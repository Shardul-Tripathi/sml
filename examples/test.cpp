ABYParty *party = new ABYParty(role, address, port, seclvl, bitlen, nthreads, mt_alg, 650000000);
vector<Sharing*>& sharings = party->GetSharings();
Circuit* ycirc = sharings[S_YAO]->GetCircuitBuildRoutine();
Circuit* acirc = sharings[S_ARITH]->GetCircuitBuildRoutine();
Circuit* bcirc = sharings[S_BOOL]->GetCircuitBuildRoutine();
MultiDimArray< uint32_t, 100, 2, 3, 4234, 432>::type a ;
MultiDimArray<share*, 100, 2, 3, 4234, 432>::type s_a_a ;
MultiDimArray< uint32_t, 100>::type b ;
MultiDimArray<share*, 100>::type s_a_b ;
MultiDimArray< uint32_t, 100>::type d ;
MultiDimArray<share*, 100>::type s_a_d ;
MultiDimArray< uint16_t, 100>::type x ;
MultiDimArray<share*, 100>::type s_a_x ;
uint32_t a1;
share *s_a_a1;
uint32_t a2;
share *s_a_a2;
s_a_a1 = acirc->PutINVGate( s_a_a2 );
share *s_y_a2 = ycirc->PutA2YGate( s_a_a2 );
share * s_y_a1 = ycirc->PutINVGate( s_y_a2 );
uint32_t _tmp_2 = 24 ;
share * s_y__tmp_2 = ycirc->PutCONSGate( _tmp_2 ,bitlen);
vector<uint32_t> _vec3 = s_y__tmp_2->get_wires();
_vec3.erase( _vec3.begin(), _vec3.begin() + 1 );
share *s_y_tmp_1 = create_new_share( _vec3 , ycirc );
share * s_y_tmp_0 = ycirc->PutOUTGate( s_y_tmp_1 , ALL);
party->ExecCircuit();
uint32_t _output = s_y_tmp_0->get_clear_value<uint32_t>();
