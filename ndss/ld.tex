%\newcommand{\kw}[1]{{\lstinline[basicstyle=\small\color{blue}]{#1}}}
\newcommand{\kw}[1]{{\ensuremath{\mathtt{#1}}}}
\newcommand{\ftext}[1]{\text{\small{#1}}}
\newcommand{\cond}[3]{\ensuremath{{{#1}\:?\:{#2}\::{#3}}}}
\newcommand{\forl}[4]{\ensuremath{\kw{for}\:{#1}\:\kw{in}\:[{#2}, {#3}]\:\kw{do}\:{#4}}}
\newcommand{\ite}[3]{\ensuremath{\kw{if}({#1}, {#2}, {#3})}}
\newcommand{\loops}[3]{\ensuremath{\kw{while}\:{#1} \leq {#2}\:\kw{do}\:{#3}}}

\section{Formal development}
\label{sec:ld}



%In this section we prove the correctness and security of our compiler.
%%
%We first formalize the source and target languages. Our source runtime
%semantics is a model of the ideal, trusted third-party semantics, and
%generates observations corresponding to the values revealed to the
%parties.
%%
%The target language semantics (a model of the C++ code generated by
%our compiler implementation) ``computes away'' the public parts and
%arrays from the compiled program, generating a secure computation
%circuit. Crucially, this semantics does not have access to the secret
%inputs--those are processed by the secure computation circuit.
%%
%Finally, we formalize the circuit semantics that computes the
%generated circuit, and like the source semantics, emits observations
%corresponding to the values revealed to the parties.
%
%We then present the compilation rules. To prove the correctness
%of our compiler, we prove that it preserves the observations. For
%security of our compiler, we reduce the security argument to the
%security of the cryptographic protocol used to compute the secure
%computation circuit.
%\nc{Should we also say that security relies on correctness? (they go together)}
%We present only selected parts of our formalization for space
%reasons. Full definitions and proofs can be found in the supplementary
%material submitted along with the paper.


In this section we prove correctness and security of our \tool compiler.
The readers who are interested in using the compiler as a black box can
move directly to  Section~\ref{sec:pipe} without loss of continuity.
%\dg{Put a warning that this section is technical and not prerequisite for understanding later section.}
%We formalize our source, intermediate and circuit languages. 
%An example of a program in our source language is provided in \figureref{ex-sml}.
%Our source runtime semantics is a model of the ideal, trusted third-party semantics, and
%generates observations corresponding to the values revealed to the
%parties.
We first formalize our source language (an example program being
\figureref{ex-sml}), and its runtime semantics.
This semantics describes the ``trusted third party"
execution semantics of the source programs and
generates observations corresponding to the values revealed to the
parties.
%
We then present the compilation rules that type check a program in the
source language and generate a program in the intermediate
language (an example program being \figureref{ex-aby}).
%
Next, we present the runtime semantics of our intermediate language
that evaluates to a circuit by ``evaluating away'' the public parts
and the arrays. Crucially, this step does not have access to the secret
inputs; those are processed by our distributed circuit semantics that
model the \mpc back-end.
%
Evaluation in this distributed setting involves the parties running an
interactive protocol. This step, like  the source semantics, emits
observations corresponding to the values revealed to the parties.
%Finally, we formalize the distributed circuit semantics (of the cryptographic back-end) that computes the generated circuit in the distributed setting, and like  the source semantics, emits observationscorresponding to the values revealed to the parties.

To prove the correctness of \tool, we prove that  the observations in
source semantics and the distributed circuit semantics are identical
(\theoremref{correctness}).
We combine this correctness theorem and the security of the \mpc
back-end to prove security of the protocols generated by \tool
(\theoremref{security}).
%For the security of our compiler, we rely on the correctness guarantee and  reduce the security to the security of the underlying cryptographic protocol used to compute the generated circuit (see \theoremref{security}).
We present only selected parts of our formalization. Full definitions, auxiliary lemmas and complete proofs (that follow from a straight-forward induction argument once the key lemmas are identified) can be found in the full version of this paper. %We will also
%release complete typeset proofs in a tech report.


%\TODO{Do we want to write things in logical order or order in paper?}

\begin{figure}[htp]
  \footnotesize
  \[
  \begin{array}{rrcl}
    \ftext{Base type} & \sigma &::=& \kw{uint} \mid \kw{bool}\\
    \ftext{Type} & \psi &::=& \sigma \mid \sigma[n]\\
    \ftext{Constant} & c &::=& n \mid \top \mid \bot\\
    \ftext{Expression} & e &::=& c \mid x \mid e_{1} \mulop e_{2} \mid e_{1} > e_{2} \mid \cond{e_{1}}{e_{2}}{e_{3}}\\
    & &\mid& [\overline{e_{i}}]_{n} \mid x[e] \mid \kw{in}_{j}\\
    \ftext{Statement} & s &::=& \psi\:x = e \mid x := e \mid \forl{x}{n_{1}}{n_{2}}{s}\\
    & & \mid& x[e_{1}] := e_{2} \mid \ite{e}{s_{1}}{s_{2}} \mid \kw{out}\:e \mid s_{1}; s_{2}\\
    & & \mid& \loops{x}{n}{s}
  \end{array}
  \]
\caption{Source language syntax}
\label{fig:srclang}
\end{figure}

\noindent\textbf{Source language.} Our language
 is a simple imperative language shown in \figureref{srclang}. Types
$\psi$ consist of the base types $\sigma$, and arrays
of base types $\sigma[n]$, where $n$ is the array length. Though we
model only one dimensional arrays, our implementation supports
 multi-dimensional arrays as well. Expressions $e$ in the language include the
 integer constants $n$, \kw{bool} constants $\top$ and $\bot$,
variables $x$, binary operations $e_{1} \mulop e_{2}$ and $e_{1} >
e_{2}$ (we support several other
operators in the implementation, detailed in \sectionref{impl}),
conditionals $\cond{e}{e_{1}}{e_{2}}$,
array literals
$[\overline{e_{i}}]_{n}$\footnote{We write $\overline{e}$ (and
  similarly for other symbols) to denote a sequence of expressions.
The length of the sequence is usually clear from the context.}, and
array reads $x[e]$. The expression $\kw{in}_{j}$ denotes input from
party $j$. The statements $s$ in the language comprise of variable
declarations, assignments,
\kw{for} loops, array writes, \kw{if}
statements, and sequence of statements. The statement
$\kw{out}\:e$ denotes revealing the value of $e$ to the
parties\footnote{Our language also has statements $\kw{out}_1\:e$ (resp., $\kw{out}_2\:e$) to reveal value of $e$ to only the first (resp., second) party. We omit these for brevity.}. The \kw{while} statement is an internal syntax that is not
exposed to the programmer. \\

\begin{figure}[htp]
  \footnotesize
  \fbox{$\rho \vdash e \Downarrow v$}\quad\quad
  \fbox{$\rho \vdash s \Downarrow \rho_{1}; O$}
  \[
  \begin{array}{c}
    \inferrule*[lab={\footnotesize{E-Var}}]
               {
               }
               {
                 \rho \vdash x \Downarrow \rho(x)
               }
               
               \hspace{0.1cm}
               
    \inferrule*[lab={\footnotesize{E-Mult}}]
               {
                 \forall i \in \{1, 2\}.\:\rho \vdash e_{i} \Downarrow n_{i}
               }
               {
                 \rho \vdash e_{1} \mulop e_{2} \Downarrow n_{1} \mulop n_{2}
               }

               \hspace{0.1cm}
               \inferrule*[lab={\footnotesize{E-Cond}}]
               {
                 \rho \vdash e \Downarrow c\\\\
                 c = \top \Rightarrow e_{3} = e_{1}\\\\
                 c = \bot \Rightarrow e_{3} = e_{2}\\\\
                 \rho \vdash e_{3} \Downarrow c_{3}
               }
               {
                 \rho \vdash \cond{e}{e_{1}}{e_{2}} \Downarrow c_{3}
               }
               
   
\\\\
	 \inferrule*[lab={\footnotesize{E-Read}}]
               {
                 \rho \vdash x \Downarrow [\overline{c_{i}}]_{n_{1}} \\\\
                 \rho \vdash e \Downarrow n \quad n < n_{1}
               }
               {
                 \rho \vdash x[e] \Downarrow c_{n}
               }
    
               \hspace{0.1cm}
    \inferrule*[lab={\footnotesize{E-Arr}}]
               {
                 \forall i \in [n].\:\rho \vdash e_{i} \Downarrow c_{i}
               }
               {
                 \rho \vdash [\overline{e_{i}}]_{n} \Downarrow [\overline{c_{i}}]_{n}
               }
               \hspace{0.1cm}
    \inferrule*[lab={\footnotesize{E-Inp}}]
               {
               }
               {
                 \rho \vdash \kw{in}_{j} \Downarrow c
               }
               \\\\
    \inferrule*[lab={\footnotesize{E-Decl}}]
               {
                 \rho \vdash e \Downarrow v
               }
               {
                 \rho \vdash \psi\:x = e \Downarrow \rho, x \mapsto v; \cdot
               }
               
               \hspace{0.1cm}

    \inferrule*[lab={\footnotesize{E-LoopT}}]
               {
                 \rho(x) > n
               }
               {
                 \rho \vdash \loops{x}{n}{s} \Downarrow \rho; \cdot
               }

               \\\\
               
    \inferrule*[lab={\footnotesize{E-LoopI}}]
               {
                 \rho(x) \leq n\\\\
                 \rho \vdash s \Downarrow \rho_{1}; O_{1}\\\\
                 \rho_{2} = [\rho_{1}]_{\mathsf{dom}(\rho)}[x \mapsto \rho_{1}(x) + 1]\\\\
                 \rho_{2} \vdash \loops{x}{n}{s} \Downarrow \rho_{3}; O_{2}
               }
               {
                 \rho \vdash \loops{x}{n}{s} \Downarrow \rho_{3}; O_{1}, O_{2}
               }

               \hspace{0.2cm}

    \inferrule*[lab={\footnotesize{E-If}}]
               {
                 \rho \vdash e \Downarrow c\\\\
                 c = \top \Rightarrow s = s_{1}\\\\
                 c = \bot \Rightarrow s = s_{2}\\\\
                 \rho \vdash s \Downarrow \rho_{1}; O
               }
               {
                 \rho \vdash \ite{e}{s_{1}}{s_{2}} \Downarrow \rho_{1}; O
               }

               \\\\
               
    \inferrule*[lab={\footnotesize{E-For}}]
               {
                 \rho, x \mapsto n_{1} \vdash \loops{x}{n_{2}}{s} \Downarrow \rho_{1}; O
               }
               {
                 \rho \vdash \forl{x}{n_{1}}{n_{2}}{s} \Downarrow \rho_{1} - \{x\}; O
               }


               \hspace{0.2cm}

    \inferrule*[lab={\footnotesize{E-Out}}]
               {
                 \rho \vdash e \Downarrow c
               }
               {
                 \rho \vdash \kw{out}\:e \Downarrow \rho; c
               }

\end{array}
  \]
\caption{Source semantics}
\label{fig:srcsem}
\end{figure}

\noindent\textbf{Source semantics.} The runtime semantics for the source language is shown in
\figureref{srcsem}. These semantics show how a ``trusted third party" computes the outputs when given the inputs of both the parties. 
 Values $v$, runtime environments $\rho$, and
observations $O$ are defined as follows:

\vspace{0.1cm}
$
\footnotesize
\begin{array}{rrcl}
    \ftext{Value} & v &::=& c \mid [\overline{c_{i}}]_{n}\\
    \ftext{Runtime environment} & \rho &::=& \cdot \mid \rho,x \mapsto v\\
    \ftext{Observation} & O & ::= & \cdot \mid c, O \\
\end{array}
$

\vspace{0.1cm}
Values consist of constants and array of constants, runtime environment
$\rho$ maps variables to values, and observations are sequences of
constants.

The judgment $\rho \vdash e \Downarrow v$ denotes the big-step
evaluation of an expression~$e$ to a value~$v$ under the runtime
environment~$\rho$. Rule ({\sc{E-Var}}) looks up the value of $x$ in
the environment. Rule ({\sc{E-Mult}}) inductively evaluates $e_{1}$ and
$e_{2}$, and returns their product. Rule ({\sc{E-Read}})
evaluates an array read operation. It first evaluates $x$ to an array
value $[\overline{c_{i}}]_{n_{1}}$, and $e$ to a \kw{uint} value
$n$. It then returns $c_{n}$, the $n$-th index value in the array,
provided $n < n_{1}$, the length of the array. Rule ({\sc{E-Inp}})
evaluates to some constant $c$ denoting party $j$'s input. 
%We model the inputs to be base constants, a
An array input can be written in the
language as $[\kw{in}_{j}]_{n}$, which can then evaluate using the
rule ({\sc{E-Arr}}) (the notation $\forall i \in [n]$ is read
  as $\forall i \in \{0\dots n - 1\}$). The remaining rules are
straightforward, and are elided for space reasons.

The judgment $\rho \vdash s \Downarrow \rho_{1}; O$ represents the
big-step evaluation of a statement $s$ under environment $\rho$,
producing a new environment $\rho_{1}$ and observations $O$. Rule
({\sc{E-Decl}}) evaluates the expression $e$ to $v$, and returns the
updated environment $\rho,x \mapsto v$, with empty observations. The
$\kw{for}$ statements evaluate
through the internal $\kw{while}$ syntax. Specifically, the rule
({\sc{E-For}}) appends $\rho$ with $x\mapsto n_{1}$,
evaluates $\loops{x}{n_{2}}{s}$ to $\rho_{1}; O$, and returns
$\rho_{1} - \{x\}$ (removing $x$ from $\rho_{1}$) and $O$. Rule
({\sc{E-LoopI}}) shows the inductive case for \kw{while}
statements, when $\rho(x) \leq n$. The rule evaluates $s$, producing
$\rho_{1}; O_{1}$. It then restricts $\rho_{1}$ to the domain of
$\rho$ ($[\rho_{1}]_{\mathsf{dom}(\rho)}$) to remove the variables
added by $s$, increments the value of $x$, and evaluates the
\kw{while} statement under this updated environment. Rule
({\sc{E-LoopT}}) is the termination case for \kw{while},
when $\rho(x) > n$. Finally, the rule ({\sc{E-Out}}) evaluates the
expression, and adds its value to the observations.

\newcommand{\lcond}[4]{\ensuremath{{{#2}\:?_{{#1}}\:{#3}\::{#4}}}}
%\newcommand{\forl}[4]{\ensuremath{\kw{for}\:{#1}\:\kw{in}\:[{#2}, {#3}]\:\kw{do}\:{#4}}}
%\newcommand{\ite}[3]{\ensuremath{\kw{if}({#1}, {#2}, {#3})}}
%\newcommand{\loops}[3]{\ensuremath{\kw{while}\:{#1} \leq {#2}\:\kw{do}\:{#3}}}

\begin{figure}[htp]
  \footnotesize
  \[
  \begin{array}{rrcl}
    \ftext{Secret label} & m &::=& \mathcal{A} \mid \mathcal{B}\\
    \ftext{Label} & \ell &::=& \mathcal{P} \mid m\\
    \ftext{Type} & \tau &::=& \sigma^{\ell} \mid \sigma^{\ell}[n]\\
    \ftext{Expression} & \widetilde{e} &::=& c \mid x \mid \widetilde{e}_{1} \mulop_{\ell} \widetilde{e}_{2} \mid \widetilde{e}_{1} >_{\ell} \widetilde{e}_{2} \mid x[\widetilde{e}] \mid [\,\overline{\widetilde{e}}_{i}]_{n} \\
    & & \mid & \lcond{\ell}{{\widetilde{e}}}{{\widetilde{e}}_{1}}{{\widetilde{e}}_{2}} \mid \kw{in}^{m}_{j} \mid \langle \ell \rhd m \rangle\:\widetilde{e}\\
    \ftext{Statement} & \widetilde{s} &::=& \tau\:x = \widetilde{e} \mid x := \widetilde{e} \mid \dots \mid \widetilde{s}_{1}; \widetilde{s}_{2} \mid \dots\\
  \end{array}
  \]
\caption{Intermediate language syntax}
\label{fig:interlang}
\end{figure}

\noindent\textbf{Intermediate language.} \figureref{interlang} shows the
intermediate language of our compiler. The syntax follows that of the source
language, except that the types and operators are \emph{labeled}. 
%Below we mainly focus on the bits that are different from the source
%language.
A label $\ell$ can be the  public label $\mathcal{P}$ or  one of the secret labels $\mathcal{A}$ or
$\mathcal{B}$, which denote arithmetic and boolean respectively.
Types $\tau$ are then
labeled base types $\sigma^{\ell}$ and arrays of labeled base types
$\sigma^{\ell}[n]$.
Most of the expression forms $\widetilde{e}$ are same as $e$, except
that the binary operators, and the conditional forms
are annotated with labels $\ell$.
Looking ahead, the label determines how the operators are
evaluated: $\mathcal{P}$-labeled operators are evaluated in-clear, $\mathcal{A}$-labeled operators generate arithmetic circuits, and
$\mathcal{B}$-labeled operators generate boolean circuits. The
form $\langle \ell \rhd m \rangle\:\widetilde{e}$ denotes coercing
$\widetilde{e}$ from label $\ell$ to label $m$.
%The statements $\widetilde{s}$ are analogous to $s$.

\noindent\textbf{Source to intermediate compilation.} We provide the compilation
rules in \figureref{compile}. We present the rules in a
declarative style, where the rules are non-syntax
directed, and the labels $\ell$ are chosen
non-deterministically. \sectionref{impl} describes the label  inference
scheme in our implementation.

\begin{figure}[t]
  \footnotesize
  \fbox{$\Gamma \vdash e : \tau \leadsto \widetilde{e}$}\quad\quad
  \fbox{$\Gamma \vdash s \leadsto \widetilde{s} \mid \Gamma_{1}$}  \[
  \begin{array}{c}
     \inferrule*[lab={\footnotesize{T-UInt}}]
               {
               }
               {
                 \Gamma \vdash n : \kw{uint}^{\mathcal{P}} \leadsto n
               }
               \hspace{0.1cm}
     \inferrule*[lab={\footnotesize{T-Bool}}]
               {
                 c = \top \vee c = \bot
               }
               {
                 \Gamma \vdash c : \kw{bool}^{\mathcal{P}} \leadsto c 
               }

               \hspace{0.1cm}
                \inferrule*[lab={\footnotesize{T-Inp}}]
               {
               }
               {
                 \Gamma \vdash \kw{in}_{j} : \sigma^{m} \leadsto \kw{in}^{m}_{j}
               }
               \\\\
	  \inferrule*[lab={\footnotesize{T-Mult}}]
               {
                 \forall i \in \{1,2\}.\:\Gamma \vdash e_{i} : \kw{uint}^{\ell} \leadsto \widetilde{e}_{i}\\\\
                 \left(\ell = \mathcal{P}\right) \vee \left(\ell = \mathcal{A}\right)
               }
               {
                 \Gamma \vdash e_{1} \mulop e_{2} : \kw{uint}^{\ell} \leadsto \widetilde{e}_{1} \mulop_{\ell} \widetilde{e}_{2}
               }
               
     \inferrule*[lab={\footnotesize{T-Gt}}]
               {
                 \forall i \in \{1,2\}.\:\Gamma \vdash e_{i} : \kw{uint}^{\ell} \leadsto \widetilde{e}_{i}\\\\
                 \left(\ell = \mathcal{P}\right) \vee \left(\ell = \mathcal{B}\right)
               }
               {
                 \Gamma \vdash e_{1} > e_{2} : \kw{bool}^{\ell} \leadsto \widetilde{e}_{1} >_{\ell} \widetilde{e}_{2}
               }

     
\\\\               

	\inferrule*[lab={\footnotesize{T-Read}}]
               {
                 \Gamma \vdash x : \sigma^{\ell}[n] \leadsto x\\\\
                 \Gamma \vdash e : \kw{uint}^{\mathcal{P}} \leadsto \widetilde{e}\\\\
                  \models e < n
               }
               {
                 \Gamma \vdash x[e] : \sigma^{\ell} \leadsto x[\widetilde{e}]
               }


     \inferrule*[lab={\footnotesize{T-Cond}}]
               {
                 \Gamma \vdash e : \kw{bool}^{\ell} \leadsto \widetilde{e}\\\\
                 \forall i \in \{1,2\}.\:\Gamma \vdash e_{i} : \sigma^{\ell_{1}} \leadsto \widetilde{e}_{i}\\\\
                 \ell = \mathcal{P} \vee (\ell = \mathcal{B} \wedge \ell_{1} =\mathcal{B})
               }
               {
                 \Gamma \vdash \cond{e}{e_{1}}{e_{2}} : \sigma^{\ell_{1}} \leadsto \lcond{\ell}{\widetilde{e}}{\widetilde{e}_{1}}{\widetilde{e}_{2}}
               }
               
\\\\               

     \inferrule*[lab={\footnotesize{T-Arr}}]
               {
                 \forall i \in [n].\:\Gamma \vdash e_{i} : \sigma^{\ell} \leadsto \widetilde{e}_{i}
               }
               {
                 \Gamma \vdash [\overline{e_{i}}]_{n} : \sigma^{\ell}[n] \leadsto [\,\overline{\widetilde{e}}_{i}]_{n}
               }

     \inferrule*[lab={\footnotesize{T-Sub}}]
               {
                 \Gamma \vdash e : \sigma^{\ell} \leadsto \widetilde{e}
               }
               {
                 \Gamma \vdash e : \sigma^{m} \leadsto \langle \ell \rhd m \rangle\:\widetilde{e}
               }
\\\\
     \inferrule*[lab={\footnotesize{T-Decl}}]
               {
                 \Gamma \vdash e : \psi^{\ell} \leadsto \widetilde{e}
               }
               {
                 \Gamma \vdash \psi\:x = e \leadsto \psi^{\ell}\:x = \widetilde{e} \mid \Gamma, x:\tau
               }

     \inferrule*[lab={\footnotesize{T-Assgn}}]
               {
                 \Gamma(x) = \sigma^{\ell}\\\\
                 \Gamma \vdash e : \sigma^{\ell} \leadsto \widetilde{e}
               }
               {
                 \Gamma \vdash x := e \leadsto x := \widetilde{e} \mid \Gamma
               }

\\\\

     \inferrule*[lab={\footnotesize{T-For}}]
               {
                 \Gamma, x:\kw{uint}^{\mathcal{P}} \vdash \loops{x}{n_{2}}{s} \leadsto \loops{x}{n_{2}}{\widetilde{s}} \mid \_
               }
               {
                 \Gamma \vdash \forl{x}{n_{1}}{n_{2}}{s} \leadsto \forl{x}{n_{1}}{n_{2}}{\widetilde{s}} \mid \Gamma
               }

               \\\\

     \inferrule*[lab={\footnotesize{T-Write}}]
               {
                 \Gamma \vdash x : \sigma^{\ell}[n] \leadsto x\\\\
                 \Gamma \vdash e_{1} : \kw{uint}^{\mathcal{P}} \leadsto \widetilde{e_{1}}\\\\
                 \Gamma \vdash e_{2} : \sigma^{\ell} \leadsto \widetilde{e_{2}}\\\\
                  \models e_{1} < n
               }
               {
                 \Gamma \vdash x[e_{1}] := e_{2} \leadsto x[\widetilde{e_{1}}] := \widetilde{e_{2}} \mid \Gamma
               }

     \inferrule*[lab={\footnotesize{T-Out}}]
               {
                 \Gamma \vdash e : \sigma^{m} \leadsto \widetilde{e}
               }
               {
                 \Gamma \vdash \kw{out}\:e \leadsto \kw{out}\:\widetilde{e} \mid \Gamma
               }

\\\\

     \inferrule*[lab={\footnotesize{T-If}}]
               {
                 \Gamma \vdash e : \kw{bool}^{\mathcal{P}} \leadsto \widetilde{e}\\\\
                 \forall i \in \{1, 2\}.\:\Gamma \vdash s_{i} \leadsto \widetilde{s}_{i} \mid \_
               }
               {
                 \Gamma \vdash \ite{e}{s_{1}}{s_{2}} \leadsto \ite{\widetilde{e}}{\widetilde{s}_{1}}{\widetilde{s}_{2}}  \mid \Gamma
               }

     \inferrule*[lab={\footnotesize{T-Seq}}]
               {
                 \Gamma \vdash s_{1} \leadsto \widetilde{s}_{1} \mid \Gamma_{1}\\\\
                 \Gamma_{1} \vdash s_{2} \leadsto \widetilde{s}_{2} \mid \Gamma_{2}
               }
               {
                 \Gamma \vdash s_{1}; s_{2} \leadsto \widetilde{s}_{1}; \widetilde{s}_{2} \mid \Gamma_{2}
               }

\\\\

     \inferrule*[lab={\footnotesize{T-While}}]
               {                 
                 \Gamma(x) = \kw{uint}^{\mathcal{P}}\quad
                 \Gamma \vdash s \leadsto \widetilde{s} \mid \_\quad
                 x \notin \mathsf{modifies}(s)
               }
               {
                 \Gamma \vdash \loops{x}{n_{2}}{s} \leadsto \loops{x}{n_{2}}{\widetilde{s}} \mid \Gamma
               }

  \end{array}
  \]
\caption{Source compilation}
\label{fig:compile}
\end{figure}
%\vspace{-0.2in}

The judgment $\Gamma \vdash e : \tau \leadsto \widetilde{e}$, where
$\Gamma$ maps variables $x$ to types $\tau$, says that
under $\Gamma$, $e$ (in the source language) compiles to $\widetilde{e}$
(in the intermediate language), where $\widetilde{e}$ has type $\tau$.
Rules ({\sc{T-UInt}}) and ({\sc{T-Bool}}) assigns the label
$\mathcal{P}$ to the constants, as the constants are always
public. Rule ({\sc{T-Mult}})
compiles a multiplication to either a public multiplication  ($\mulop_{\mathcal{P}}$), or a
secret arithmetic multiplication ($\mulop_{\mathcal{A}}$). As
our compiler is cryptographic cost aware, it never compiles the
multiplication to boolean multiplication $\mulop_{\mathcal{B}}$ (\sectionref{impl}). In a similar manner,
rule ({\sc{T-Gt}}) compiles $e_{1} > e_{2}$ to either public comparison,
or secret boolean comparison $>_\mathcal{B}$ (and never
$>_{\mathcal{A}}$).
%
The rule for conditional
({\sc{T-Cond}}) has two cases: when the conditional expression $e$ is of
type $\kw{bool}^{\mathcal{P}}$, both the branches have a base type
$\sigma^{\ell_{1}}$, for an arbitrary $\ell_{1}$, and the conditional is
compiled to a public conditional, whereas when the conditional
expression has type $\kw{bool}^{\mathcal{B}}$, $\ell_{1}$ is also
$\mathcal{B}$, and the conditional is compiled to a secret conditional
using a boolean circuit. Note that we restrict the type of the branches
to be of base type. 
Rule ({\sc{T-Read}}) type checks an array read. It checks
that the array index $e$ is public, and uses a static bounds checking
judgment $ \models e < n$ to prove that the array index is in
bounds \footnote{\sectionref{impl} discusses our implementation of this
check.}. Rule ({\sc{T-Inp}}) picks a label $m$ for the input. Finally,
the rule ({\sc{T-Sub}}) is the subsumption rule that coerces an expression of
type $\sigma^{\ell}$ to an expression of type $\sigma^{m}$ using the
coerce expression. It is important for security that the secrets
cannot be coerced to public values and indeed ({\sc{T-Sub}}) does not
permit it.

Judgment $\Gamma \vdash s : \tau \leadsto \widetilde{s} \mid \Gamma_{1}$
compiles a statement $s$ resulting in the statement $\widetilde{s}$
and type environment $\Gamma_{1}$. Rule ({\sc{T-Decl}}) picks a label
$\ell$, and adds the binding for $x$ to the environment (if $\psi =
\sigma$, $\psi^\ell = \sigma^\ell$, else if $\psi = \sigma[n]$,
$\psi^\ell = \sigma^\ell[n]$).
Rule ({\sc{T-Assign}}) looks up the type of $x$ in $\Gamma$ and compiles $e$ to $\tilde{e}$ of same type.
Note that in this rule we restrict the type of variable $x$ to be of base type.
Rule ({\sc{T-For}}) adds the loop counter $x$ to $\Gamma$ at type
$\kw{uint}^{\mathcal{P}}$, and delegates type checking to the
\kw{while} form. Rule ({\sc{T-Out}})
types the expression $e$ at some secret label $m$. Rule ({\sc{T-If}})
checks that the conditional expression is public, and rule
({\sc{T-Seq}}) sequences the type environments. Finally, the typing
rule for the (internal) \kw{while} form ensures that $x$ is mapped in
$\Gamma$ at type $\kw{uint}^{\mathcal{P}}$, and that the statement $s$
does not modify $x$ ($x \notin
\mathsf{modifies}(s)$)--this is necessary for ensuring termination.


\begin{figure}
  \footnotesize
  \[
  \begin{array}{rrcl}
    \ftext{Wire id} & \wire &&\\
    \ftext{Circuit gate} & \gate & ::= & \wire \mid \kw{in}^{m}_{j} \mid \kw{mult}\:\gate_1\:\gate_{2} \mid \kw{gt}\:\gate_{1}\:\gate_{2}\\
    & & \mid & \kw{mux}\:\gate\:\gate_{1}\:\gate_{2} \mid \langle \ell
    \rhd m \rangle\:\gate \mid c\\
    \ftext{Sub-circuit} & \val & ::= & \gate \mid [\overline{\gate_{i}}]_{n}\\
    %\ftext{Runtime environment} & \widetilde{\rho} & ::= & \cdot \mid \widetilde{\rho},x \mapsto \val \\
    \ftext{Circuit} & \crct & ::= & \cdot \mid \kw{bind}\:\gate\:\wire \mid \kw{out}\:\gate \mid \crct_{1}; \crct_{2}
  \end{array}
  \]
\caption{Circuits  syntax}
\label{fig:circuits}
\end{figure}

As mentioned earlier, the intermediate language models the code such
as in \figureref{ex-aby} output by our compiler.
Next, a program in the intermediate language is evaluated to a circuit
that can be executed in the distributed runtime later. The evaluation
to a circuit computes away the public parts of the program and also
\emph{flattens} the arrays so that the circuits are unaware of the
array structure.
Crucially, this phase of the semantics does not have access to the
secret inputs.
Below, we first provide the language for the circuits followed by the
evaluation rules.

\noindent\textbf{Evaluation to Circuits.}
\figureref{circuits} shows the syntax of circuits. A wire id range
$\wire$ denotes a set of circuit wires that carry the runtime value of a
 variable with a secret label (we will concretely define these runtime
values later as part of the circuit semantics). Circuit gates $\gate$
are wires $\wire$, input gates $\kw{in}^m_j$, multiplication gates \kw{mult}, comparison gates \kw{gt}, and multiplexer \kw{mux} gates, 
coerce gates $\langle \ell \rhd m \rangle$, and constants.
Sub-circuits $\val$ (generated from $\widetilde e$) then consist of
gates and arrays of gates.  A circuit $\crct$ is either empty, \kw{bind}-ing of a
circuit gate $\gate$ to wire $\wire$, \kw{out} gate, or a sequence of
circuits.

\begin{figure}[h]
  \footnotesize
  \fbox{$\widetilde{\rho} \vdash \widetilde{e} \Downarrow \val$}\quad\quad
  \fbox{$\widetilde{\rho} \vdash \widetilde{s} \Downarrow \widetilde{\rho}_{1}; \crct$}
  \[
  \begin{array}{c}
    \inferrule*[lab={\footnotesize{S-Var}}]
               {
               }
               {
                 \widetilde{\rho} \vdash x \Downarrow \widetilde{\rho}(x)
               }
               
    \inferrule*[lab={\footnotesize{S-PMult}}]
               {
                 \forall i \in \{1, 2\}.\:\widetilde{\rho} \vdash \widetilde{e}_{i} \Downarrow n_{i}
               }
               {
                 \widetilde{\rho} \vdash \widetilde{e}_{1} \mulop_{\mathcal{P}} \widetilde{e}_{2} \Downarrow n_{1} \mulop n_{2}
               }
               
    \inferrule*[lab={\footnotesize{S-Read}}]
               {
                 \widetilde{\rho} \vdash x \Downarrow [\overline{\wire_i}]_{n_{1}} \\\\
                 \widetilde{\rho} \vdash \widetilde{e} \Downarrow n \quad n < n_{1}
               }
               {
                 \widetilde{\rho} \vdash x[\widetilde{e}] \Downarrow \wire_n
               }\\\\
    \inferrule*[lab={\footnotesize{S-SMult}}]
               {
                 \forall i \in \{1, 2\}.\:\widetilde{\rho} \vdash \widetilde{e}_{i} \Downarrow \gate_{i}
               }
               {
                 \widetilde{\rho} \vdash \widetilde{e}_{1} \mulop_{\mathcal{A}} \widetilde{e}_{2} \Downarrow \kw{mult}\:\gate_{1}\:\gate_{2}
               }

               \hspace{0.3cm}

    \inferrule*[lab={\footnotesize{S-SGt}}]
               {
                 \forall i \in \{1, 2\}.\:\widetilde{\rho} \vdash \widetilde{e_{i}} \Downarrow \gate_{i}
               }
               {
                 \widetilde{\rho} \vdash \widetilde{e_{1}} >_{\mathcal{B}} \widetilde{e_{2}} \Downarrow \kw{gt}\:\gate_{1}\:\gate_{2}
               }\\\\
               \inferrule*[lab={\footnotesize{S-SCond}}]
               {
                 \forall i \in \{1, 2, 3\}.\:\widetilde{\rho} \vdash \widetilde{e}_{i} \Downarrow \gate_{i}
               }
               {
                 \widetilde{\rho} \vdash \lcond{\mathcal{B}}{\widetilde{e}_{1}}{\widetilde{e}_{2}}{\widetilde{e}_{3}} \Downarrow \kw{mux}\:\gate_{1}\:\gate_{2}\:\gate_{3}
               }
               \hspace{0.2cm}
    \inferrule*[lab={\footnotesize{S-Coerce}}]
               {
                 \widetilde{\rho} \vdash \widetilde{e} \Downarrow \gate
               }
               {
                 \widetilde{\rho} \vdash \langle \ell \rhd m \rangle\:
                 \widetilde{e} \Downarrow \langle \ell \rhd m \rangle\:\gate
               }
               \\\\
               %% \inferrule*[lab={\footnotesize{S-Arr}}]
               %% {
               %%   \forall i \in \{0 \dots n - 1\}.\:\widetilde{\rho} \vdash \widetilde{e_{i}} \Downarrow \widetilde{w_{i}}
               %% }
               %% {
               %%   \widetilde{\rho} \vdash [\overline{\widetilde{e_{i}}}]_{n} \Downarrow [\overline{\widetilde{w_{i}}}]_{n}
               %% }

               \inferrule*[lab={\footnotesize{S-PCond}}]
               {
                 \widetilde{\rho} \vdash \widetilde{e} \Downarrow c\\\\
                 c = \top \Rightarrow \widetilde{e}_{3} = \widetilde{e}_{1}\\
                 c = \bot \Rightarrow \widetilde{e}_{3} = \widetilde{e}_{2}\\\\
                 \widetilde{\rho} \vdash \widetilde{e}_{3} \Downarrow \val
               }
               {
                 \widetilde{\rho} \vdash \lcond{\mathcal{P}}{\widetilde{e}}{\widetilde{e}_{1}}{\widetilde{e}_{2}} \Downarrow \val
               }
               %\hspace{0.5cm}
               
    \inferrule*[lab={\footnotesize{S-Inp}}]
               {
               }
               {
                 \widetilde{\rho} \vdash \kw{in}^{m}_{j} \Downarrow \kw{in}^{m}_{j}
               }
               \\\\
    \inferrule*[lab={\footnotesize{S-DeclC}}]
               {
                 \widetilde{\rho} \vdash \widetilde{e} \Downarrow \val\\\\
                 \left(\val = c\right) \vee \left(\val = [\overline{c_{i}}]_{n}\right)
               }
               {
                 \widetilde{\rho} \vdash \tau\:x = \widetilde{e} \Downarrow \widetilde{\rho}, x \mapsto \val; \cdot
               }
               
               \hspace{0.2cm}

    \inferrule*[lab={\footnotesize{S-DeclCkt}}]
               {
                 \widetilde{\rho} \vdash \widetilde{e} \Downarrow \gate\quad\quad
                 \mathsf{fresh}\:\wire
               }
               {
                 \widetilde{\rho} \vdash \tau\:x = \widetilde{e} \Downarrow \widetilde{\rho}, x \mapsto \wire; \kw{bind}\:\gate\:\wire
               }

\\\\
    \inferrule*[lab={\footnotesize{S-DeclCktA}}]
               {
                 \widetilde{\rho} \vdash \widetilde{e} \Downarrow [\overline{\gate_{i}}]_{n}\\\\
                 \forall i \in [n].\:\mathsf{fresh}\:\wire_{i}
               }
               {
                 \widetilde{\rho} \vdash \tau\:x = \widetilde{e} \Downarrow \widetilde{\rho}, x \mapsto [\overline{\wire_{i}}]_{n}; \overline{\kw{bind}\:\gate_{i}\:\wire_{i}}
               }

               \hspace{0.2cm}
               
    \inferrule*[lab={\footnotesize{S-Out}}]
               {
                 \widetilde{\rho} \vdash \widetilde{e} \Downarrow \gate
               }
               {
                 \widetilde{\rho} \vdash \kw{out}\:\widetilde{e} \Downarrow \widetilde{\rho}; \kw{out}\:\gate
               }

               \\\\
    \inferrule*[lab={\footnotesize{S-If}}]
               {
                 \widetilde{\rho} \vdash \widetilde{e} \Downarrow c\\\\
                 c = \top \Rightarrow \widetilde{s} = \widetilde{s_{1}}\\\\
                 c = \bot \Rightarrow \widetilde{s} = \widetilde{s_{2}}\\\\
                 \widetilde{\rho} \vdash \widetilde{s} \Downarrow \widetilde{\rho}_{1}; \crct
               }
               {
                 \widetilde{\rho} \vdash \ite{\widetilde{e}}{\widetilde{s_{1}}}{\widetilde{s_{2}}} \Downarrow \widetilde{\rho}_{1}; \crct
               }

               \hspace{0.5cm}
               
    \inferrule*[lab={\footnotesize{S-WriteCkt}}]
               {
                 \widetilde{\rho} \vdash x \Downarrow [\overline{\wire_{i}}]_{n}\quad
                 \widetilde{\rho} \vdash \widetilde{e}_{1} \Downarrow n_{1}\\\\
                 n_{1} < n\quad
                 \mathsf{fresh}\:\wire\quad
                 \widetilde{\rho} \vdash \widetilde{e}_{2} \Downarrow \gate\\\\
                 \widetilde{\rho}_{1} = \widetilde{\rho}[x \mapsto ([\overline{\wire_{i}}]_{n}[n_{1} \mapsto \wire])]
               }
               {
                 \widetilde{\rho} \vdash x[\widetilde{e}_{1}] := \widetilde{e}_{2} \Downarrow \widetilde{\rho}_{1}; \kw{bind}\:\gate\:\wire
               }

\end{array}
  \]
\caption{Evaluation of Intermediate Language to Circuit}
\label{fig:eval-inter-circ}
\end{figure}

\figureref{eval-inter-circ} shows the judgments for the evaluation of
the intermediate language to a circuit. The circuit generation environment maps
variables to sub-circuits:

\vspace{0.2cm}
$
\footnotesize
\begin{array}{rrcl}
    \ftext{Circuit generation environment} & \widetilde\rho &::=& \cdot \mid \widetilde\rho,x \mapsto \val\\
\end{array}
$
\vspace{0.2cm}

We first focus on the expression evaluation judgment
$\widetilde{\rho} \vdash \widetilde{e} \Downarrow\val$. 
%
Rules ({\sc{S-PMult}}) and ({\sc{S-SMult}}) illustrate
the significance of the operator labels. In particular, the rule
({\sc{S-PMult}}) evaluates a public multiplication $\widetilde{e}_{1}
\mulop_{\mathcal{P}} \widetilde{e}_{2}$ to $n_{1} \mulop n_{2}$, similar to the
source semantics of \figureref{srcsem}. In contrast, the rule
({\sc{S-SMult}}) evaluates a secret multiplication $\widetilde{e}_{1}
\mulop_{\mathcal{A}} \widetilde{e}_{2}$ to an arithmetic multiplication
gate $\kw{mult}\:\gate_{1}\:\gate_{2}$. As mentioned above, the intermediate language
expressions generated by our compiler never have $\widetilde{e}_{1}
\mulop_{\mathcal{B}} \widetilde{e}_{2}$, as our compiler is aware that $\mulop$
is more performant using an arithmetic circuit compared to a boolean
one~\cite{aby}. Rules ({\sc{S-PCond}}) and ({\sc{S-SCond}})
are along similar lines. Rule ({\sc{S-PCond}}) evaluates a public
conditional to the sub-circuit  from one of the branches, while the rule
({\sc{S-SCond}}) evaluates to a multiplexer \kw{mux} gate that takes as  input
the sub-circuits from the guard ($\gate_{1}$) and both the branches
($\gate_{2}$ and $\gate_{3}$). Recall, for performance reasons,
the  expressions in the intermediate language generated by our compiler do not have
$\lcond{\mathcal{A}}{e_{1}}{e_{2}}{e_{3}}$. Rules
({\sc{S-Coerce}}) and ({\sc{S-Inp}}) evaluate to coerce and input
gates respectively.

Statement evaluation $\widetilde{\rho} \vdash \widetilde{s} \Downarrow
\widetilde{\rho}_{1}; \chi$ evaluates a statement $\widetilde{s}$ under 
the environment $\widetilde{\rho}$  to produce a new
environment $\widetilde{\rho}_{1}$, and a circuit $\crct$. Rules ({\sc{S-DeclC}}), ({\sc{S-DeclCkt}}), and
({\sc{S-DeclCktA}}) show the variable declaration cases. Rule
({\sc{S-DeclC}}) shows the case when $\widetilde{e}$ evaluates to
$\val$, where $\val$ is either a constant or an
array of constants. In this case, the mapping $x \mapsto
\val$ is added to the environment, and the resulting circuit
is empty. When 
$\widetilde{e}$ evaluates to a sub-circuit $\gate$, rule
({\sc{S-DeclCkt}}) picks a fresh wire $\wire$, adds the mapping $x \mapsto \wire$
to the environment $\widetilde{\rho}$, and outputs the circuit
$\kw{bind}\:\gate\:\wire$. The rule ({\sc{S-DeclCktA}}) is analogous for
$\widetilde{e}$ evaluating to an  array of sub-circuits. The variable
assignment rules (not shown in the figure) are similar. The rule
({\sc{S-WriteCkt}}) shows the case for writing to an array, where the
array contents are secret. Finally, rule ({\sc{S-Out}}) compiles to an
\kw{out} circuit.

\noindent\textbf{Circuit semantics.} Evaluating a program in the
intermediate language produces a
circuit to be computed using a distributed \mpc protocol. With
our circuit semantics, we model the \emph{functional} aspect
of a \mpc protocol, parametrized by cryptographic encoding and
decoding functions.

During the circuit evaluation, the wire ids $w$ are
mapped to (random) strings $b$. The semantics of these strings is
given by pairs of encode-decode algorithms, written as
$\mathcal{E}_{m}$ and $\mathcal{D}_{m}$ (where $m$ is either
$\mathcal{A}$ or $\mathcal{B}$). 
More concretely,
$\mathcal{E}_{m}(c)$ returns a pair of strings $(b_{1}, b_{2})$
 with the property that
$\mathcal{D}_{m}(b_{1}, b_{2}) = c$. 
The string $b_j$ denotes the $j^{th}$ party's {\it share} of $c$.
We assume that the underlying \mpc
protocol instantiates $\mathcal{E}_{m}$ and $\mathcal{D}_{m}$
appropriately. For ABY protocol \cite{aby}, algorithms
$(\mathcal{E}_{\mathcal{A}},\mathcal{D}_{\mathcal{A}})$
(resp. $(\mathcal{E}_{\mathcal{B}},\mathcal{D}_{\mathcal{B}})$)
correspond to the arithmetic (resp. boolean) secret-sharing and
reconstruction algorithms.


\figureref{cktsem} gives the judgments for evaluation of circuits by
the two parties using a \mpc protocol. The circuit environment  is a
map from wires to shares:

\vspace{0.2cm}
$
\footnotesize
\begin{array}{rrcl}
    \ftext{Circuit environment} & \widehat\rho &::=& \cdot \mid \widehat\rho,\wire \mapsto b\\
\end{array}
$
\vspace{0.2cm}

We use $\widehat\rho_j$ to denote the circuit environment for party $j.$ 
We give the 
judgments $\widehat{\rho}_{1}, \widehat{\rho}_{2} \vdash \gate
\Downarrow b_{1}, b_{2}$, and $\widehat{\rho}_{1}, \widehat{\rho}_{2}
\vdash \chi \Downarrow \widehat{\rho}'_{1}, \widehat{\rho}'_{2}; O$,
where $O$ are the observations (similar to source semantics). 
The former judgment evaluates a gate under the environments
$\widehat{\rho}_j$ and generates shares $b_j$ of the gate's output.
Rule ({\sc{C-In}}) evaluates the input gate $\kw{in}^{m}_{j}$, and
creates the $m$-type shares of the value $c$ input by party $j$.
Rule ({\sc{C-Mult}}) illustrates the pattern for evaluating circuit
gates $\gate$. To evaluate $\kw{mult}\:\gate_{1}\:\gate_{2}$, the
rule first evaluates $\gate_{1}$ to $(b_{11}, b_{21})$ and
$\gate_{2}$ to $(b_{12}, b_{22})$. Shares $(b_{11}, b_{21})$ are then
combined using $\mathcal{D_{\mathcal{A}}}$ to $n_{1}$, and similarly
$(b_{12}, b_{22})$ are combined to $n_{2}$. The final output of the
\kw{mult} gate is then $\mathcal{E}_{\mathcal{A}}(n_{1} \mulop n_{2})$. Note
that this is a functional description of how the \kw{mult} gate
evaluates, of course, concretely $n_{1}$ and $n_{2}$ are not observed
by the parties. Rule ({\sc{C-Coerce}}) creates the new shares using
$\mathcal{E}_m$ (the corresponding rule for coercion from
$\mathcal{P}$ is similar). The evaluation
of \kw{bind} updates the mapping of $\wire$ in the input environments, and
the rule ({\sc{C-Out}}) outputs the clear value $c$ to the
observations.




\begin{figure}
  \footnotesize
  \fbox{$\widehat{\rho}_{1}, \widehat{\rho}_{2} \vdash \gate \Downarrow b_{1}, b_{2}$}\quad\quad
  \fbox{$\widehat{\rho}_{1}, \widehat{\rho}_{2} \vdash \crct \Downarrow \widehat{\rho}'_{1}, \widehat{\rho}'_{2}; O$}
  \[
  \begin{array}{c}
    %% \inferrule*[lab={\footnotesize{C-Wire}}]
    %%            {
    %%              b_{1}, b_{2} = \widehat{\rho_{1}}(r), \widehat{\rho_{2}}(r)
    %%            }
    %%            {
    %%              \widehat{\rho_{1}}, \widehat{\rho_{2}} \vdash r \Downarrow b_{1}, b_{2}
    %%            }               
    \inferrule*[lab={\footnotesize{C-In}}]
               {
                 (b_{1}, b_{2}) = \mathcal{E}_{m}(c)
               }
               {
                 \widehat{\rho}_{1}, \widehat{\rho}_{2} \vdash \kw{in}^{m}_{j} \Downarrow b_{1}, b_{2}
               }

               \hspace{0.3cm}
               
    \inferrule*[lab={\footnotesize{C-Coerce}}]
               {
                 \widehat{\rho}_{1}, \widehat{\rho}_{2} \vdash \gate \Downarrow b_{1}, b_{2}\\\\
                 (b'_{1}, b'_{2}) = \mathcal{E}_{m}(\mathcal{D}_{m_{1}}(b_{1}, b_{2}))
               }
               {
                 \widehat{\rho}_{1}, \widehat{\rho}_{2} \vdash \langle
                 m_{1} \rhd m \rangle\:g \Downarrow b'_{1}, b'_{2}
               }

               \\\\

    \inferrule*[lab={\footnotesize{C-Mult}}]
               {
                 \forall i \in \{1, 2\}.\:\widehat{\rho}_{1}, \widehat{\rho}_{2} \vdash \gate_{i} \Downarrow b_{1i}, b_{2i}\quad
                 n_{i} = \mathcal{D}_{\mathcal{A}}(b_{1i}, b_{2i})\\\\
                 (b_{1}, b_{2}) = \mathcal{E}_{\mathcal{A}}(n_{1} \mulop n_{2})
               }
               {
                 \widehat{\rho}_{1}, \widehat{\rho}_{2} \vdash \kw{mult}\:\gate_{1}\:\gate_{2} \Downarrow b_{1}, b_{2}
               }

\\\\

    \inferrule*[lab={\footnotesize{C-Gt}}]
               {
                 \forall i \in \{1, 2\}.\:\widehat{\rho}_{1}, \widehat{\rho}_{2} \vdash \gate_{i} \Downarrow b_{1i}, b_{2i}\quad
                 n_{i} = \mathcal{D}_{\mathcal{B}}(b_{1i}, b_{2i})\\\\
                 (b_{1}, b_{2}) = \mathcal{E}_{\mathcal{B}}(n_{1} > n_{2})
               }
               {
                 \widehat{\rho}_{1}, \widehat{\rho}_{2} \vdash \kw{gt}\:\gate_{1}\:\gate_{2} \Downarrow b_{1}, b_{2}
               }

\\\\

    \inferrule*[lab={\footnotesize{C-Mux}}]
               {
                 \forall i \in \{1, 2, 3\}.\:\widehat{\rho}_{1}, \widehat{\rho}_{2} \vdash \gate_{i} \Downarrow b_{1i}, b_{2i}\quad
                 c_{i} = \mathcal{D}_{\mathcal{B}}(b_{1i}, b_{2i})\\\\
                 (c_{1} = \top) \Rightarrow \left((b_{1}, b_{2}) = \mathcal{E}_{\mathcal{B}}(c_{2})\right)\hspace{0.1cm}
                 (c_{1} = \bot) \Rightarrow \left((b_{1}, b_{2}) = \mathcal{E}_{\mathcal{B}}(c_{3})\right)
               }
               {
                 \widehat{\rho}_{1}, \widehat{\rho}_{3} \vdash \kw{mux}\:\gate_{1}\:\gate_{2}\:\gate_{3} \Downarrow b_{1}, b_{2}
               }

  \\\\
    \inferrule*[lab={\footnotesize{C-Bind}}]
               {
                 \widehat{\rho}_{1}, \widehat{\rho}_{2} \vdash \gate \Downarrow b_{1}, b_{2}\\\\
                 \widehat{\rho}'_{1} = \widehat{\rho}_{1}[\wire \mapsto b_{1}] \quad
                 \widehat{\rho}'_{2} = \widehat{\rho}_{2}[\wire \mapsto b_{2}]
               }
               {
                 \widehat{\rho}_{1}, \widehat{\rho}_{2} \vdash \kw{bind}\:\gate\:\wire \Downarrow \widehat{\rho}'_{1}, \widehat{\rho}'_{2}; \cdot
               }
               
               \hspace{0.1cm}

    \inferrule*[lab={\footnotesize{C-Out}}]
               {
                 \widehat{\rho}_{1}, \widehat{\rho}_{2} \vdash \gate \Downarrow b_{1}, b_{2}\\\\
                 c = \mathcal{D}_{m}(b_{1}, b_{2})
               }
               {
                 \widehat{\rho}_{1}, \widehat{\rho}_{2} \vdash \kw{out}\:\gate \Downarrow \widehat{\rho}_{1}, \widehat{\rho}_{2}; c
               }
\end{array}
  \]
\caption{Circuit semantics in a distributed runtime}
\label{fig:cktsem}
\end{figure}

\noindent\textbf{Correctness Theorem.} We prove that all well typed programs always terminate successfully (array indices are always in bounds, there are no unbounded loops, etc.) and the \mpc protocol produces the same outputs as the source program. That is, if a source statement $s$ is well-typed, and compiles to $\widetilde{s}$ in the intermediate language, then $s$ terminates in the source semantics with observations $O$, $\widetilde{s}$ evaluates to circuit $\crct$, and $\crct$ terminates in the circuit semantics with the same observations $O$. Formally, the correctness theorem is as follows (the environments on the left of $\vdash$ are empty and we elide the environments on the right of $\vdash$ for brevity):


%\subsubsection*{Correctness theorem}

%Finally, the correctness theorem is as follows (the environments onthe left of $\vdash$ are empty and we elide the environments on the right of $\vdash$ for brevity):

\begin{theorem}[Correctness]\label{theorem:correctness}
 $\forall\: s, \widetilde{s}$, if $\vdash s \leadsto \widetilde{s}
  \mid \_$  then $\exists  O , \chi$, s.t.  $\vdash s \Downarrow \_;
  O$, $ \vdash \widetilde{s} \Downarrow \_; \chi$, and $ \vdash \chi
  \Downarrow \_, \_; O$.
\end{theorem}

%%\old{The theorem states that if a source statement $s$ is well-typed, and
%compiles to $\widetilde{s}$ in the intermediate language, then $s$ terminates in the source
%semantics with observations $O$, $\widetilde{s}$ evaluates to circuit $\crct$, and $\crct$ terminates in the
%circuit semantics with the same observations $O$. 
%Therefore, well typed programs always terminate (array indices are always in bounds, there are no unbounded loops, etc.) and the \mpc protocol produces the same outputs as the source program.}

We prove the theorem in the full version. %Appendix~\ref{app:formal}.
% We first define a judgment for
%translation of environments, $\Gamma \vdash \rho \leadsto
%\widetilde{\rho}; \widehat{\rho}_{1}, \widehat{\rho}_{2}$. The
%judgment is defined inductively on $\Gamma$, and establishes that
%the static environment $\Gamma$ is consistent with the runtime
%environments $\rho$, $\widetilde{\rho}$, and $\widehat{\rho}_{1}$ and
%$\widehat{\rho}_{2}$. 
%As an example, if $x:\kw{uint}^{\mathcal{P}} \in
%\Gamma$, the judgment checks that $\rho(x) = \widetilde{\rho}(x) =
%n$, for some $n$. On the other hand, if $x:\kw{uint}^{m} \in
%\Gamma$ then the judgment checks that $\mathcal{D}_m( \widehat{\rho}_{1}(\widetilde{\rho}(x)),\widehat{\rho}_{2}(\widetilde{\rho}(x)))=\rho(x)$.
%%We elide the judgment, providing the full definition
%%in the supplementary material.
%With this judgment,
%the correctness theorem is as follows:
%
%\begin{theorem}[Correctness]\label{theorem:correctness}
%  $\forall\:\Gamma, s, \widetilde{s}, \Gamma_{1}, \rho, \widetilde{\rho}, \widehat{\rho}_{1}, \widehat{\rho}_{2}$, if:
%
%  \begin{enumerate}
%  \item $\Gamma \vdash s \leadsto \widetilde{s} \mid \Gamma_{1}$
%  \item $\Gamma \vdash \rho \leadsto \widetilde{\rho}; \widehat{\rho}_{1}, \widehat{\rho}_{2}$
%  \end{enumerate}
%
%  then $\exists \rho_{1}, O_{1}, \widetilde{\rho}_{1}, \chi, \widehat{\rho}'_{1}, \widehat{\rho}'_{2}, O_{2}$, s.t.
%
%  \begin{enumerate}[label=(\alph*)]
%  \item $\rho \vdash s \Downarrow \rho_{1}; O_{1}$
%  \item $\widetilde{\rho} \vdash \widetilde{s} \Downarrow \widetilde{\rho}_{1}; \chi$
%  \item $\widehat{\rho}_{1}, \widehat{\rho}_{2} \vdash \chi \Downarrow \widehat{\rho}'_{1}, \widehat{\rho}'_{2}; O_{2}$
%  \item $\Gamma_{1} \vdash \rho_{1} \leadsto \widetilde{\rho}_{1}; \widehat{\rho}'_{1}, \widehat{\rho}'_{2}$
%  \item $O_{1} = O_{2}$
%  \end{enumerate}
%  
%\end{theorem}
%
%The theorem states that if a source statement $s$ is well-typed, and
%compiles to $\widetilde{s}$ in intermediate language, then $s$ terminates in the source
%semantics with observations $O_{1}$, $\widetilde{s}$ evaluates to circuit $\crct$, and $\crct$ terminates in the
%circuit semantics with observations $O_{2}$, where $O_{1} = O_{2}$
%%Furthermore, the final environments are also in the compilation
%%relation. \divya{Should we call the judgment between environs as compilation relation?}
%Due to space reasons, we provide the proof in \cite{anonymized}.

