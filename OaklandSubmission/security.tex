\divya{Start here......}
\subsubsection*{Security theorem} The protocols we generate provide
simulation-based security against a semi-honest adversary, in the
framework of ~\cite{gmw,can00,can01}. At a very high level, in this
framework, parties are modeled as non-uniform interactive turing
machines (ITMs), with inputs provided by an environment $\env$. An
adversary $\adv$, selects and ``corrupts'' one of the parties -
however, $\adv$ still follows the protocol specification. $\adv$
interacts with the $\env$, which observes the view of the corrupted
party. At the end of the interaction, $\env$ outputs a single bit. Two
different interactions are defined: the {\em real world} and an {\em
  ideal world}. In the real interaction, the parties run the protocol
$\prot$ in the presence of $\adv$ and $\env$. Let
$\real_{\prot,\adv,\env}$ denote the binary distribution ensemble
describing $\env$'s output in this interaction. In the ideal
interaction, parties send their inputs to an additional entity, a
trusted functionality machine $\F$ that carries the desired
computation truthfully. Let $\simu$ (the simulator) denote the
adversary in this idealized execution, and $\ideal_{\F,\simu,\env}$
the binary distribution ensemble describing $\env$'s output after
interacting with adversary $\simu$ and ideal functionality $\F$. A
protocol $\prot$ is said to {\em securely realize} a functionality
$\F$ if for every adversary $\adv$ in the real interaction, there is
an adversary $\simu$ in the ideal interaction, such that no
environment $\env$, on any input, can tell the real interaction apart
from the ideal interaction, except with negligible probability (in the
security parameter $\secparam$). More precisely, if the two binary
distribution ensembles above are computationally indistinguishable. 

We shall assume a cryptographic MPC backend that securely implements any circuit $\chi$ that is output by our compiler. In more detail, this means that for every source program $s$, let $\chi$ be the circuit output by our compiler (as in Theorem \ref{theorem:correctness}). We assume that there exists a two-party secure computation protocol $\prot$ that securely realizes the functionality $\chi$ and we will call the corresponding simulator for the protocol as $\simu_{\tiny{2pc}}$ (that runs on input $\chi$ and the output produced by $\chi$ on the parties inputs). We note that the work of \cite{aby} provides such a protocol $\prot$ and simulator $\simu_{\tiny{2pc}}$ for all circuits $\chi$ output by our compiler. We are now ready to state and prove our security theorem.
 
\begin{theorem}[Security]\label{theorem:security}
Let $s$ be any functionality or program in our source language with outputs (or observations) $O_1$, that is compiled into a circuit $\chi$ (as defined in Theorem \ref{theorem:correctness}). Let protocol $\prot$ be the two-party secure computation protocol that securely realizes $\chi$ (as defined above). Then, $\prot$ securely realizes $s$.  
\end{theorem}

\noindent {\em Proof.} Our simulator $\simu$ simply runs our compiler on program $s$ to obtain $\chi$ and upon receiving output $O_1$, executes $\simu_{\tiny{2pc}}$ on $\chi$ and $O_1$. Let $O_2$ be the outputs (or observations) of $\chi$. First, from Theorem \ref{theorem:correctness}, we have that the observations in $s$ and $\chi$ are the same (i.e. $O_2 = O_1$). Now, from the security of $\prot$, we have that the simulated view output by $\simu_{\tiny{2pc}}$ (with circuit $\chi$ and output $O_2$) is indistinguishable from the real view of the $\prot$ (when executed on circuit $\chi$ and when the output is $O_2$). Combining these two statements, the proof of the theorem follows. 
\aseem{Can we give a construction of the simulator S in the ideal
  semantics? The simulator S whenever it receives an observable event,
  outputs it to Z, and whenever A receives a string in the real
  semantics, S outputs a random string to Z. Now, with theorem 1,
  observable events are same in the ideal and real semantics, and with
  the security of the crypto backend, the random strings and the
  strings in the protocol are indistinguishable. Is it
  incorrect/naive?

  Also, we should emaphasize here that the ideal semantics is the
  source semantics from Figure x and the real semantics is the circuit
  semantics from Figure y. For the target language semantics, we
  should emphasize that it does not have access to the secrets, so
  there are no observations there.
}

\nc{OK now?}
  %% \\
  %% \[
  %% \begin{array}{rrcl}
  %%   \ftext{Value} & v &::=& c \mid [\overline{c_{i}}]_{n}\\
  %%   \ftext{Observation} & O &::=& \cdot \mid c; O\\
  %% \end{array}
  %% \]
