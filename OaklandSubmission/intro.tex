\aseem{Is the title too general :). May be we want something more
  specific on the lines of A compiler for mixed efficient MPC
  protocols, or something?}
  
  \divya{Do we write the intro for \mpc or 2PC?}

\section{Introduction}
\label{sec:intro}

Today it is hard for developers to create secure implementations using cryptographic techniques.
Typical developers lack an understanding of cryptographic protocols
and cannot be expected to implement them correctly and efficiently without tool
support.
In an ideal world, a developer declares the functionality to be implemented
in a general purpose programming language and an automatic tool takes care
of all the cryptography and generates a secure and efficient implementation  of the functionality. 
This paper provides a language-based solution to make
secure  computation  accessible to the software developer community. 

%Most cryptographic tools rely on circuit as abstractions for any general computation but real-life developers write programs. It is critical to address this fundamental  representation gap to make cryptography accessible to non-crypto specialist developers. In this work, we address this gap for the case of secure multi-party computation.

%Most cryptographic tools are very hard to use non-crypto specialist developers. The task becomes even more tedious and error-prone for the case of secure multiparty computation since different protocol implementations require the function to be expressed in different representations such as Boolean or Arithmetic circuits. To make cryptography accessible to non-crypto specialist developers, we need to design systems that do crypto automatically and satisfy the properties of ... 

Secure two-party computation (\mpc) \cite{yao,gmw} is a powerful
cryptographic tool that allows two mutually distrusting parties
to compute a joint function of their secret inputs such as {\em secure prediction} \cite{shafindss,wu,barni,minionn,secureml}. Here,  one party holds the propriety classifier for disease, genomics or spam detection and the other party  
holds the private input and the second party learns the classification label such as the presence of the disease. Since its introduction
\mpc in 1980's, there has been a long sequence of work that has
transformed \mpc from a mere theoretical tool to something practically
efficient and usable. Hence, there have been efforts to make \mpc
accessible to non-specialist programmers. To understand the
state-of-the-art, let us consider the following 
example that is the sub-computation in many classification tasks.

Suppose a developer wants to compute $w^Tx >b$ securely using
\mpc, where $w$ and $x$ are two vectors, $b$ is a scalar, and $w^Tx$ denotes the inner product of $w$ and $x$.  With the current techniques, he has three options. \aseem{We should
  use she for the programmer instead of he?}
\begin{tiret}
\item He can code up the functionality in a programmer friendly
  domain-specific language such as
  \cite{lambdaps,wysteria,oblivm,smcl,cbmcgc} that would automatically
  compile it to a \mpc protocol. The downside is that all of these
  works build on a cryptographic back-end that takes as input a functionality expressed as either a boolean circuit \cite{yao,gmw} or an arithmetic circuit \cite{homo}.
  The efficiency of the generated \mpc protocol is hence, bounded by the possibility of efficiently representing the functionality in one of these circuit representations. For instance, multiplication of two $\ell$-bit integers can be expressed as a boolean circuit of size  $O(\ell^2)$ or an arithmetic circuit with 1 multiplication gate. 
Hence, for better efficiency, we would like to securely compute $w^Tx$ using an arithmetic circuit and the comparison with $b$ using a boolean circuit. \divya{that is not supported by above systems.}
In fact, most interesting functions require a mix of arithmetic and boolean computations for efficiency.

\item To address this issue of efficient representation, recently Demmler et al. \cite{aby} gave a cryptographic protocol for \mpc where the functionality can be expressed as a circuit with a mix of both arithmetic and boolean parts.
Hence, the second option is to write the functionality in the system developed in \cite{aby}.
However, in their framework, the programmer is required to write circuits consisting of  arithmetic and boolean gates along with appropriate
inter-conversion gates.
This requires the programmer to be aware of
trade-offs between arithmetic and boolean cryptographic
schemes as well as the complex inter-conversion costs between arithmetic and boolean, and manually split the functionality into such parts accordingly.  
In short, as is also mentioned by Demmler et al., the current system  is not suitable
to be used by non-specialist programmers without security expertise.

\item Finally, the third option is to hire a cryptographer to design a specialized efficient protocol for this functionality such as \cite{shafindss,wu,minionn}. 
\end{tiret}
In our work, we achieve the best of all the above options. 



%Unfortunately, implementing functionalities using \mpc protocols requires thorough understanding of cryptography. To allow for widespread use of \mpc, it is critical that \mpc protocols are programmable by non-cryptographic experts. To cater to this, there have been several efforts developing domain-specific languages that are programmer friendly and compile to a SMC protocol. Most notable of these domain specific languages and systems include \cite{...}. All of these works build on a cryptographic back-end that is either entirely boolean \cite{yao,gmw} or arithmetic \cite{homo}. In fact, most of these works use boolean circuits based scheme for completeness\footnote{Note that comparisons cannot be expressed in arithmetic circuits}. However, most interesting functions require a mix of arithmetic and boolean computations.  Examples include ......... As one can expect, compiling these programs to boolean circuits is one of the biggest efficiency bottlenecks. \divya{Our work addresses this performance bottleneck.}

%To address this issue \divya{on the cryptographic side}, recently Demmler et al. \cite{aby} gave a cryptographic protocol for SMC where the parties can mix arithmetic and boolean computations and claimed potentially great performance benefits. However, using their system requires the programmer to be aware of trade-offs of arithmetic and boolean cryptographic schemes. In their framework, the programmer is required to write circuits consisting of a mix of arithmetic and boolean gates along with appropriate conversion gates. In short, as is also mentioned by the authors themselves, the current system is not suitable to be used by non-specialist programmers.


%%%%%%%Recent works \cite{aby,secureml,minion} have shown that great performance benefit can be obtained by mixing arithmetic and boolean computations in the back-end. Certain computations such as integer multiplication are efficient when implemented using arithmetic SMC \cite{gmw} whereas max(x,0) needs to be computed using a boolean back-end \cite{yao}. More details later.. ABY \cite{aby} requires programmer to be aware of arithmetic and boolean trade-offs and  write high-level circuits consisting of both arithmetic and boolean gates and share-conversion gates. Other works such as \cite{secureml,minion} build on ideas from \cite{aby} and develop tailor made algorithms for neural network training and prediction \cite{ml} and claim huge improvements over only boolean implementations. As is already mentioned in these works, their systems are mere proofs-of-concept and far from being implementable.



%\divya{old para...} In this work, we develop and implement our framework \tool\footnote{\tool, read as ``easy peasy'', stands for Easy 2 Party Computation} for secure
%computation that achieves generality, performance and programmer
%productivity. The programmer writes a high level \divya{C-like}
%program (instead of a circuit) to describe the function to be
%computed. Our compiler automatically generates an \mpc protocol using a
%mix of Arithmetic and Boolean compute. Our compiler is general and can
%work with any secure implementation of a mix of arithmetic and boolean
%computations. In our work, we focus on semi-honest secure two-party
%computation. We build on ABY \cite{aby} that provides the suitable
%cryptographic back-end in this setting. We provide a formal type
%system and prove correctness and security of our compiler. We evaluate
%our system on various benchmarks such as logistic regression and
%convolutional neural network (CNN) for MNIST data \cite{minionn},
%naive bayes, decision trees from \cite{shafindss}. Evaluations show
%that protocols generated by our compiler match
%the performance or outperform hand-crafted protocols in most cases (see
%\sectionref{eval}). Below, we will  give an overview of \tool and
%describe our contributions in more detail.

%The programmer is oblivious of the cryptographic back-end being used. Our compiler automatically compiles it to a circuit framework consisting to both arithmetic and boolean gates as well share-conversion gates wherever required. We use ABY as the cryptographic backend. \divya{Say something about what kind of backend we want. provides \mpc for a mix of arithmetic and boolean circuit with appropriate secure conversion between two types and ABY provides such a framework for semi-honest 2pc.} Our work is compatible with malicious, multiparty as well... etc We give a type system, correctness ..... We evaluate our framework on ... and show performance comparable and even better than tailor made protocols. It is simple to program in our framework and our work provides a meaningful baseline for future works designing tailor made protocols for specific functionalities.

\subsection{\tool: Overview and Contributions} 
\label{sec:contrib}
%Write high level overview of programming language and tool.. \divya{have some preamble}

In this work, we develop and implement our framework \tool\footnote{\tool, read as ``easy peasy'', stands for Easy 2 Party Computation} for secure
computation. We provide the first compiler where the developer writes a high-level program and the compiler automatically generates an efficient \mpc protocol that uses a
mix of arithmetic and boolean circuits. 
It is compatible with any implementation of \mpc that allows a mix of arithmetic and boolean circuits. 
We focus on semi-honest secure two-party computation and use ABY \cite{aby} as the suitable cryptographic back-end.
We provide a formal type system and operational semantics for our language and prove correctness and security of our compiler.
We evaluate our system on wide range of benchmarks for secure prediction \cite{shafindss,wu,barni,secureml,minionn,bonsai} using linear classifier, decision trees and deep neural networks, matrix factorization \cite{valeriaMatrix} and training of deep neural network \cite{secureml}. Our evaluations show that protocols generated by our compiler match
the performance or outperform hand-crafted protocols in most cases (see
\sectionref{eval}). \TODO{Add some text to increase enthusiasm about results.} Moreover, unlike previous systems such as \cite{wysteria,aby}, our system can scale to arbitrarily large computations using {\em secure code partitioning} (see below). \divya{I think we can skip Yao pipelining here, right?}
Hence, we show that our framework achieves all four properties of programmability, generality, performance, and scalability. 

Prior to our work, there have been systems that provide only a subset of the above properties and lack in remaining properties. For instance, using the framework of CBMC-GC \cite{cbmcgc}, one can write functionalities in high-level language like C but it gives poor performance due to its usage of boolean circuits as underlying representation. Similarly, ABY framework can potentially give good performance but is not programmable. Technique of pipelining Yao garbled circuits \cite{yao-pipe} allowed scaling to lage circuits but gives poor performance. \divya{what about programming?} To summarize, none of the prior frameworks could be used to evaluate the benchmarks such as linear regression, deep neural network prediction etc. In fact, it was widely believed that generic 2PC would not scale to the secure prediction and hence, various protocols were hand-crafted for this task \cite{shafindss,wu,secureml,minionn}. Our framework contradicts this belief.

In this work, we solve an interesting design problem to give a user friendly language that is expressive enough together with a compiler generating efficient secure 2PC protocols.
Programmability and performance of our system has enabled us to write large programs whose circuits  exhaust the memory of the system (~32 GB). To combat this issue, we give a technique called pipelining (see below) that allows scaling of our  scaling of our framework to arbitrary size computations.

Below, we describe the salient features of \tool in more detail.


\textbf{Programmability.} \tool is a programmer-friendly framework to
express the function to be computed and uses a mix of arithmetic and
boolean \mpc back-ends. We illustrate the above toy example of $w^Tx
>b$ in our language in \figureref{ex-sml}. As is clear from the code,
the programmer is not required to write keywords such as {\em secret}
or {\em public} and can remain completely oblivious of the
cryptographic back-end. In contrast, \figureref{ex-aby} illustrates
the same example using the framework in ABY \cite{aby}. Here, as
already mentioned, the programmer needs to write the low level gates
like {\tt MULT, ADD, CONS, GT}, etc. The programmer is also required
to use the appropriate share conversion gates such as {\tt A2Y} that
converts Arithmetic shares to Yao shares. Moreover, it is easy to
maintain code in \tool and small change to the functionality requires
only a small change in the code. In contrast, working with ABY, even
for a small change a developer might have to re-work the whole circuit
for efficiency reasons. We describe these examples in detail in
\sectionref{ex}.

\textbf{Performance.} Our compiler is aware of cryptographic costs of different representations and inter-conversions.  Based on these costs, our compiler, given a program in \tool, automatically picks Arithmetic and Boolean representations for different sub-parts of the program and inserts the required inter-conversions as well. 
Our experiments show that automatically generated protocols using \tool match the performance of tailor-made protocols in \cite{minionn,shafindss} (see \sectionref{eval}). This shows that  \tool achieves generality, performance and programmer productivity. These features allow us to evaluate our system on a variety of benchmarks, especially, state-of-the-art ML prediction algorithms with \emph{real} data and models. 

\textbf{Type system.} We give a formal {\em type system} for our language and prove useful properties. We prove that if a program type checks in our language then it would run correctly, e.g., there would not be any array index out of bounds error. The programmer writes a single code describing the inputs from each party and the function to be computed. Our compiler automatically generates separate executables for the server and the client that can be executed in the distributed setting. We prove the {\em correctness} for this compilation, i.e., the outputs obtained in the distributed execution are identical to the stand-alone execution by a trusted third party. We formally reduce the {\em security} of our system to the security of the cryptographic back-end. For details on formal language, correctness and security theorems see \sectionref{ld}.


\textbf{Pipelining.} Another issue in adoption of \mpc is difficulty in scaling to large programs. 
%In general, \mpc implementations struggle in scaling to large programssize of memory on a system limits the largest compute inside the SMC and hence,. 
The reason being all \mpc implementations use a circuit-like representation as an intermediate representation. Hence, the largest compute that can be done securely is upper-bounded by the largest circuit that can fit in memory on a machine. \nc{Should we point out here that ABY itself has an explicit limit on circuit size and also give an example of a program that easily surpasses this bound? Also, hadnt ABY also said something about this? If so, we can mention this.}
To address this issue, we develop a technique called \emph{pipelining} that allows us to run arbitrarily large programs. At a high level, we break the original program into a sequence of small sub-programs and mask the intermediate outputs using secure secret sharing between the two parties. We appropriately append the share-reconstruction function to the beginning of the subsequent sub-program. Now, we execute each of these sub-programs sequentially in our framework. We provide details of pipelining and prove the correctness and security of this transformation in \sectionref{pipe}.

\textbf{Baseline.} Finally, our framework \tool can serve as a meaningful baseline for future works on hand-crafted \mpc protocols for specific functionalities such as \textsc{MiniONN} \cite{minionn}. 
Prior to our work, garbled circuit based two-party computation is cited as the most practical approach and used as the baseline for comparison of performance. But, it has been observed multiple times this approach does not even scale on realistic examples.



%\newpage
%\divya{ideally have small paragraphs about key features}
%1. ease to programming.. refer to section with example in our language; contrast to verilog paper; programmer is completely oblivious of security; looks like a normal/vanilla/ regular C program;
%Moreover, the developer does not write keywords such as secret and public; 
%
%
%2. first programmable system that supports a mix of arithmetic and boolean for efficiency give example of multiplication of integers; linear algebra; logistic regression and evaluate on state of the art ML prediction tasks
%
%3. prove correctness, type system guarantees correct termination, progress etc..; 
%
%%In contrast with most systems that require a programmer to label variables as public secret, we automatically infer them. leads to more efficiency compared to default secret
%
%If program type-checks then runs correctly for example no array out of bound errors
%code runs correctly in distributed env
%programmer writes one code; compiles to server code and client code
%we prove and outputs identical to stand-alone output
%distributed code produces same output as if the code were run by distributed third party
%
%
%4. Scaling to large programs. Describe pipeling here... Like all MPC implementations use an intermediate rep as a circuit and largest compute that can run is given by largest circuit that can fit in memory are restricted by memory of machines. This in turn limits the size of functions 
%We implement/give/design a generic technique called pipelining that allow us to run arbitrarily large computations without affecting security.
%
%
%5. Previous papers when comparing with generic 2pc compare with Yao; does not scale etc...
%can serve as a baseline for future works on hand-crafted algorithms for specific applications cite minion etc here...
%




\vspace{10pt}

\noindent\textbf{Other Related Work} 
Before ABY \cite{aby}, to improve efficiency, several works proposed
to mix secure computation protocols based on homomorphic
encryption with Yao’s garbled circuits protocol, e.g., \cite{barni,blanton,brickell,franz,huang,valeriaMatrix,valeriaRidge,schropferK11}
  and developed tools that allowed writing a mixed \mpc protocol, e.g., \cite{bogdanov,lone,tasty}. The assignment can
even be done automatically as was shown in \cite{autoS}. 
However, as noted by ABY, due to high conversion cost between homomorphic encryption and Yao's garbled circuit, these mixed protocols do not gain much over single protocol. Also, none of these works give a high-level developer-friendly language support.
No prior work has given a formal type system and operational semantics for mixed arithmetic and boolean back-ends.
In our evaluation, we use benchmarks for the problem of secure prediction where the cloud holds the secret model and the client holds the secret input. For this problem various works have considered tailor-made protocols depending on the model considered \cite{shafindss,wu,secureml,minionn}. In our evaluation, we compare our performance with these specialized protocols and give competitive run-times. We provide a detailed survey of related work in \sectionref{related}.
