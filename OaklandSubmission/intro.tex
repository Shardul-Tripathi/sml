\section{Introduction}
\label{sec:intro}

Most cryptographic tools rely on circuit as abstractions for any general computation but real-life developers write programs. It is critical to address this fundamental  representation gap to make cryptography accessible to non-crypto specialist developers. In this work, we address this gap for the case of secure multi-party computation.

Secure multi-party computation \cite{yao,gmw} (SMC) is a powerful cryptographic tool that allows a set of mutually distrusting parties to compute a joint function of their secret inputs. Examples of these include various machine learning prediction algorithm where one party holds the secret input such as a medical report and the other party holds the ML model for disease prediction. Since the introduction of SMC in 1980's, there has been a large body of work \cite{..} that has transformed SMC from a mere theoretical tool to something practically efficient/usable. Hence, there have been efforts to make SMC accessible to non-specialist programmers. To understand the state-of-the-art, let us consider the following toy example.

Suppose a developer wants to compute $w^Tx >0$ securely using SMC. With the current techniques, he has two options. He can code up the functionality in a programmer friendly domain-specific language such as \cite{lambdaps,wysteria,oblivm} that would automatically compile it to an SMC protocol. The downside is that all of these works build on a cryptographic back-end that is either entirely boolean \cite{yao,gmw} or entirely arithmetic \cite{homo}. The efficiency of the generated SMC protocol is hence, bounded by the possibility of efficiently representing the function in a form that is compatible with the cryptographic back-end used. For instance, over $\ell$-bit integers, multiplication requires a boolean circuit of size  $O(\ell^2)$. 
For better efficiency, we would like to evaluate $w^Tx$ using an Arithmetic circuit and the comparison using a boolean circuit.
In fact, most interesting functions require a mix of arithmetic and boolean computations.
To address this issue, recently Demmler et al. \cite{aby} gave a cryptographic protocol for SMC where the parties can mix arithmetic and boolean computations. \footnote{Need to note somewhere that many works combined HE and Yao. Look at ABY for references.}
Hence, the second option is to write the functionality in the system developed in \cite{aby}.
However, using their system requires the programmer to be aware of complex trade-offs between arithmetic and boolean cryptographic schemes. In their framework, the programmer is required to write circuits consisting of  arithmetic and boolean gates along with appropriate conversion gates. In short, as is also mentioned by the authors themselves, the current system is not suitable to be used by non-specialist programmers. \divya{Change tone...}
Our work .....



%Unfortunately, implementing functionalities using SMC protocols requires thorough understanding of cryptography. To allow for widespread use of SMC, it is critical that SMC protocols are programmable by non-cryptographic experts. To cater to this, there have been several efforts developing domain-specific languages that are programmer friendly and compile to a SMC protocol. Most notable of these domain specific languages and systems include \cite{...}. All of these works build on a cryptographic back-end that is either entirely boolean \cite{yao,gmw} or arithmetic \cite{homo}. In fact, most of these works use boolean circuits based scheme for completeness\footnote{Note that comparisons cannot be expressed in arithmetic circuits}. However, most interesting functions require a mix of arithmetic and boolean computations.  Examples include ......... As one can expect, compiling these programs to boolean circuits is one of the biggest efficiency bottlenecks. \divya{Our work addresses this performance bottleneck.}

%To address this issue \divya{on the cryptographic side}, recently Demmler et al. \cite{aby} gave a cryptographic protocol for SMC where the parties can mix arithmetic and boolean computations and claimed potentially great performance benefits. However, using their system requires the programmer to be aware of trade-offs of arithmetic and boolean cryptographic schemes. In their framework, the programmer is required to write circuits consisting of a mix of arithmetic and boolean gates along with appropriate conversion gates. In short, as is also mentioned by the authors themselves, the current system is not suitable to be used by non-specialist programmers.


%%%%%%%Recent works \cite{aby,secureml,minion} have shown that great performance benefit can be obtained by mixing arithmetic and boolean computations in the back-end. Certain computations such as integer multiplication are efficient when implemented using arithmetic SMC \cite{gmw} whereas max(x,0) needs to be computed using a boolean back-end \cite{yao}. More details later.. ABY \cite{aby} requires programmer to be aware of arithmetic and boolean trade-offs and  write high-level circuits consisting of both arithmetic and boolean gates and share-conversion gates. Other works such as \cite{secureml,minion} build on ideas from \cite{aby} and develop tailor made algorithms for neural network training and prediction \cite{ml} and claim huge improvements over only boolean implementations. As is already mentioned in these works, their systems are mere proofs-of-concept and far from being implementable.

In this work, we develop and implement our framework \tool where the programmer writes a high level C-like program (instead of a circuit) to describe the function to be computed. Our compiler automatically converts this program to a suitable SMC protocol that uses both arithmetic and boolean secure computation components as well as the correct conversion protocols whenever required. Our compiler is general and can work with any secure implementation of a mix of arithmetic and boolean computations. In our work, we focus on semi-honest secure two-party computation and  ABY \cite{aby} provides the suitable cryptographic back-end. \divya{We provide a formal type system.... } We evaluate our system on various benchmarks such as logistic regression and convolutional neural network (CNN) for MNIST data \cite{minionn}, naive bayes, decision trees from \cite{shafindss}. Evaluations show that protocols generated by our compiler match the performance of hand-crafted protocols in most cases (see \ref{sec:eval}). \divya{Below, we will  give an overview of \tool and describe our contributions.}

%The programmer is oblivious of the cryptographic back-end being used. Our compiler automatically compiles it to a circuit framework consisting to both arithmetic and boolean gates as well share-conversion gates wherever required. We use ABY as the cryptographic backend. \divya{Say something about what kind of backend we want. provides SMC for a mix of arithmetic and boolean circuit with appropriate secure conversion between two types and ABY provides such a framework for semi-honest 2pc.} Our work is compatible with malicious, multiparty as well... etc We give a type system, correctness ..... We evaluate our framework on ... and show performance comparable and even better than tailor made protocols. It is simple to program in our framework and our work provides a meaningful baseline for future works designing tailor made protocols for specific functionalities.

\subsection{\tool: Overview and Contributions} Write high level overview of programming language and tool..

\divya{ideally have small paragraphs about key features}
1. ease to programming.. refer to section with example in our language; contrast to verilog paper; programmer is completely oblivious of security; looks like a normal/vanilla/ regular C program;
Moreover, the developer does not write keywords such as secret and public; 
\input{fig-ex-aby}
\input{fig-ex-sml}

2. first programmable system that supports a mix of arithmetic and boolean for efficiency give example of multiplication of integers; linear algebra; logistic regression and evaluate on state of the art ML prediction tasks

3. prove correctness, type system guarantees correct termination, progress etc..; 

%In contrast with most systems that require a programmer to label variables as public secret, we automatically infer them. leads to more efficiency compared to default secret

If program type-checks then runs correctly for example no array out of bound errors
code runs correctly in distributed env
programmer writes one code; compiles to server code and client code
we prove and outputs identical to stand-alone output
distributed code produces same output as if the code were run by distributed third party


4. Scaling to large programs. Describe pipeling here... Like all MPC implementations use an intermediate rep as a circuit and largest compute that can run is given by largest circuit that can fit in memory are restricted by memory of machines. This in turn limits the size of functions 
We implement/give/design a generic technique called pipelining that allow us to run arbitrarily large computations without affecting security.


5. Previous papers when comparing with generic 2pc compare with Yao; does not scale etc...
can serve as a baseline for future works on hand-crafted algorithms for specific applications cite minion etc here...







\noindent\textbf{Related Work}
\cite{lambdaps,wysteria}

\divya{Useful phrases:} progress in practical efficiency; non-specialist programmers; fundamental representation gap; circuits as an abstraction of computation; task becomes even more tedious, time-consuming, and error-prone,
since each secure computation protocol has its own
representation in which a functionality has to be described, e.g.,
Arithmetic vs. Boolean circuits.

\divya{useful thoughts} It is widely believed that garbled circuit based 2pc is most practical; but not quite true..

\divya{points that have to be there...} Security; traces are ``oblivious'' of secret values if observables/outputs are same; formal cryptographic security guarantee uses simulation paradigm \cite{canetti2000} 


\divya{not sure if we wanna say anything about these} 1. all the programs written in our language are memory trace oblivious because array indices are public 2. instruction trace obliviousness handled by using a multiplexor or executing both branches.. plus all loops are public counters. Our type system rejects programs that loop on secret variables

\divya{questions:} Does ABY allow secret array indices? or does it allow arrays? thats not so important actually

\divya{Related Work: writing some citations here to be used appropriately.}
\begin{enumerate}
\item Secure Computation of MIPS Machine Code %https://eprint.iacr.org/2015/547
\item TASTY https://eprint.iacr.org/2010/365.pdf

\end{enumerate}


There have been many languages and compilers that compile to cryptographic backends
exception of TASTY

\divya{where to put this.. 6. Suitable to use multiple crypto backends; We formalize the guarantees needed from crypto backend; it is easy for expert programmers to to extend our framework for example add another SMC backend. say more about this later... there say that possible to integrate minion's more efficient matrix based preprocessing into our framework and matrix ops as native types and instructions in our language}

\newpage