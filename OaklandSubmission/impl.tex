\section{Implementation}
\label{sec:impl}
The  \tool compiler is written in Python and
compiles each of our benchmarks in under a second to C++ code that makes calls to the ABY
library~\cite{aby}. We use the default options of ABY except 
for the maximum number of gates. \nc{What are these options? Do we want to spell it out?} Our benchmarks require us to set this value to a
hundred million.\nc{I dont fully follow this. Why require us to set it to 100 million? Are we saying that because of the size of data etc and type of protocol generated by our benchmark, we limit the max gates to 100 million (when ABY supports up to 4 billion) so that we dont run into memory issues?} ABY provides facilities to use multiple threads\footnote{The protocol has an offline phase and an online phase. Although multiple threads can be used in the offline phase, the online phase is single threaded.}.
We use at most four threads in our evaluation.\nc{ABY did say that more than 4 threads didnt help them, right? Should we say that this is why we use 4 threads in our evaluations?}

We use an off-the-shelf solver
(SeaHorn~\cite{seahorn}) to check the verification conditions required
to prove that the array indices remain in bound ($\Gamma\vDash e < n$ in {\sc T-Read}, Figure~\ref{fig:compile}). The solver takes less
than a minute on our largest benchmark.
The type label is assigned conservatively in  {\sc T-Decl}.
Only the variables that govern the control flow, i.e., variables
in if-conditions and for-loops are assigned public labels.
All other variables are assigned arithmetic labels.
In the future, we would like to explore more intelligent strategies for label assignment.

Some of our benchamrks require accessing arrays at secret location.
For example, consider the expression $A[x]$ where $A$ is an array of size 2 and $x$ is shared.
\tool enforces the array indices to be public. The developer expresses this functionality in \tool
as $x > 0 ? A[1] : A[0]$. In general, for an array of size $2^n$, we need to write $2^{n-1}$ multiplexers
in \tool. This design choice of making secret indexing inconvenient to implement was deliberate.
Accessing arrays at secret locations is a powerful but expensive primitive
and we want the developers to perform this operation sparingly. \nc{Should we say here that if we did not do it this way, then we would either be insecure or would have to use something like ObliVM that will hide locations accessed?}

The secure code partitioning is not fully automatic.
in particular, the developer needs to decompose a program $P$ into $P_1||\ldots||P_k$ manually (Section~\ref{sec:pipe}). Then \tool generates $Q_1||\ldots||Q_k$ automatically.
Automating the decomposition step requires an analysis that can 
statically estimate the resource usage of a \tool program and we leave the construction of such
an analysis as future work.

The compilation rules of Figure~\ref{fig:compile} can introduce redundant coercions from arithmetic to
bool and vice versa.
The implementation of \tool performs several optimizations to reduce these.
For example, on each coercion, \tool memorizes the pair of arithmetic share and boolean share involved in the coercion.
\tool invalidates such pairs when the variables corresponding to the shares are overwritten by assignments.
In subsequent coercions, \tool can reuse valid pairs (if available) instead of recomputing them afresh. 

\divya{
\begin{enumerate}
\item add all the expressions that our language supports such as mult, bit-wise and and anything else.
\item Say that we compile to source to intermediate and use inter to circuit of ABY.. We can decide if we want to say this.
\end{enumerate}
}
 