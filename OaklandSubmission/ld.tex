\newcommand{\kw}[1]{{\lstinline[basicstyle=\small\color{blue}]{#1}}}
\newcommand{\ftext}[1]{\text{\small{#1}}}
\newcommand{\cond}[3]{\ensuremath{{{#1}\:?\:{#2}\::{#3}}}}
\newcommand{\for}[4]{\ensuremath{\kw{for}\:{#1}\:\kw{in}\:[{#2}, {#3}]\:\kw{do}\:{#4}}}
\newcommand{\ite}[3]{\ensuremath{\kw{if}({#1}, {#2}, {#3})}}
\newcommand{\loops}[3]{\ensuremath{\kw{while}\:{#1} \leq {#2}\:\kw{do}\:{#3}}}

\section{Formal development}
\label{sec:ld}

In this section we prove the correctness and security of our compiler.
%
We first formalize the source and target languages. Our source runtime
semantics is a model of the ideal, trusted third-party semantics, and
generates observations corresponding to the values revealed to the
parties.
%
The target language semantics (a model of the C++ code generated by
our compiler implementation) ``computes away'' the public parts of the
compiled program, generating a secure computation circuit.
%
Finally, we formalize the circuit semantics that computes the
generated circuit, and like the source semantics, emits observations.

We then present the compilation judgments. To prove the correctness
of our compiler, we prove that it preserves the observations. For
security of our compiler, we reduce the security argument to the
security of the cryptographic protocol used to compute the secure
computation circuit.

We present only selected parts of our formalization for space
reasons. Full definitions and proofs can be found in the supplementary
material submitted along with the paper.


\begin{figure}
  \small
  \[
  \begin{array}{rrcl}
    \ftext{Base type} & \sigma &::=& \kw{uint} \mid \kw{bool}\\
    \ftext{Type} & \psi &::=& \sigma \mid \sigma[n]\\
    \ftext{Constant} & c &::=& n \mid \top \mid \bot\\
    \ftext{Expression} & e &::=& c \mid x \mid e_{1} + e_{2} \mid e_{1} > e_{2} \mid \cond{e_{1}}{e_{2}}{e_{3}}\\
    & &\mid& [\overline{e_{i}}]_{n} \mid x[e] \mid \kw{in}_{j}\\
    \ftext{Statement} & s &::=& \psi\:x = e \mid x := e \mid \for{x}{n_{1}}{n_{2}}{s}\\
    & & \mid& x[e_{1}] := e_{2} \mid \ite{e}{s_{1}}{s_{2}} \mid \kw{out}\:e \mid s_{1}; s_{2}\\
    & & \mid& \loops{x}{n}{s}
  \end{array}
  \]
\caption{Source language}
\label{fig:srclang}
\end{figure}

\begin{figure}
  \small
  \fbox{$\rho \vdash e \Downarrow v$}
  \[
  \\
  \begin{array}{c}
    \inferrule*[lab={\footnotesize{E-Var}}]
               {
               }
               {
                 \rho \vdash x \Downarrow \rho(x)
               }
               
               \hspace{0.1cm}
               
    \inferrule*[lab={\footnotesize{E-Add}}]
               {
                 \forall i \in \{1, 2\}.\:\rho \vdash e_{i} \Downarrow n_{i}
               }
               {
                 \rho \vdash e_{1} + e_{2} \Downarrow n_{1} + n_{2}
               }

               \hspace{0.1cm}
               
    \inferrule*[lab={\footnotesize{E-Read}}]
               {
                 \rho \vdash x \Downarrow [\overline{c_{i}}]_{n_{1}} \\\\
                 \rho \vdash e \Downarrow n \quad n < n_{1}
               }
               {
                 \rho \vdash x[e] \Downarrow c_{n}
               }
\\\\
    \inferrule*[lab={\footnotesize{E-Arr}}]
               {
                 \forall i \in \{0 \dots n - 1\}.\:\rho \vdash e_{i} \Downarrow c_{i}
               }
               {
                 \rho \vdash [\overline{e_{i}}]_{n} \Downarrow [\overline{c_{i}}]_{n}
               }
               \quad
    \inferrule*[lab={\footnotesize{E-Inp}}]
               {
               }
               {
                 \rho \vdash \kw{in}_{j} \Downarrow c
               }
  \end{array}
  \]
  \\\\
    \fbox{$\rho \vdash c \Downarrow \rho'; O$}
  \[
  \\
  \begin{array}{c}
    \inferrule*[lab={\footnotesize{E-Decl}}]
               {
                 \rho \vdash e \Downarrow v
               }
               {
                 \rho \vdash \psi\:x = e \Downarrow \rho, x \mapsto v; \cdot
               }
               
               \hspace{0.1cm}

    \inferrule*[lab={\footnotesize{E-LoopT}}]
               {
                 \rho(x) > n
               }
               {
                 \rho \vdash \loops{x}{n}{s} \Downarrow \rho; \cdot
               }

               \\\\
               
    \inferrule*[lab={\footnotesize{E-LoopI}}]
               {
                 \rho(x) \leq n\\\\
                 \rho \vdash s \Downarrow \rho_{1}; O_{1}\\\\
                 \rho_{2} = [\rho_{1}]_{\mathsf{dom}(\rho)}[x \mapsto \rho_{1}(x) + 1]\\\\
                 \rho_{2} \vdash \loops{x}{n}{s} \Downarrow \rho'; O_{2}
               }
               {
                 \rho \vdash \loops{x}{n}{s} \Downarrow \rho'; O_{1}, O_{2}
               }

               \hspace{0.2cm}

    \inferrule*[lab={\footnotesize{E-If}}]
               {
                 \rho \vdash e \Downarrow c\\\\
                 c = \top \Rightarrow s = s_{1}\\\\
                 c = \bot \Rightarrow s = s_{2}\\\\
                 \rho \vdash s \Downarrow \rho'; O
               }
               {
                 \rho \vdash \ite{e}{s_{1}}{s_{2}} \Downarrow \rho'; O
               }

               \\\\
               
    \inferrule*[lab={\footnotesize{E-For}}]
               {
                 \rho, x \mapsto n_{1} \vdash \loops{x}{n_{2}}{s} \Downarrow \rho_{1}; O
               }
               {
                 \rho \vdash \for{x}{n_{1}}{n_{2}}{s} \Downarrow \rho_{1} - \{x\}; O
               }


               \hspace{0.2cm}

    \inferrule*[lab={\footnotesize{E-Out}}]
               {
                 \rho \vdash e \Downarrow c
               }
               {
                 \rho \vdash \kw{out}\:e \Downarrow \rho; c
               }

\end{array}
  \]
\caption{Source semantics (selected rules)}
\label{fig:srcsem}
\end{figure}

\subsubsection*{Source language}Our source language
(Figure~\ref{fig:srclang}) is a simple imperative language. Types
$\psi$ in the language consist of the base types $\sigma$, and arrays
of base types $\sigma[n]$, where $n$ is the array length. Though we
model only one dimensional arrays, our implementation supports higher
dimensional arrays as well. Expressions in the language include the
integer constants $n$, \kw{bool} constants $\top$ and $\bot$,
variables $x$, binary operations $e_{1} + e_{2}$ and $e_{1} > e_{2}$,
conditionals $\cond{e}{e_{1}}{e_{2}}$, array literals 
$[\overline{e_{i}}]_{n}$\footnote{We write $\overline{e}$ (and
  similarly for other symbols) to denote a sequence of expressions.
The length of the sequence is usually clear from the context.}, and
array reads $x[e]$. The expression $\kw{in}_{j}$ denotes input from
party $j$. The statements $s$ in the language comprise of variable
declarations and assignments ($\psi\:x = e$ and $x := e$ resp.),
\kw{for} loops, array writes ($x[e_{1}] := e_{2}$), \kw{if}
statements, and sequence of statements ($s_{1}; s_{2}$). The statement
$\kw{out}\:e$ denotes revealing the value of $e$ to the
parties. The \kw{while} statement is an internal syntax that is not
exposed to the programmer.

The runtime semantics for the source language is shown in
Figure~\ref{fig:srcsem}. Values $v$, runtime environments $\rho$, and
observations $O$ are defined as follows:

\vspace{0.2cm}
$
\small
\begin{array}{rrcl}
    \ftext{Value} & v &::=& c \mid [\overline{c_{i}}]_{n}\\
    \ftext{Runtime environment} & \rho &::=& \cdot \mid \rho[x \mapsto v]\\
    \ftext{Observation} & O & ::= & \cdot \mid c, O \\
\end{array}
$

\vspace{0.2cm}
Values consist of constants and array values. Runtime environment
$\rho$ maps variables to values. Observations are sequences of
constants.

The judgment $\rho \vdash e \Downarrow v$ denotes the big-step
evaluation of an expression~$e$ to a value~$v$ under the runtime
environment~$\rho$. Rule ({\sc{E-Var}}) looks up the value of $x$ in
the environment. Rule ({\sc{E-Add}}) inductively evaluates $e_{1}$ and
$e_{2}$ and evaluates to their addition. Rule ({\sc{E-Read}})
evaluates an array read operation. It first evaluates $x$ to an array
value $[\overline{c_{i}}]_{n_{1}}$, and $e$ to an \kw{uint} value
$n$. It then returns $c_{n}$, the $n$-th index value in the array,
provided $n < n_{1}$, the length of the array. Rule ({\sc{E-Inp}})
evaluates to some constant $c$ denoting party $j$'s input. We model
the inputs to be base constants, an array input can be written in the
language as $[\kw{in}_{j}]_{n}$, which can then evaluate using the
rule ({\sc{E-Arr}}). The remaining rules are straightforward, and are
elided for space reasons.

The judgment $\rho \vdash s \Downarrow \rho'; O$ represents the
big-step evaluation of an statement $s$ under environment $\rho$
producing a new environment $\rho'$ and observations $O$. Rule
({\sc{E-Decl}}) evaluates the expression $e$ to $v$, and returns the
updated environment $\rho[x \mapsto v]$, with empty observations. Rule
({\sc{E-If}}) evaluates the guard expression, and then evaluates
either $s_{1}$ or $s_{2}$ accordingly. $\kw{for}$ statements evaluate
through the internal $\kw{while}$ syntax. Specifically, rule
({\sc{E-For}}) updates $\rho$ with the initial counter value $n_{1}$,
evaluates $\loops{x}{n_{2}}{s}$ to $\rho_{1}; O$, and returns
$\rho_{1} - \{x\}$ (removing $x$ from the environment) and $O$. Rule
({\sc{E-LoopI}}) shows the inductive case for \kw{while}
statements, when $\rho(x) \leq n$. The rule evaluates $s$, producing
$\rho_{1}; O_{1}$. It then restricts $\rho_{1}$ to the domain of
$\rho$ ($[\rho_{1}]_{\mathsf{dom}(\rho)}$) to remove the variables
added by $s$, increments the value if $x$, and evaluates the
\kw{while} statement under this updated environment. Rule
({\sc{E-LoopT}}) is the termination case for \kw{while} statements,
when $\rho(x) > n$. Finally, the rule ({\sc{E-Out}}) evaluates the
expression, and adds it value to the observations.

\subsubsection{Target language}

\begin{theorem}[Correctness of the compiler]
  
\end{theorem}


\newcommand{\lcond}[4]{\ensuremath{{{#2}\:?_{{#1}}\:{#3}\::{#4}}}}
%\newcommand{\for}[4]{\ensuremath{\kw{for}\:{#1}\:\kw{in}\:[{#2}, {#3}]\:\kw{do}\:{#4}}}
%\newcommand{\ite}[3]{\ensuremath{\kw{if}({#1}, {#2}, {#3})}}
%\newcommand{\loops}[3]{\ensuremath{\kw{while}\:{#1} \leq {#2}\:\kw{do}\:{#3}}}

\begin{figure}
  \small
  \[
  \begin{array}{rrcl}
    \ftext{Secret label} & m &::=& \mathcal{A} \mid \mathcal{B}\\
    \ftext{Label} & \ell &::=& \mathcal{P} \mid m\\
    \ftext{Type} & \tau &::=& \sigma^{\ell} \mid \sigma^{\ell}[n]\\
    \ftext{Expression} & \widetilde{e} &::=& c \mid x \mid \widetilde{e_{1}} +_{\ell} \widetilde{e_{2}} \mid \widetilde{e_{1}} >_{\ell} \widetilde{e_{2}} \\
    & & \mid & \lcond{\ell}{{\widetilde{e}}}{{\widetilde{e_{1}}}}{{\widetilde{e_{2}}}} \mid x[\widetilde{e}] \mid [\overline{\widetilde{e_{i}}}]_{n} \mid \kw{in}^{m}_{j} \mid \widetilde{e} \rhd m\\
    \ftext{Statement} & \widetilde{s} &::=& \tau\:x = \widetilde{e} \mid x := \widetilde{e} \mid \dots \mid \widetilde{s_{1}}; \widetilde{s_{2}} \mid \dots\\
  \end{array}
  \]
\label{fig:tgtlang}
\caption{Target language}
\end{figure}

\begin{figure}
  \small
  \[
  \begin{array}{rrcl}
    \ftext{Wire id} & r &&\\
    \ftext{Circuit gate} & \kappa & ::= & r \mid \kw{in}^{m}_{j} \mid \kw{add}\:\kappa_{1}\:\kappa_{2} \mid \kw{gt}\:\kappa_{1}\:\kappa_{2}\\
    & & \mid & \kw{mux}\:\kappa\:\kappa_{1}\:\kappa_{2} \mid \widetilde{w} \rhd m\\
    \ftext{Base value} & \widetilde{w} & ::= & c \mid \kappa\\
    \ftext{Value} & \widetilde{v} & ::= & \widetilde{w} \mid [\overline{\widetilde{w}_{i}}]_{n}\\
    \ftext{Circuit} & \chi & ::= & \cdot \mid \kw{bind}\:\kappa\:r \mid \kw{out}\:\kappa \mid \kappa_{1}; \kappa_{2}
  \end{array}
  \]
\label{fig:tgtruntime}
\caption{Target runtime}
\end{figure}


\begin{figure}
  \small
  \fbox{$\widetilde{\rho} \vdash \widetilde{e} \Downarrow \widetilde{v}$}
  \[
  \\
  \begin{array}{c}
    \inferrule*[lab={\footnotesize{S-Var}}]
               {
               }
               {
                 \widetilde{\rho} \vdash x \Downarrow \widetilde{\rho}(x)
               }
               
    \inferrule*[lab={\footnotesize{S-PAdd}}]
               {
                 \forall i \in \{1, 2\}.\:\widetilde{\rho} \vdash \widetilde{e_{i}} \Downarrow n_{i}
               }
               {
                 \widetilde{\rho} \vdash \widetilde{e_{1}} +_{\mathcal{P}} \widetilde{e_{2}} \Downarrow n_{1} + n_{2}
               }
               
    \inferrule*[lab={\footnotesize{S-Read}}]
               {
                 \widetilde{\rho} \vdash x \Downarrow [\overline{\widetilde{w_{i}}}]_{n_{1}} \\\\
                 \widetilde{\rho} \vdash \widetilde{e} \Downarrow n \quad n < n_{1}
               }
               {
                 \widetilde{\rho} \vdash x[\widetilde{e}] \Downarrow \widetilde{w_{n}}
               }\\\\
    \inferrule*[lab={\footnotesize{S-SAdd}}]
               {
                 \forall i \in \{1, 2\}.\:\widetilde{\rho} \vdash \widetilde{e_{i}} \Downarrow \kappa_{i}
               }
               {
                 \widetilde{\rho} \vdash \widetilde{e_{1}} +_{\mathcal{A}} \widetilde{e_{2}} \Downarrow \kw{add}\:\kappa_{1}\:\kappa_{2}
               }

               \hspace{0.3cm}

    \inferrule*[lab={\footnotesize{S-SGt}}]
               {
                 \forall i \in \{1, 2\}.\:\widetilde{\rho} \vdash \widetilde{e_{i}} \Downarrow \kappa_{i}
               }
               {
                 \widetilde{\rho} \vdash \widetilde{e_{1}} >_{\mathcal{B}} \widetilde{e_{2}} \Downarrow \kw{gt}\:\kappa_{1}\:\kappa_{2}
               }\\\\
               \inferrule*[lab={\footnotesize{S-SCond}}]
               {
                 \forall i \in \{1, 2, 3\}.\:\widetilde{\rho} \vdash \widetilde{e_{i}} \Downarrow \kappa_{i}
               }
               {
                 \widetilde{\rho} \vdash \lcond{\mathcal{B}}{\widetilde{e_{1}}}{\widetilde{e_{2}}}{\widetilde{e_{3}}} \Downarrow \kw{mux}\:\kappa_{1}\:\kappa_{2}\:\kappa_{3}
               }
               \hspace{0.2cm}
    \inferrule*[lab={\footnotesize{S-Coerce}}]
               {
                 \widetilde{\rho} \vdash \widetilde{e} \Downarrow \widetilde{w}
               }
               {
                 \widetilde{\rho} \vdash \widetilde{e} \rhd m \Downarrow \widetilde{w} \rhd m
               }
               \\\\
               %% \inferrule*[lab={\footnotesize{S-Arr}}]
               %% {
               %%   \forall i \in \{0 \dots n - 1\}.\:\widetilde{\rho} \vdash \widetilde{e_{i}} \Downarrow \widetilde{w_{i}}
               %% }
               %% {
               %%   \widetilde{\rho} \vdash [\overline{\widetilde{e_{i}}}]_{n} \Downarrow [\overline{\widetilde{w_{i}}}]_{n}
               %% }

               \inferrule*[lab={\footnotesize{S-PCond}}]
               {
                 \widetilde{\rho} \vdash \widetilde{e} \Downarrow c\\\\
                 c = \top \Rightarrow \widetilde{e'} = \widetilde{e_{1}}\\
                 c = \bot \Rightarrow \widetilde{e'} = \widetilde{e_{2}}\\\\
                 \widetilde{\rho} \vdash \widetilde{e'} \Downarrow \widetilde{v}
               }
               {
                 \widetilde{\rho} \vdash \lcond{\mathcal{P}}{\widetilde{e}}{\widetilde{e_{1}}}{\widetilde{e_{2}}} \Downarrow \widetilde{v}
               }
               %\hspace{0.5cm}
               
    \inferrule*[lab={\footnotesize{S-Inp}}]
               {
               }
               {
                 \widetilde{\rho} \vdash \kw{in}^{m}_{j} \Downarrow \kw{in}^{m}_{j}
               }
  \end{array}
  \]
  \\\\
    \fbox{$\widetilde{\rho} \vdash \widetilde{c} \Downarrow \widetilde{\rho'}; \chi$}
  \[
  \\
  \begin{array}{c}
    \inferrule*[lab={\footnotesize{S-DeclC}}]
               {
                 \widetilde{\rho} \vdash \widetilde{e} \Downarrow \widetilde{v}\\\\
                 \widetilde{v} = c \vee \widetilde{v} = [\overline{c_{i}}]_{n}\\\\
                 \widetilde{\rho'} = \widetilde{\rho}, x \mapsto \widetilde{v}
               }
               {
                 \widetilde{\rho} \vdash \tau\:x = \widetilde{e} \Downarrow \widetilde{\rho'}; \cdot
               }
               
               \hspace{0.5cm}

    \inferrule*[lab={\footnotesize{S-DeclCkt}}]
               {
                 \widetilde{\rho} \vdash \widetilde{e} \Downarrow \kappa\quad
                 \mathsf{fresh}\:r\\\\
                 \widetilde{\rho'} = \widetilde{\rho}, x \mapsto r\quad
                 \chi = \kw{bind}\:\kappa\:r
               }
               {
                 \widetilde{\rho} \vdash \tau\:x = \widetilde{e} \Downarrow \widetilde{\rho'}; \chi
               }

\\\\
    \inferrule*[lab={\footnotesize{S-DeclCktA}}]
               {
                 \widetilde{\rho} \vdash \widetilde{e} \Downarrow [\overline{\kappa_{i}}]_{n}\\\\
                 \forall i \in \{0 \dots n - 1\}.\:\mathsf{fresh}\:r_{i}\\\\
                 \widetilde{\rho'} = \widetilde{\rho}, x \mapsto [r_{i}]_{n}\quad
                 \chi = \overline{\kw{bind}\:\kappa_{i}\:r_{i}}
               }
               {
                 \widetilde{\rho} \vdash \tau\:x = \widetilde{e} \Downarrow \widetilde{\rho'}; \chi
               }

               \hspace{0.2cm}
               
    \inferrule*[lab={\footnotesize{S-Out}}]
               {
                 \widetilde{\rho} \vdash \widetilde{e} \Downarrow \kappa
               }
               {
                 \widetilde{\rho} \vdash \kw{out}\:\widetilde{e} \Downarrow \widetilde{\rho}; \kw{out}\:\kappa
               }

               \\\\
    \inferrule*[lab={\footnotesize{S-If}}]
               {
                 \widetilde{\rho} \vdash \widetilde{e} \Downarrow c\\\\
                 c = \top \Rightarrow \widetilde{s} = \widetilde{s_{1}}\\\\
                 c = \bot \Rightarrow \widetilde{s} = \widetilde{s_{2}}\\\\
                 \widetilde{\rho} \vdash \widetilde{s} \Downarrow \widetilde{\rho'}; \chi
               }
               {
                 \widetilde{\rho} \vdash \ite{\widetilde{e}}{\widetilde{s_{1}}}{\widetilde{s_{2}}} \Downarrow \widetilde{\rho'}; \chi
               }

               \hspace{0.5cm}
               
    \inferrule*[lab={\footnotesize{S-WriteCkt}}]
               {
                 \widetilde{\rho} \vdash x \Downarrow [\overline{r_{i}}]_{n}\quad
                 \widetilde{\rho} \vdash \widetilde{e_{1}} \Downarrow n_{1}\\\\
                 n_{1} < n\quad
                 \mathsf{fresh}\:r\quad
                 \widetilde{\rho} \vdash \widetilde{e_{2}} \Downarrow \kappa\\\\
                 \widetilde{\rho'} = \widetilde{\rho}[x \mapsto [\overline{r_{i}}]_{n}[n_{1} \mapsto r]]
               }
               {
                 \widetilde{\rho} \vdash x[\widetilde{e_{1}}] := \widetilde{e_{2}} \Downarrow \widetilde{\rho'}; \kw{bind}\:\kappa\:r
               }

\end{array}
  \]
\label{fig:tgtsem}
\caption{Target semantics (selected rules)}
\end{figure}

\begin{figure}
  \small
  \fbox{$\widehat{\rho_{1}}, \widehat{\rho_{2}} \vdash \kappa \Downarrow b_{1}, b_{2}$}
  \[
  \\
  \begin{array}{c}
    %% \inferrule*[lab={\footnotesize{C-Wire}}]
    %%            {
    %%              b_{1}, b_{2} = \widehat{\rho_{1}}(r), \widehat{\rho_{2}}(r)
    %%            }
    %%            {
    %%              \widehat{\rho_{1}}, \widehat{\rho_{2}} \vdash r \Downarrow b_{1}, b_{2}
    %%            }               
    \inferrule*[lab={\footnotesize{C-In}}]
               {
                 b_{1}, b_{2} = \mathcal{E}_{m}(c)
               }
               {
                 \widehat{\rho_{1}}, \widehat{\rho_{2}} \vdash \kw{in}^{m}_{j} \Downarrow b_{1}, b_{2}
               }

               \hspace{0.3cm}
               
    \inferrule*[lab={\footnotesize{C-Coerce}}]
               {
                 \widehat{\rho_{1}}, \widehat{\rho_{2}} \vdash \kappa \Downarrow b_{1}, b_{2}\\\\
                 c = \mathcal{D}_{m_{1}}(b_{1}, b_{2})\\\\
                 b'_{1}, b'_{2} = \mathcal{E}_{m}(c)
               }
               {
                 \widehat{\rho_{1}}, \widehat{\rho_{2}} \vdash \kappa \rhd m \Downarrow b'_{1}, b'_{2}
               }
\\\\

    \inferrule*[lab={\footnotesize{C-Add}}]
               {
                 \forall i \in \{1, 2\}.\:\widehat{\rho_{1}}, \widehat{\rho_{2}} \vdash \kappa_{i} \Downarrow b_{1i}, b_{2i}\quad
                 n_{i} = \mathcal{D}_{\mathcal{A}}(b_{1i}, b_{2i})\\\\
                 b_{1}, b_{2} = \mathcal{E}_{\mathcal{A}}(n_{1} + n_{2})
               }
               {
                 \widehat{\rho_{1}}, \widehat{\rho_{2}} \vdash \kw{add}\:\kappa_{1}\:\kappa_{2} \Downarrow b_{1}, b_{2}
               }

\\\\

    \inferrule*[lab={\footnotesize{C-Gt}}]
               {
                 \forall i \in \{1, 2\}.\:\widehat{\rho_{1}}, \widehat{\rho_{2}} \vdash \kappa_{i} \Downarrow b_{1i}, b_{2i}\quad
                 n_{i} = \mathcal{D}_{\mathcal{B}}(b_{1i}, b_{2i})\\\\
                 b_{1}, b_{2} = \mathcal{E}_{\mathcal{B}}(n_{1} > n_{2})
               }
               {
                 \widehat{\rho_{1}}, \widehat{\rho_{2}} \vdash \kw{gt}\:\kappa_{1}\:\kappa_{2} \Downarrow b_{1}, b_{2}
               }

\\\\

    \inferrule*[lab={\footnotesize{C-Mux}}]
               {
                 \forall i \in \{1, 2, 3\}.\:\widehat{\rho_{1}}, \widehat{\rho_{2}} \vdash \kappa_{i} \Downarrow b_{1i}, b_{2i}\quad
                 c_{i} = \mathcal{D}_{\mathcal{B}}(b_{1i}, b_{2i})\\\\
                 c_{1} = \top \Rightarrow b_{1}, b_{2} = \mathcal{E}_{\mathcal{B}}(c_{2})\quad
                 c_{1} = \bot \Rightarrow b_{1}, b_{2} = \mathcal{E}_{\mathcal{B}}(c_{3})
               }
               {
                 \widehat{\rho_{1}}, \widehat{\rho_{2}} \vdash \kw{mux}\:\kappa_{1}\:\kappa_{2}\:\kappa_{3} \Downarrow b_{1}, b_{2}
               }

  \end{array}
  \]
  \\\\
    \fbox{$\widehat{\rho_{1}}, \widehat{\rho_{2}} \vdash \chi \Downarrow \widehat{\rho'_{1}}, \widehat{\rho'_{2}}; O$}
  \[
  \\
  \begin{array}{c}
    \inferrule*[lab={\footnotesize{C-Bind}}]
               {
                 \widehat{\rho_{1}}, \widehat{\rho_{2}} \vdash \kappa \Downarrow b_{1}, b_{2}\\\\
                 \widehat{\rho'_{1}} = \widehat{\rho_{1}}[r \mapsto b_{1}] \quad
                 \widehat{\rho'_{2}} = \widehat{\rho_{2}}[r \mapsto b_{2}]
               }
               {
                 \widehat{\rho_{1}}, \widehat{\rho_{2}} \vdash \kw{bind}\:\kappa\:r \Downarrow \widehat{\rho'_{1}}, \widehat{\rho'_{2}}; \cdot
               }
               
               \hspace{0.1cm}

    \inferrule*[lab={\footnotesize{C-Out}}]
               {
                 \widehat{\rho_{1}}, \widehat{\rho_{2}} \vdash \kappa \Downarrow b_{1}, b_{2}\\\\
                 c = \mathcal{D}_{m}(b_{1}, b_{2})
               }
               {
                 \widehat{\rho_{1}}, \widehat{\rho_{2}} \vdash \kw{out}\:\kappa \Downarrow \widehat{\rho_{1}}, \widehat{\rho_{2}}; c
               }
\end{array}
  \]
\label{fig:cktsem}
\caption{Circuit semantics (selected rules)}
\end{figure}

\begin{figure}
  \small
  \fbox{$\Gamma \vdash e : \tau \leadsto \widetilde{e}$}
  \[
  \begin{array}{c}
     \inferrule*[lab={\footnotesize{T-Cons}}]
               {
                 \tau = \mathsf{typeof}(c)^{\mathcal{P}}
               }
               {
                 \Gamma \vdash c : \tau \leadsto c 
               }

     \inferrule*[lab={\footnotesize{T-Add}}]
               {
                 \forall i \in \{1,2\}.\:\Gamma \vdash e_{i} : \kw{uint}^{\ell} \leadsto \widetilde{e_{i}}\\\\
                 \ell = \mathcal{P} \vee \ell = \mathcal{A}
               }
               {
                 \Gamma \vdash e_{1} + e_{2} : \kw{uint}^{\ell} \leadsto \widetilde{e_{1}} +_{\ell} \widetilde{e_{2}}
               }

    %% \inferrule*[lab={\footnotesize{T-Cons}}]
    %%            {
    %%              \tau = \mathsf{typeof}(c)^{\mathcal{P}}
    %%            }
    %%            {
    %%              \Gamma \vdash c : \tau \leadsto c
    %%            }

    %%  \inferrule*[lab={\footnotesize{T-Var}}]
    %%            {
    %%            }
    %%            {
    %%              \Gamma \vdash x : \Gamma(x) \leadsto x
    %%            }
\\\\
     \inferrule*[lab={\footnotesize{T-Gt}}]
               {
                 \forall i \in \{1,2\}.\:\Gamma \vdash e_{i} : \kw{uint}^{\ell} \leadsto \widetilde{e_{i}}\\\\
                 \ell = \mathcal{P} \vee \ell = \mathcal{B}
               }
               {
                 \Gamma \vdash e_{1} > e_{2} : \kw{bool}^{\ell} \leadsto \widetilde{e_{1}} >_{\ell} \widetilde{e_{2}}
               }

     \inferrule*[lab={\footnotesize{T-Read}}]
               {
                 \Gamma \vdash x : \sigma^{\ell}[n] \leadsto x\\\\
                 \Gamma \vdash e : \kw{uint}^{\mathcal{P}} \leadsto \widetilde{e}\\\\
                 \Gamma \models e < n
               }
               {
                 \Gamma \vdash x[e] : \sigma^{\ell} \leadsto x[\widetilde{e}]
               }

\\\\               

     \inferrule*[lab={\footnotesize{T-Cond}}]
               {
                 \Gamma \vdash e : \kw{bool}^{\ell} \leadsto \widetilde{e}\\\\
                 \forall i \in \{1,2\}.\:\Gamma \vdash e_{i} : \sigma^{\ell'} \leadsto \widetilde{e_{i}}\\\\
                 \ell = \mathcal{P} \vee (\ell = \mathcal{B} \wedge \ell' =\mathcal{B})
               }
               {
                 \Gamma \vdash \cond{e}{e_{1}}{e_{2}} : \sigma^{\ell'} \leadsto \lcond{\ell}{\widetilde{e}}{\widetilde{e_{1}}}{\widetilde{e_{2}}}
               }

     \inferrule*[lab={\footnotesize{T-Inp}}]
               {
               }
               {
                 \Gamma \vdash \kw{in}_{j} : \sigma^{m} \leadsto \kw{in}^{\sigma}_{j}
               }
               
\\\\               

     \inferrule*[lab={\footnotesize{T-Arr}}]
               {
                 \forall i \in \{0 \dots n - 1\}.\:\Gamma \vdash e_{i} : \sigma^{\ell} \leadsto \widetilde{e_{i}}
               }
               {
                 \Gamma \vdash [\overline{e_{i}}]_{n} : \sigma^{\ell}[n] \leadsto [\overline{\widetilde{e_{i}}}]_{n}
               }

     \inferrule*[lab={\footnotesize{T-Sub}}]
               {
                 \Gamma \vdash e : \sigma^{\ell} \leadsto \widetilde{e}
               }
               {
                 \Gamma \vdash e : \sigma^{m} \leadsto \widetilde{e} \rhd m
               }

  \end{array}
  \]
  \\\\
    \fbox{$\Gamma \vdash s \leadsto \widetilde{s} \mid \Gamma'$}
  \[
  \\
  \begin{array}{c}
     \inferrule*[lab={\footnotesize{T-Decl}}]
               {
                 \psi = \sigma \Rightarrow \tau = \sigma^{\ell}\\\\
                 \psi = \sigma[n] \Rightarrow \tau = \sigma^{\ell}[n]\\\\
                 \Gamma \vdash e : \tau \leadsto \widetilde{e}
               }
               {
                 \Gamma \vdash \psi\:x = e \leadsto \tau\:x = \widetilde{e} \mid \Gamma, x:\tau
               }

     \inferrule*[lab={\footnotesize{T-Assgn}}]
               {
                 \Gamma(x) = \sigma^{\ell}\\\\
                 \Gamma \vdash e : \sigma^{\ell} \leadsto \widetilde{e}
               }
               {
                 \Gamma \vdash x := e \leadsto x = \widetilde{e} \mid \Gamma
               }

\\\\

     \inferrule*[lab={\footnotesize{T-For}}]
               {
                 \Gamma' = \Gamma, x::\kw{uint}^{\mathcal{P}}\\\\
                 \Gamma' \vdash \loops{x}{n_{2}}{s} \leadsto \loops{x}{n_{2}}{\widetilde{s}} \mid \Gamma'
               }
               {
                 \Gamma \vdash \for{x}{n_{1}}{n_{2}}{s} \leadsto \for{x}{n_{1}}{n_{2}}{\widetilde{s}} \mid \Gamma
               }

               \\\\

     \inferrule*[lab={\footnotesize{T-Write}}]
               {
                 \Gamma \vdash x : \sigma^{\ell}[n] \leadsto x\\\\
                 \Gamma \vdash e_{1} : \kw{uint}^{\mathcal{P}} \leadsto \widetilde{e_{1}}\\\\
                 \Gamma \vdash e_{2} : \sigma^{\ell} \leadsto \widetilde{e_{2}}\\\\
                 \Gamma \models e_{1} < n
               }
               {
                 \Gamma \vdash x[e_{1}] := e_{2} \leadsto x[\widetilde{e_{1}}] := \widetilde{e_{2}} \mid \Gamma
               }

     \inferrule*[lab={\footnotesize{T-Out}}]
               {
                 \Gamma \vdash e : \sigma^{m} \leadsto \widetilde{e}
               }
               {
                 \Gamma \vdash \kw{out}\:e \leadsto \kw{out}\:\widetilde{e} \mid \Gamma
               }

\\\\

     \inferrule*[lab={\footnotesize{T-If}}]
               {
                 \Gamma \vdash e : \kw{bool}^{\mathcal{P}} \leadsto \widetilde{e}\\\\
                 \forall i \in \{1, 2\}.\:\Gamma \vdash s_{i} \leadsto \widetilde{s_{i}} \mid \_
               }
               {
                 \Gamma \vdash \ite{e}{s_{1}}{s_{2}} \leadsto \ite{\widetilde{e}}{\widetilde{s_{1}}}{\widetilde{s_{2}}}  \mid \Gamma
               }

     \inferrule*[lab={\footnotesize{T-Seq}}]
               {
                 \Gamma \vdash s_{1} \leadsto \widetilde{s_{1}} \mid \Gamma_{1}\\\\
                 \Gamma_{1} \vdash s_{2} \leadsto \widetilde{s_{2}} \mid \Gamma_{2}
               }
               {
                 \Gamma \vdash s_{1}; s_{2} \leadsto \widetilde{s_{1}}; \widetilde{s_{2}} \mid \Gamma_{2}
               }

\\\\

     \inferrule*[lab={\footnotesize{T-While}}]
               {                 
                 \Gamma(x) = \kw{uint}^{\mathcal{P}}\quad
                 \Gamma \vdash s \leadsto \widetilde{s} \mid \_\quad
                 x \notin \mathsf{modifies}(s)
               }
               {
                 \Gamma \vdash \loops{x}{n_{2}}{s} \leadsto \loops{x}{n_{2}}{\widetilde{s}} \mid \Gamma
               }

  \end{array}
  \]
\label{fig:compile}
\caption{Compilation judgments (selected rules)}
\end{figure}

  %% \\
  %% \[
  %% \begin{array}{rrcl}
  %%   \ftext{Value} & v &::=& c \mid [\overline{c_{i}}]_{n}\\
  %%   \ftext{Observation} & O &::=& \cdot \mid c; O\\
  %% \end{array}
  %% \]
