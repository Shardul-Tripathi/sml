\newcommand{\kw}[1]{{\lstinline[basicstyle=\small\color{blue}]{#1}}}
%\newcommand{\kw}[1]{{\ensuremath{\mathtt{#1}}}}
\newcommand{\ftext}[1]{\text{\small{#1}}}
\newcommand{\cond}[3]{\ensuremath{{{#1}\:?\:{#2}\::{#3}}}}
\newcommand{\for}[4]{\ensuremath{\kw{for}\:{#1}\:\kw{in}\:[{#2}, {#3}]\:\kw{do}\:{#4}}}
\newcommand{\ite}[3]{\ensuremath{\kw{if}({#1}, {#2}, {#3})}}
\newcommand{\loops}[3]{\ensuremath{\kw{while}\:{#1} \leq {#2}\:\kw{do}\:{#3}}}

\section{Formal development}
\label{sec:ld}



%In this section we prove the correctness and security of our compiler.
%%
%We first formalize the source and target languages. Our source runtime
%semantics is a model of the ideal, trusted third-party semantics, and
%generates observations corresponding to the values revealed to the
%parties.
%%
%The target language semantics (a model of the C++ code generated by
%our compiler implementation) ``computes away'' the public parts and
%arrays from the compiled program, generating a secure computation
%circuit. Crucially, this semantics does not have access to the secret
%inputs--those are processed by the secure computation circuit.
%%
%Finally, we formalize the circuit semantics that computes the
%generated circuit, and like the source semantics, emits observations
%corresponding to the values revealed to the parties.
%
%We then present the compilation rules. To prove the correctness
%of our compiler, we prove that it preserves the observations. For
%security of our compiler, we reduce the security argument to the
%security of the cryptographic protocol used to compute the secure
%computation circuit.
%\nc{Should we also say that security relies on correctness? (they go together)}
%We present only selected parts of our formalization for space
%reasons. Full definitions and proofs can be found in the supplementary
%material submitted along with the paper.


In this section we prove correctness and security of our compiler \tool.
We formalize our source, intermediate and circuit languages. 
An example of a program in our source language is provided in \figureref{ex-sml}.
%Our source runtime semantics is a model of the ideal, trusted third-party semantics, and
%generates observations corresponding to the values revealed to the
%parties.
Our source runtime semantics describe the standard execution semantics of the source programs and
generates observations corresponding to the values revealed to the
parties.
%
We present the compilation rules that type check a program in the source language and generates a program in the intermediate language. This intermediate language models programs such as \figureref{ex-aby} generated by our compiler implementation.
%
We evaluate the program in our intermediate language  to a circuit by ``computing away'' the public parts and the arrays. Crucially, this step does not have access to the secret inputs--those are processed by the distributed circuit semantics that model the \mpc back-end.
%
Here, the generated circuit is evaluated in the distributed setting, where the parties run an interactive protocol. This step, like  the source semantics, emits observations corresponding to the values revealed to the parties. 
%Finally, we formalize the distributed circuit semantics (of the cryptographic back-end) that computes the generated circuit in the distributed setting, and like  the source semantics, emits observationscorresponding to the values revealed to the parties.

To prove the correctness of \tool, we prove that  the observations in source semantics and distributed circuit semantics are identical (see \theoremref{correctness}). 
We combine this correctness and the security of the \mpc back-end to argue security of the implementations generated by \tool (see \theoremref{security}).
%For the security of our compiler, we rely on the correctness guarantee and  reduce the security to the security of the underlying cryptographic protocol used to compute the generated circuit (see \theoremref{security}).
We present only selected parts of our formalization for space
reasons. Full definitions and proofs can be found \cite{anonymized}.


%\TODO{Do we want to write things in logical order or order in paper?}



\begin{figure}
  \small
  \[
  \begin{array}{rrcl}
    \ftext{Base type} & \sigma &::=& \kw{uint} \mid \kw{bool}\\
    \ftext{Type} & \psi &::=& \sigma \mid \sigma[n]\\
    \ftext{Constant} & c &::=& n \mid \top \mid \bot\\
    \ftext{Expression} & e &::=& c \mid x \mid e_{1} \mulop e_{2} \mid e_{1} > e_{2} \mid \cond{e_{1}}{e_{2}}{e_{3}}\\
    & &\mid& [\overline{e_{i}}]_{n} \mid x[e] \mid \kw{in}_{j}\\
    \ftext{Statement} & s &::=& \psi\:x = e \mid x := e \mid \for{x}{n_{1}}{n_{2}}{s}\\
    & & \mid& x[e_{1}] := e_{2} \mid \ite{e}{s_{1}}{s_{2}} \mid \kw{out}\:e \mid s_{1}; s_{2}\\
    & & \mid& \loops{x}{n}{s}
  \end{array}
  \]
\caption{Source language}
\label{fig:srclang}
\end{figure}

\begin{figure}
  \small
  \fbox{$\rho \vdash e \Downarrow v$}
  \[
  \\
  \begin{array}{c}
    \inferrule*[lab={\footnotesize{E-Var}}]
               {
               }
               {
                 \rho \vdash x \Downarrow \rho(x)
               }
               
               \hspace{0.1cm}
               
    \inferrule*[lab={\footnotesize{E-Mult}}]
               {
                 \forall i \in \{1, 2\}.\:\rho \vdash e_{i} \Downarrow n_{i}
               }
               {
                 \rho \vdash e_{1} \mulop e_{2} \Downarrow n_{1} \mulop n_{2}
               }

               \hspace{0.1cm}
               \inferrule*[lab={\footnotesize{E-Cond}}]
               {
                 \rho \vdash e \Downarrow c\\\\
                 c = \top \Rightarrow e' = e_{1}\\\\
                 c = \bot \Rightarrow e' = e_{2}\\\\
                 \rho \vdash e' \Downarrow c'
               }
               {
                 \rho \vdash \cond{e}{e_{1}}{e_{2}} \Downarrow c'
               }
               
   
\\\\
	 \inferrule*[lab={\footnotesize{E-Read}}]
               {
                 \rho \vdash x \Downarrow [\overline{c_{i}}]_{n_{1}} \\\\
                 \rho \vdash e \Downarrow n \quad n < n_{1}
               }
               {
                 \rho \vdash x[e] \Downarrow c_{n}
               }
    
               \hspace{0.1cm}
    \inferrule*[lab={\footnotesize{E-Arr}}]
               {
                 \forall i \in [n].\:\rho \vdash e_{i} \Downarrow c_{i}
               }
               {
                 \rho \vdash [\overline{e_{i}}]_{n} \Downarrow [\overline{c_{i}}]_{n}
               }
               \hspace{0.1cm}
    \inferrule*[lab={\footnotesize{E-Inp}}]
               {
               }
               {
                 \rho \vdash \kw{in}_{j} \Downarrow c
               }
  \end{array}
  \]
  \\\\
    \fbox{$\rho \vdash s \Downarrow \rho'; O$}
  \[
  \\
  \begin{array}{c}
    \inferrule*[lab={\footnotesize{E-Decl}}]
               {
                 \rho \vdash e \Downarrow v
               }
               {
                 \rho \vdash \psi\:x = e \Downarrow \rho, x \mapsto v; \cdot
               }
               
               \hspace{0.1cm}

    \inferrule*[lab={\footnotesize{E-LoopT}}]
               {
                 \rho(x) > n
               }
               {
                 \rho \vdash \loops{x}{n}{s} \Downarrow \rho; \cdot
               }

               \\\\
               
    \inferrule*[lab={\footnotesize{E-LoopI}}]
               {
                 \rho(x) \leq n\\\\
                 \rho \vdash s \Downarrow \rho_{1}; O_{1}\\\\
                 \rho_{2} = [\rho_{1}]_{\mathsf{dom}(\rho)}[x \mapsto \rho_{1}(x) + 1]\\\\
                 \rho_{2} \vdash \loops{x}{n}{s} \Downarrow \rho_{3}; O_{2}
               }
               {
                 \rho \vdash \loops{x}{n}{s} \Downarrow \rho_{3}; O_{1}, O_{2}
               }

               \hspace{0.2cm}

    \inferrule*[lab={\footnotesize{E-If}}]
               {
                 \rho \vdash e \Downarrow c\\\\
                 c = \top \Rightarrow s = s_{1}\\\\
                 c = \bot \Rightarrow s = s_{2}\\\\
                 \rho \vdash s \Downarrow \rho_{1}; O
               }
               {
                 \rho \vdash \ite{e}{s_{1}}{s_{2}} \Downarrow \rho_{1}; O
               }

               \\\\
               
    \inferrule*[lab={\footnotesize{E-For}}]
               {
                 \rho, x \mapsto n_{1} \vdash \loops{x}{n_{2}}{s} \Downarrow \rho_{1}; O
               }
               {
                 \rho \vdash \for{x}{n_{1}}{n_{2}}{s} \Downarrow \rho_{1} - \{x\}; O
               }


               \hspace{0.2cm}

    \inferrule*[lab={\footnotesize{E-Out}}]
               {
                 \rho \vdash e \Downarrow c
               }
               {
                 \rho \vdash \kw{out}\:e \Downarrow \rho; c
               }

\end{array}
  \]
\caption{Source semantics (selected rules)}
\label{fig:srcsem}
\end{figure}

\subsubsection*{Source language} Our source language
 is a simple imperative language. \divya{We present the core of our language in \figureref{srclang} but our implementation is more expressive (see \sectionref{impl}).} Types
$\psi$ consist of the base types $\sigma$, and arrays
of base types $\sigma[n]$, where $n$ is the array length. Though we
model only one dimensional arrays, our implementation supports higher
dimensional arrays as well. Expressions $e$ in the language include the
integer constants $n$, \kw{bool} constants $\top$ and $\bot$,
variables $x$, binary operations $e_{1} \mulop e_{2}$ and $e_{1} > e_{2}$,
conditionals $\cond{e}{e_{1}}{e_{2}}$, array literals 
$[\overline{e_{i}}]_{n}$\footnote{We write $\overline{e}$ (and
  similarly for other symbols) to denote a sequence of expressions.
The length of the sequence is usually clear from the context.}, and
array reads $x[e]$. The expression $\kw{in}_{j}$ denotes input from
party $j$. The statements $s$ in the language comprise of variable
declarations and assignments ($\psi\:x = e$ and $x := e$ resp.),
\kw{for} loops, array writes ($x[e_{1}] := e_{2}$), \kw{if}
statements, and sequence of statements ($s_{1}; s_{2}$). The statement
$\kw{out}\:e$ denotes revealing the value of $e$ to the
parties. The \kw{while} statement is an internal syntax that is not
exposed to the programmer. \\

\noindent\textbf{Source Semantics.} The runtime semantics for the source language is shown in
\figureref{srcsem}. \TODO{Add something about claer text stand alone exec.} Values $v$, runtime environments $\rho$, and
observations $O$ are defined as follows:

\vspace{0.2cm}
$
\small
\begin{array}{rrcl}
    \ftext{Value} & v &::=& c \mid [\overline{c_{i}}]_{n}\\
    \ftext{Runtime environment} & \rho &::=& \cdot \mid \rho,x \mapsto v\\
    \ftext{Observation} & O & ::= & \cdot \mid c, O \\
\end{array}
$

\vspace{0.2cm}
Values consist of constants and array of constants, runtime environment
$\rho$ maps variables to values, and observations are sequences of
constants.

The judgment $\rho \vdash e \Downarrow v$ denotes the big-step
evaluation of an expression~$e$ to a value~$v$ under the runtime
environment~$\rho$. Rule ({\sc{E-Var}}) looks up the value of $x$ in
the environment. Rule ({\sc{E-Mult}}) inductively evaluates $e_{1}$ and
$e_{2}$, and evaluates to their product. Rule ({\sc{E-Read}})
evaluates an array read operation. It first evaluates $x$ to an array
value $[\overline{c_{i}}]_{n_{1}}$, and $e$ to a \kw{uint} value
$n$. It then returns $c_{n}$, the $n$-th index value in the array,
provided $n < n_{1}$, the length of the array. Rule ({\sc{E-Inp}})
evaluates to some constant $c$ denoting party $j$'s input. We model
the inputs to be base constants, an array input can be written in the
language as $[\kw{in}_{j}]_{n}$, which can then evaluate using the
rule ({\sc{E-Arr}}). The remaining rules are straightforward, and are
elided for space reasons.

The judgment $\rho \vdash s \Downarrow \rho_{1}; O$ represents the
big-step evaluation of a statement $s$ under environment $\rho$
producing a new environment $\rho_{1}$ and observations $O$. Rule
({\sc{E-Decl}}) evaluates the expression $e$ to $v$, and returns the
updated environment $\rho,x \mapsto v$, with empty observations. Rule
({\sc{E-If}}) evaluates the guard expression, and then evaluates
either $s_{1}$ or $s_{2}$ accordingly. The $\kw{for}$ statements evaluate
through the internal $\kw{while}$ syntax. Specifically, the rule
({\sc{E-For}}) appends $\rho$ with $x\mapsto n_{1}$,
evaluates $\loops{x}{n_{2}}{s}$ to $\rho_{1}; O$, and returns
$\rho_{1} - \{x\}$ (removing $x$ from $\rho_{1}$) and $O$. Rule
({\sc{E-LoopI}}) shows the inductive case for \kw{while}
statements, when $\rho(x) \leq n$. The rule evaluates $s$, producing
$\rho_{1}; O_{1}$. It then restricts $\rho_{1}$ to the domain of
$\rho$ ($[\rho_{1}]_{\mathsf{dom}(\rho)}$) to remove the variables
added by $s$, increments the value of $x$, and evaluates the
\kw{while} statement under this updated environment. Rule
({\sc{E-LoopT}}) is the termination case for \kw{while} statements,
when $\rho(x) > n$. Finally, the rule ({\sc{E-Out}}) evaluates the
expression, and adds its value to the observations.

\newcommand{\lcond}[4]{\ensuremath{{{#2}\:?_{{#1}}\:{#3}\::{#4}}}}
%\newcommand{\for}[4]{\ensuremath{\kw{for}\:{#1}\:\kw{in}\:[{#2}, {#3}]\:\kw{do}\:{#4}}}
%\newcommand{\ite}[3]{\ensuremath{\kw{if}({#1}, {#2}, {#3})}}
%\newcommand{\loops}[3]{\ensuremath{\kw{while}\:{#1} \leq {#2}\:\kw{do}\:{#3}}}

\begin{figure}
  \small
  \[
  \begin{array}{rrcl}
    \ftext{Secret label} & m &::=& \mathcal{A} \mid \mathcal{B}\\
    \ftext{Label} & \ell &::=& \mathcal{P} \mid m\\
    \ftext{Type} & \tau &::=& \sigma^{\ell} \mid \sigma^{\ell}[n]\\
    \ftext{Expression} & \widetilde{e} &::=& c \mid x \mid \widetilde{e_{1}} \mulop_{\ell} \widetilde{e_{2}} \mid \widetilde{e_{1}} >_{\ell} \widetilde{e_{2}} \\
    & & \mid & \lcond{\ell}{{\widetilde{e}}}{{\widetilde{e_{1}}}}{{\widetilde{e_{2}}}} \mid x[\widetilde{e}] \mid [\overline{\widetilde{e_{i}}}]_{n} \mid \kw{in}^{m}_{j} \mid \widetilde{e} \rhd m\\
    \ftext{Statement} & \widetilde{s} &::=& \tau\:x = \widetilde{e} \mid x := \widetilde{e} \mid \dots \mid \widetilde{s_{1}}; \widetilde{s_{2}} \mid \dots\\
  \end{array}
  \]
\caption{Intermediate Language}
\label{fig:interlang}
\end{figure}









\subsubsection*{Intermediate language} \figureref{interlang} shows the
intermediate language of our compiler. The syntax follows that of the source
language, except that the types and operators are \emph{labeled}. Below
we mainly focus on the bits that are different from the source
language.

Labels $\ell$ consist of secret labels $\mathcal{A}$ and
$\mathcal{B}$, denoting the arithmetic and boolean shared secrets
resp., and the public label $\mathcal{P}$. Types $\tau$ are then
labeled base types $\sigma^{\ell}$ and arrays of labeled base types
$\sigma^{\ell}[n]$.

Most of the expression forms $\widetilde{e}$ are same as $e$, except
that the binary operators, and the conditional forms
are annotated with label $\ell$, denoting how the operators should be
evaluated ($\mathcal{P}$ for in-clear, and $\mathcal{A}$ and
$\mathcal{B}$ for using arithmetic or boolean circuits resp.). The
form $\widetilde{e} \rhd m$ denotes coercing the value of $\widetilde{e}$ to be
$m$-secret shared. The statements $\widetilde{s}$ are analogous to
$s$.



\begin{figure}[t]
  \small
  \fbox{$\Gamma \vdash e : \tau \leadsto \widetilde{e}$}
  \[
  \begin{array}{c}
     \inferrule*[lab={\footnotesize{T-Cons}}]
               {
                 \tau = \mathsf{typeof}(c)^{\mathcal{P}}
               }
               {
                 \Gamma \vdash c : \tau \leadsto c 
               }
               
                \inferrule*[lab={\footnotesize{T-Inp}}]
               {
               }
               {
                 \Gamma \vdash \kw{in}_{j} : \sigma^{m} \leadsto \kw{in}^{m}_{j}
               }

   

    %% \inferrule*[lab={\footnotesize{T-Cons}}]
    %%            {
    %%              \tau = \mathsf{typeof}(c)^{\mathcal{P}}
    %%            }
    %%            {
    %%              \Gamma \vdash c : \tau \leadsto c
    %%            }

    %%  \inferrule*[lab={\footnotesize{T-Var}}]
    %%            {
    %%            }
    %%            {
    %%              \Gamma \vdash x : \Gamma(x) \leadsto x
    %%            }
\\\\

	  \inferrule*[lab={\footnotesize{T-Mult}}]
               {
                 \forall i \in \{1,2\}.\:\Gamma \vdash e_{i} : \kw{uint}^{\ell} \leadsto \widetilde{e_{i}}\\\\
                 \left(\ell = \mathcal{P}\right) \vee \left(\ell = \mathcal{A}\right)
               }
               {
                 \Gamma \vdash e_{1} \mulop e_{2} : \kw{uint}^{\ell} \leadsto \widetilde{e_{1}} \mulop_{\ell} \widetilde{e_{2}}
               }
               
     \inferrule*[lab={\footnotesize{T-Gt}}]
               {
                 \forall i \in \{1,2\}.\:\Gamma \vdash e_{i} : \kw{uint}^{\ell} \leadsto \widetilde{e_{i}}\\\\
                 \left(\ell = \mathcal{P}\right) \vee \left(\ell = \mathcal{B}\right)
               }
               {
                 \Gamma \vdash e_{1} > e_{2} : \kw{bool}^{\ell} \leadsto \widetilde{e_{1}} >_{\ell} \widetilde{e_{2}}
               }

     
\\\\               

	\inferrule*[lab={\footnotesize{T-Read}}]
               {
                 \Gamma \vdash x : \sigma^{\ell}[n] \leadsto x\\\\
                 \Gamma \vdash e : \kw{uint}^{\mathcal{P}} \leadsto \widetilde{e}\\\\
                 \Gamma \models e < n
               }
               {
                 \Gamma \vdash x[e] : \sigma^{\ell} \leadsto x[\widetilde{e}]
               }


     \inferrule*[lab={\footnotesize{T-Cond}}]
               {
                 \Gamma \vdash e : \kw{bool}^{\ell} \leadsto \widetilde{e}\\\\
                 \forall i \in \{1,2\}.\:\Gamma \vdash e_{i} : \sigma^{\ell'} \leadsto \widetilde{e_{i}}\\\\
                 \ell = \mathcal{P} \vee (\ell = \mathcal{B} \wedge \ell' =\mathcal{B})
               }
               {
                 \Gamma \vdash \cond{e}{e_{1}}{e_{2}} : \sigma^{\ell'} \leadsto \lcond{\ell}{\widetilde{e}}{\widetilde{e_{1}}}{\widetilde{e_{2}}}
               }
               
\\\\               

     \inferrule*[lab={\footnotesize{T-Arr}}]
               {
                 \forall i \in [n].\:\Gamma \vdash e_{i} : \sigma^{\ell} \leadsto \widetilde{e_{i}}
               }
               {
                 \Gamma \vdash [\overline{e_{i}}]_{n} : \sigma^{\ell}[n] \leadsto [\overline{\widetilde{e_{i}}}]_{n}
               }

     \inferrule*[lab={\footnotesize{T-Sub}}]
               {
                 \Gamma \vdash e : \sigma^{\ell} \leadsto \widetilde{e}
               }
               {
                 \Gamma \vdash e : \sigma^{m} \leadsto \widetilde{e} \rhd m
               }

  \end{array}
  \]
  \\\\
    \fbox{$\Gamma \vdash s \leadsto \widetilde{s} \mid \Gamma_{1}$}
  \[
  \\
  \begin{array}{c}
     \inferrule*[lab={\footnotesize{T-Decl}}]
               {
                 \tau = \psi^\ell \\\\
                 \Gamma \vdash e : \tau \leadsto \widetilde{e}
               }
               {
                 \Gamma \vdash \psi\:x = e \leadsto \tau\:x = \widetilde{e} \mid \Gamma, x:\tau
               }

     \inferrule*[lab={\footnotesize{T-Assgn}}]
               {
                 \Gamma(x) = \sigma^{\ell}\\\\
                 \Gamma \vdash e : \sigma^{\ell} \leadsto \widetilde{e}
               }
               {
                 \Gamma \vdash x := e \leadsto x = \widetilde{e} \mid \Gamma
               }

\\\\

     \inferrule*[lab={\footnotesize{T-For}}]
               {
                 \Gamma, x:\kw{uint}^{\mathcal{P}} \vdash \loops{x}{n_{2}}{s} \leadsto \loops{x}{n_{2}}{\widetilde{s}} \mid \_
               }
               {
                 \Gamma \vdash \for{x}{n_{1}}{n_{2}}{s} \leadsto \for{x}{n_{1}}{n_{2}}{\widetilde{s}} \mid \Gamma
               }

               \\\\

     \inferrule*[lab={\footnotesize{T-Write}}]
               {
                 \Gamma \vdash x : \sigma^{\ell}[n] \leadsto x\\\\
                 \Gamma \vdash e_{1} : \kw{uint}^{\mathcal{P}} \leadsto \widetilde{e_{1}}\\\\
                 \Gamma \vdash e_{2} : \sigma^{\ell} \leadsto \widetilde{e_{2}}\\\\
                 \Gamma \models e_{1} < n
               }
               {
                 \Gamma \vdash x[e_{1}] := e_{2} \leadsto x[\widetilde{e_{1}}] := \widetilde{e_{2}} \mid \Gamma
               }

     \inferrule*[lab={\footnotesize{T-Out}}]
               {
                 \Gamma \vdash e : \sigma^{m} \leadsto \widetilde{e}
               }
               {
                 \Gamma \vdash \kw{out}\:e \leadsto \kw{out}\:\widetilde{e} \mid \Gamma
               }

\\\\

     \inferrule*[lab={\footnotesize{T-If}}]
               {
                 \Gamma \vdash e : \kw{bool}^{\mathcal{P}} \leadsto \widetilde{e}\\\\
                 \forall i \in \{1, 2\}.\:\Gamma \vdash s_{i} \leadsto \widetilde{s_{i}} \mid \_
               }
               {
                 \Gamma \vdash \ite{e}{s_{1}}{s_{2}} \leadsto \ite{\widetilde{e}}{\widetilde{s_{1}}}{\widetilde{s_{2}}}  \mid \Gamma
               }

     \inferrule*[lab={\footnotesize{T-Seq}}]
               {
                 \Gamma \vdash s_{1} \leadsto \widetilde{s_{1}} \mid \Gamma_{1}\\\\
                 \Gamma_{1} \vdash s_{2} \leadsto \widetilde{s_{2}} \mid \Gamma_{2}
               }
               {
                 \Gamma \vdash s_{1}; s_{2} \leadsto \widetilde{s_{1}}; \widetilde{s_{2}} \mid \Gamma_{2}
               }

\\\\

     \inferrule*[lab={\footnotesize{T-While}}]
               {                 
                 \Gamma(x) = \kw{uint}^{\mathcal{P}}\quad
                 \Gamma \vdash s \leadsto \widetilde{s} \mid \_\quad
                 x \notin \mathsf{modifies}(s)
               }
               {
                 \Gamma \vdash \loops{x}{n_{2}}{s} \leadsto \loops{x}{n_{2}}{\widetilde{s}} \mid \Gamma
               }

  \end{array}
  \]
\caption{Compilation judgments (selected rules)}
\label{fig:compile}
\end{figure}

\subsubsection*{Source to Intermediate Compilation judgments} We provide the compilation
rules in \figureref{compile}. \divya{PL jargon?} We present the rules in a
declarative style, where the rules are non-syntax
directed, and the labels $\ell$ are chosen
non-deterministically. \sectionref{impl} describes the label  inference
scheme in our implementation.

Judgment $\Gamma \vdash e : \tau \leadsto \widetilde{e}$, where
$\Gamma$ maps variables $x$ to types $\tau$, says that
under $\Gamma$, $e$ (in source language) compiles to $\widetilde{e}$ (in intermediate language) with type $\tau$.

The rule ({\sc{T-Cons}}) assigns the label $\mathcal{P}$ to the
constants, as the constants are always public. Rule ({\sc{T-Mult}})
compiles a multiplication to either a public multiplication  ($\mulop_{\mathcal{P}}$), or a
secret arithmetic multiplication ($\mulop_{\mathcal{A}}$). As
our compiler is cryptographic cost aware, it never compiles the
multiplication to boolean multiplication $\mulop_{\mathcal{B}}$. In a similar manner,
rule ({\sc{T-Gt}}) compiles $e_{1} > e_{2}$ to either public comparison,
or secret boolean comparison. The rule for conditional
({\sc{T-Cond}}) has two cases: when the conditional expression $e$ is of
type $\kw{bool}^{\mathcal{P}}$, both the branches have a base type
$\sigma^{\ell'}$, for an arbitrary $\ell'$, and the conditional is
compiled to a public conditional, whereas when the conditional
expression has type $\kw{bool}^{\mathcal{B}}$, $\ell'$ is also
$\mathcal{B}$, and the conditional is compiled to a secret conditional
using a boolean circuit. Note that we restrict the type of the branches
to be of base type. 
Rule ({\sc{T-Read}}) type checks an array read. It checks
that the array index $e$ is public, and uses a static bounds checking
judgment $\Gamma \models e < n$ to prove that the array index is in
bounds. Section~\ref{sec:impl} discusses our implementation of bounds
checking. Rule ({\sc{T-Inp}}) picks a label $m$ for the input. Finally,
rule ({\sc{T-Sub}}) is the subsumption rule that coerces an expression of
type $\sigma^{\ell}$ to an expression of type $\sigma^{m}$ using the
coerce expression. It is important for security that the secrets cannot be coerced to public
values.

Judgment $\Gamma \vdash s : \tau \leadsto \widetilde{s} \mid \Gamma_{1}$
compiles a statement $s$ resulting in the statement $\widetilde{s}$
and type environment $\Gamma_{1}$. Rule ({\sc{T-Decl}}) picks a label
$\ell$, and adds the binding for $x$ to the environment. If $\psi = \sigma$, $\psi^\ell = \sigma^\ell$, else if $\psi = \sigma[n]$, $\psi^\ell = \sigma^\ell[n]$. 
Rule ({\sc{T-Assign}}) looks up the type of $x$ in $\Gamma$ and compiles $e$ to $\tilde{e}$ of same type.
Note that in this rule we restrict the type of variable $x$ to be of base type.
Rule ({\sc{T-For}}) adds the loop counter $x$ to $\Gamma$ at type
$\kw{uint}^{\mathcal{P}}$, and delegates type checking to the
\kw{while} form. The rule ({\sc{T-Write}}), similar to ({\sc{T-Read}}),
checks that the index has type $\kw{uint}^{\mathcal{P}}$, and is in
bounds. Rule ({\sc{T-Out}})
types the expression $e$ at some secret label $m$. Rule ({\sc{T-If}})
checks that the conditional expression is public, and rule
({\sc{T-Seq}}) sequences the type environments. Finally, the typing
rule for the (internal) \kw{while} form ensures that $x$ is mapped in
$\Gamma$ at type $\kw{uint}^{\mathcal{P}}$, and that $x \notin
\mathsf{modifies}(s)$--this is necessary for ensuring the termination
of our semantics.



As mentioned earlier, the intermediate language models the code such as in \figureref{ex-aby} output by our compiler. 
Next, a program in the intermediate language is evaluated to a circuit that can be executed in the distributed setting later. The evaluation to a circuit computes away the public parts of the program and also \emph{flattens} the arrays so that the circuits are unaware of the array structure. 
Crucially, this phase of the semantics does not have access to the secrets.
Below, we first provide the language for the circuits used followed by our evaluation rules.


\begin{figure}
  \small
  \[
  \begin{array}{rrcl}
    \ftext{Wire id} & \wire &&\\
    \ftext{Circuit gate} & \gate & ::= & \wire \mid \kw{in}^{m}_{j} \mid \kw{mult}\:\gate_1\:\gate_{2} \mid \kw{gt}\:\gate_{1}\:\gate_{2}\\
    & & \mid & \kw{mux}\:\gate\:\gate_{1}\:\gate_{2} \mid \bval \rhd m\\
    \ftext{Base value} & \bval & ::= & c \mid \gate\\
    \ftext{Value} & \val & ::= & \bval \mid [\overline{\bval_{i}}]_{n}\\
    %\ftext{Runtime environment} & \widetilde{\rho} & ::= & \cdot \mid \widetilde{\rho},x \mapsto \val \\
    \ftext{Circuit} & \crct & ::= & \cdot \mid \kw{bind}\:\gate\:\wire \mid \kw{out}\:\gate \mid \crct_{1}; \crct_{2}
  \end{array}
  \]
\caption{Circuits   \divya{Can we merge base value and circuit gate?}}
\label{fig:circuits}
\end{figure}

\subsubsection*{Circuits}
\figureref{circuits} shows the circuits syntax. A wire id range
$\wire$ denotes a set of circuit wires that carry the value of a secret
shared variable in the output circuit (we will concretely define these
values later as part of the circuit semantics). Circuit gates $\gate$
are $\wire$, input gates, \kw{mult}, \kw{gt}, and \kw{mux} gates, and
coerce gates $\bval \rhd m$. \divya{Gates are not just gates but a circuit?} Target values $\val$
then consist of base values $c$ and $\gate$, and arrays of base
values. \\





\begin{figure}[t]
  \small
  \fbox{$\widetilde{\rho} \vdash \widetilde{e} \Downarrow \val$}
  \[
  \\
  \begin{array}{c}
    \inferrule*[lab={\footnotesize{S-Var}}]
               {
               }
               {
                 \widetilde{\rho} \vdash x \Downarrow \widetilde{\rho}(x)
               }
               
    \inferrule*[lab={\footnotesize{S-PMult}}]
               {
                 \forall i \in \{1, 2\}.\:\widetilde{\rho} \vdash \widetilde{e_{i}} \Downarrow n_{i}
               }
               {
                 \widetilde{\rho} \vdash \widetilde{e_{1}} \mulop_{\mathcal{P}} \widetilde{e_{2}} \Downarrow n_{1} \mulop n_{2}
               }
               
    \inferrule*[lab={\footnotesize{S-Read}}]
               {
                 \widetilde{\rho} \vdash x \Downarrow [\overline{\wire_i}]_{n_{1}} \\\\
                 \widetilde{\rho} \vdash \widetilde{e} \Downarrow n \quad n < n_{1}
               }
               {
                 \widetilde{\rho} \vdash x[\widetilde{e}] \Downarrow \bval_n
               }\\\\
    \inferrule*[lab={\footnotesize{S-SMult}}]
               {
                 \forall i \in \{1, 2\}.\:\widetilde{\rho} \vdash \widetilde{e_{i}} \Downarrow \gate_{i}
               }
               {
                 \widetilde{\rho} \vdash \widetilde{e_{1}} \mulop_{\mathcal{A}} \widetilde{e_{2}} \Downarrow \kw{mult}\:\gate_{1}\:\gate_{2}
               }

               \hspace{0.3cm}

    \inferrule*[lab={\footnotesize{S-SGt}}]
               {
                 \forall i \in \{1, 2\}.\:\widetilde{\rho} \vdash \widetilde{e_{i}} \Downarrow \gate_{i}
               }
               {
                 \widetilde{\rho} \vdash \widetilde{e_{1}} >_{\mathcal{B}} \widetilde{e_{2}} \Downarrow \kw{gt}\:\gate_{1}\:\gate_{2}
               }\\\\
               \inferrule*[lab={\footnotesize{S-SCond}}]
               {
                 \forall i \in \{1, 2, 3\}.\:\widetilde{\rho} \vdash \widetilde{e_{i}} \Downarrow \gate_{i}
               }
               {
                 \widetilde{\rho} \vdash \lcond{\mathcal{B}}{\widetilde{e_{1}}}{\widetilde{e_{2}}}{\widetilde{e_{3}}} \Downarrow \kw{mux}\:\gate_{1}\:\gate_{2}\:\gate_{3}
               }
               \hspace{0.2cm}
    \inferrule*[lab={\footnotesize{S-Coerce}}]
               {
                 \widetilde{\rho} \vdash \widetilde{e} \Downarrow \val
               }
               {
                 \widetilde{\rho} \vdash \widetilde{e} \rhd m \Downarrow \val \rhd m
               }
               \\\\
               %% \inferrule*[lab={\footnotesize{S-Arr}}]
               %% {
               %%   \forall i \in \{0 \dots n - 1\}.\:\widetilde{\rho} \vdash \widetilde{e_{i}} \Downarrow \widetilde{w_{i}}
               %% }
               %% {
               %%   \widetilde{\rho} \vdash [\overline{\widetilde{e_{i}}}]_{n} \Downarrow [\overline{\widetilde{w_{i}}}]_{n}
               %% }

               \inferrule*[lab={\footnotesize{S-PCond}}]
               {
                 \widetilde{\rho} \vdash \widetilde{e} \Downarrow c\\\\
                 c = \top \Rightarrow \widetilde{e'} = \widetilde{e_{1}}\\
                 c = \bot \Rightarrow \widetilde{e'} = \widetilde{e_{2}}\\\\
                 \widetilde{\rho} \vdash \widetilde{e'} \Downarrow \val
               }
               {
                 \widetilde{\rho} \vdash \lcond{\mathcal{P}}{\widetilde{e}}{\widetilde{e_{1}}}{\widetilde{e_{2}}} \Downarrow \val
               }
               %\hspace{0.5cm}
               
    \inferrule*[lab={\footnotesize{S-Inp}}]
               {
               }
               {
                 \widetilde{\rho} \vdash \kw{in}^{m}_{j} \Downarrow \kw{in}^{m}_{j}
               }
  \end{array}
  \]
  \\\\
    \fbox{$\widetilde{\rho} \vdash \widetilde{s} \Downarrow \widetilde{\rho_1}; \crct$}
  \[
  \\
  \begin{array}{c}
    \inferrule*[lab={\footnotesize{S-DeclC}}]
               {
                 \widetilde{\rho} \vdash \widetilde{e} \Downarrow \val\\\\
                 \left(\val = c\right) \vee \left(\val = [\overline{c_{i}}]_{n}\right)\\\\
                 \widetilde{\rho}_{1} = \widetilde{\rho}, x \mapsto \val
               }
               {
                 \widetilde{\rho} \vdash \tau\:x = \widetilde{e} \Downarrow \widetilde{\rho}_{1}; \cdot
               }
               
               \hspace{0.5cm}

    \inferrule*[lab={\footnotesize{S-DeclCkt}}]
               {
                 \widetilde{\rho} \vdash \widetilde{e} \Downarrow \gate\quad
                 \mathsf{fresh}\:\wire\\\\
                 \widetilde{\rho}_{1} = \widetilde{\rho}, x \mapsto \wire\quad
                 \crct = \kw{bind}\:\gate\:\wire
               }
               {
                 \widetilde{\rho} \vdash \tau\:x = \widetilde{e} \Downarrow \widetilde{\rho}_{1}; \crct
               }

\\\\
    \inferrule*[lab={\footnotesize{S-DeclCktA}}]
               {
                 \widetilde{\rho} \vdash \widetilde{e} \Downarrow [\overline{\gate_{i}}]_{n}\\\\
                 \forall i \in [n].\:\mathsf{fresh}\:\wire_{i}\\\\
                 \widetilde{\rho}_{1} = \widetilde{\rho}, x \mapsto [\overline{\wire_{i}}]_{n}\quad
                 \crct = \overline{\kw{bind}\:\gate_{i}\:\wire_{i}}
               }
               {
                 \widetilde{\rho} \vdash \tau\:x = \widetilde{e} \Downarrow \widetilde{\rho}_{1}; \chi
               }

               \hspace{0.2cm}
               
    \inferrule*[lab={\footnotesize{S-Out}}]
               {
                 \widetilde{\rho} \vdash \widetilde{e} \Downarrow \gate
               }
               {
                 \widetilde{\rho} \vdash \kw{out}\:\widetilde{e} \Downarrow \widetilde{\rho}; \kw{out}\:\gate
               }

               \\\\
    \inferrule*[lab={\footnotesize{S-If}}]
               {
                 \widetilde{\rho} \vdash \widetilde{e} \Downarrow c\\\\
                 c = \top \Rightarrow \widetilde{s} = \widetilde{s_{1}}\\\\
                 c = \bot \Rightarrow \widetilde{s} = \widetilde{s_{2}}\\\\
                 \widetilde{\rho} \vdash \widetilde{s} \Downarrow \widetilde{\rho}_{1}; \crct
               }
               {
                 \widetilde{\rho} \vdash \ite{\widetilde{e}}{\widetilde{s_{1}}}{\widetilde{s_{2}}} \Downarrow \widetilde{\rho}_{1}; \crct
               }

               \hspace{0.5cm}
               
    \inferrule*[lab={\footnotesize{S-WriteCkt}}]
               {
                 \widetilde{\rho} \vdash x \Downarrow [\overline{\wire_{i}}]_{n}\quad
                 \widetilde{\rho} \vdash \widetilde{e_{1}} \Downarrow n_{1}\\\\
                 n_{1} < n\quad
                 \mathsf{fresh}\:\wire\quad
                 \widetilde{\rho} \vdash \widetilde{e_{2}} \Downarrow \gate\\\\
                 \widetilde{\rho}_{1} = \widetilde{\rho}[x \mapsto ([\overline{\wire_{i}}]_{n}[n_{1} \mapsto \wire])]
               }
               {
                 \widetilde{\rho} \vdash x[\widetilde{e_{1}}] := \widetilde{e_{2}} \Downarrow \widetilde{\rho}_{1}; \kw{bind}\:\gate\:\wire
               }

\end{array}
  \]
\caption{Evaluation of Intermediate Language to Circuit (selected rules)}
\label{fig:eval-inter-circ}
\end{figure}

\subsubsection*{Evaluation to Circuit} \figureref{eval-inter-circ} shows the judgments for the evaluation of the intermediate language to a circuit. 
The runtime environment is defined as follows:

\vspace{0.2cm}
$
\small
\begin{array}{rrcl}
    \ftext{Runtime environment} & \widetilde\rho &::=& \cdot \mid \rho,x \mapsto \val\\
\end{array}
$
\vspace{0.2cm}

We first focus on the expression evaluation judgment
$\widetilde{\rho} \vdash \widetilde{e} \Downarrow\val$. 
%
Rules ({\sc{S-PMult}}) and ({\sc{S-SMult}}) illustrate
the significance of the operator labels. In particular, the rule
({\sc{S-PMult}}) evaluates a public multiplication $\widetilde{e_{1}}
\mulop_{\mathcal{P}} \widetilde{e_{2}}$ to $n_{1} \mulop n_{2}$, similar to the
source language. In contrast, the rule
({\sc{S-SMult}}) evaluates a secret multiplication $\widetilde{e_{1}}
\mulop_{\mathcal{A}} \widetilde{e_{2}}$ to an arithmetic multiplication
gate $\kw{mult}\:\gate_{1}\:\gate_{2}$. As mentioned above, the intermediate language
expressions generated by our compiler never have $\widetilde{e_{1}}
\mulop_{\mathcal{B}} \widetilde{e_{2}}$, as our compiler is aware that $\mulop$
is more performant using an arithmetic circuit compared to a boolean
one. Rules ({\sc{S-PCond}}) and ({\sc{S-SCond}})
are along the similar lines. Rule ({\sc{S-PCond}}) evaluates a public
conditional to the value from one of the branches, while the rule
({\sc{S-SCond}}) evaluates to a \kw{mux} gate that takes input
circuits from the guard ($\gate_{1}$) and both the branches
($\gate_{2}$ and $\gate_{3}$). Once again for performance reasons,
the target expressions from our compiler do not have
$\lcond{\mathcal{A}}{e_{1}}{e_{2}}{e_{3}}$. Rules
({\sc{S-Coerce}}) and ({\sc{S-Inp}}) evaluate to the coerce and input
gates respectively.

Statement evaluation $\widetilde{\rho} \vdash \widetilde{s} \Downarrow
\widetilde{\rho}_{1}; \chi$ evaluates statements $\widetilde{s}$ to produce a new
environment $\widetilde{\rho}_{1}$, and a circuit $\crct$. A circuit $\crct$ (shown
in \figureref{circuits}) is either empty, \kw{bind}-ing of a
circuit gate $\gate$ to wire $\wire$, \kw{out} gate, or a sequence of
circuits. Rules ({\sc{S-DeclC}}), ({\sc{S-DeclCkt}}), and
({\sc{S-DeclCktA}}) show the variable declaration cases. Rule
({\sc{S-DeclC}}) shows the case when $\widetilde{e}$ evaluates to
$\val$, where $\val$ is either a constant or an
array of constants. In this case, the mapping $x \mapsto
\val$ is added to the environment, and the resulting circuit
is empty. When 
$\widetilde{e}$ evaluates to a circuit $\gate$, rule
({\sc{S-DeclCkt}}) picks a fresh wire $\wire$, adds the mapping $x \mapsto \wire$
to the environment $\widetilde{\rho}$, and outputs the circuit
$\kw{bind}\:\gate\:\wire$. Rule ({\sc{S-DeclCktA}}) is analogous for
$\widetilde{e}$ evaluating to an array of circuits. The variable
assignment rules (not shown in the figure) are similar. Rule
({\sc{S-WriteCkt}}) shows the case for writing to an array, where the
array contents are secret. Finally, rule ({\sc{S-Out}}) compiles to an
\kw{out} circuit.


\divya{Start here...}
\subsubsection*{Circuit semantics} Evaluating a program in the intermediate language produces a
circuit over the secret data to be computed using an \mpc protocol in the distributed setting. With
our circuit semantics, we model the \emph{functional} aspect of a \mpc protocol, parametrized by the sharing functions.

During the circuit evaluation, the wire ranges $r$ are
mapped to (random) strings $b$. The semantics of these strings is
given by pairs of encryption-decryption functions\nc{perhaps call this encode-decode functions since its technically not encryption-decryption? In fact more appropriate might be share-reconstruct, but that would require changing notation so lets not do that.}, written as
$\mathcal{E}_{m}$ and $\mathcal{D}_{m}$ (where $m$ is either
$\mathcal{A}$ or $\mathcal{B}$). More concretely,
$\mathcal{E}_{m}(c)$ returns a pair of two string $b_{1}$ and $b_{2}$
(shares of the two parties), with the property that
$\mathcal{D}_{m}(b_{1}, b_{2}) = c$. We assume that the underlying MPC
protocol instantiates $\mathcal{E}_{m}$ and $\mathcal{D}_{m}$
appropriately.

The circuit semantics is shown in Figure~\ref{fig:cktsem} using the
judgments $\widehat{\rho}_{1}, \widehat{\rho}_{2} \vdash \kappa
\Downarrow b_{1}, b_{2}$, and $\widehat{\rho}_{1}, \widehat{\rho}_{2}
\vdash \chi \Downarrow \widehat{\rho}'_{1}, \widehat{\rho}'_{2}; O$,
where $\widehat{\rho}_{1}$ and $\widehat{\rho}_{2}$ are the circuit
environments of the two parties, mapping wire ranges $r$ to strings
$b$. Rule ({\sc{C-Add}}) evinces the pattern for evaluating circuit
gates $\kappa$. To evaluate $\kw{add}\:\kappa_{1}\:\kappa_{2}$, the
rule first evaluates $\kappa_{1}$ to $(b_{11}, b_{21})$ and
$\kappa_{2}$ to $(b_{12}, b_{22})$. Shares $(b_{11}, b_{21})$ are then
combined using $\mathcal{D_{\mathcal{A}}}$ to $n_{1}$, and similarly
$(b_{12}, b_{22})$ are combined to $n_{2}$. The final output of the
\kw{add} gate is then $\mathcal{E}_{\mathcal{A}}(n_{1} + n_{2})$. Note
that this is a functional description of how the \kw{add} gate
evaluates, of course, concretely $n_{1}$ and $n_{2}$ are not observed
by the parties. Rule ({\sc{C-Coerce}}) re-encrypts the shares using the
scheme for $m$. Coming to the evaluation of circuits, the evaluation
of \kw{bind} updates the mapping of $r$ in the input environments, and
the rule ({\sc{C-Out}}) outputs the clear value $c$ to the
observations.




\begin{figure}
  \small
  \fbox{$\widehat{\rho_{1}}, \widehat{\rho_{2}} \vdash \kappa \Downarrow b_{1}, b_{2}$}
  \[
  \\
  \begin{array}{c}
    %% \inferrule*[lab={\footnotesize{C-Wire}}]
    %%            {
    %%              b_{1}, b_{2} = \widehat{\rho_{1}}(r), \widehat{\rho_{2}}(r)
    %%            }
    %%            {
    %%              \widehat{\rho_{1}}, \widehat{\rho_{2}} \vdash r \Downarrow b_{1}, b_{2}
    %%            }               
    \inferrule*[lab={\footnotesize{C-In}}]
               {
                 b_{1}, b_{2} = \mathcal{E}_{m}(c)
               }
               {
                 \widehat{\rho_{1}}, \widehat{\rho_{2}} \vdash \kw{in}^{m}_{j} \Downarrow b_{1}, b_{2}
               }

               \hspace{0.3cm}
               
    \inferrule*[lab={\footnotesize{C-Coerce}}]
               {
                 \widehat{\rho_{1}}, \widehat{\rho_{2}} \vdash \kappa \Downarrow b_{1}, b_{2}\\\\
                 c = \mathcal{D}_{m_{1}}(b_{1}, b_{2})\\\\
                 b'_{1}, b'_{2} = \mathcal{E}_{m}(c)
               }
               {
                 \widehat{\rho_{1}}, \widehat{\rho_{2}} \vdash \kappa \rhd m \Downarrow b'_{1}, b'_{2}
               }
\\\\

    \inferrule*[lab={\footnotesize{C-Add}}]
               {
                 \forall i \in \{1, 2\}.\:\widehat{\rho_{1}}, \widehat{\rho_{2}} \vdash \kappa_{i} \Downarrow b_{1i}, b_{2i}\quad
                 n_{i} = \mathcal{D}_{\mathcal{A}}(b_{1i}, b_{2i})\\\\
                 b_{1}, b_{2} = \mathcal{E}_{\mathcal{A}}(n_{1} + n_{2})
               }
               {
                 \widehat{\rho_{1}}, \widehat{\rho_{2}} \vdash \kw{add}\:\kappa_{1}\:\kappa_{2} \Downarrow b_{1}, b_{2}
               }

\\\\

    \inferrule*[lab={\footnotesize{C-Gt}}]
               {
                 \forall i \in \{1, 2\}.\:\widehat{\rho_{1}}, \widehat{\rho_{2}} \vdash \kappa_{i} \Downarrow b_{1i}, b_{2i}\quad
                 n_{i} = \mathcal{D}_{\mathcal{B}}(b_{1i}, b_{2i})\\\\
                 b_{1}, b_{2} = \mathcal{E}_{\mathcal{B}}(n_{1} > n_{2})
               }
               {
                 \widehat{\rho_{1}}, \widehat{\rho_{2}} \vdash \kw{gt}\:\kappa_{1}\:\kappa_{2} \Downarrow b_{1}, b_{2}
               }

\\\\

    \inferrule*[lab={\footnotesize{C-Mux}}]
               {
                 \forall i \in \{1, 2, 3\}.\:\widehat{\rho_{1}}, \widehat{\rho_{2}} \vdash \kappa_{i} \Downarrow b_{1i}, b_{2i}\quad
                 c_{i} = \mathcal{D}_{\mathcal{B}}(b_{1i}, b_{2i})\\\\
                 c_{1} = \top \Rightarrow b_{1}, b_{2} = \mathcal{E}_{\mathcal{B}}(c_{2})\quad
                 c_{1} = \bot \Rightarrow b_{1}, b_{2} = \mathcal{E}_{\mathcal{B}}(c_{3})
               }
               {
                 \widehat{\rho_{1}}, \widehat{\rho_{2}} \vdash \kw{mux}\:\kappa_{1}\:\kappa_{2}\:\kappa_{3} \Downarrow b_{1}, b_{2}
               }

  \end{array}
  \]
  \\\\
    \fbox{$\widehat{\rho_{1}}, \widehat{\rho_{2}} \vdash \chi \Downarrow \widehat{\rho'_{1}}, \widehat{\rho'_{2}}; O$}
  \[
  \\
  \begin{array}{c}
    \inferrule*[lab={\footnotesize{C-Bind}}]
               {
                 \widehat{\rho_{1}}, \widehat{\rho_{2}} \vdash \kappa \Downarrow b_{1}, b_{2}\\\\
                 \widehat{\rho'_{1}} = \widehat{\rho_{1}}[r \mapsto b_{1}] \quad
                 \widehat{\rho'_{2}} = \widehat{\rho_{2}}[r \mapsto b_{2}]
               }
               {
                 \widehat{\rho_{1}}, \widehat{\rho_{2}} \vdash \kw{bind}\:\kappa\:r \Downarrow \widehat{\rho'_{1}}, \widehat{\rho'_{2}}; \cdot
               }
               
               \hspace{0.1cm}

    \inferrule*[lab={\footnotesize{C-Out}}]
               {
                 \widehat{\rho_{1}}, \widehat{\rho_{2}} \vdash \kappa \Downarrow b_{1}, b_{2}\\\\
                 c = \mathcal{D}_{m}(b_{1}, b_{2})
               }
               {
                 \widehat{\rho_{1}}, \widehat{\rho_{2}} \vdash \kw{out}\:\kappa \Downarrow \widehat{\rho_{1}}, \widehat{\rho_{2}}; c
               }
\end{array}
  \]
\caption{Circuit semantics (selected rules)}
\label{fig:cktsem}
\end{figure}




\subsubsection*{Correctness theorem} We first define a judgment for
translation of environments, $\Gamma \vdash \rho \leadsto
\widetilde{\rho}; \widehat{\rho}_{1}, \widehat{\rho}_{2}$. The
judgment is defined inductively on $\Gamma$, and establishes that
the static environment $\Gamma$ is consistent with the runtime
environments $\rho$, $\widetilde{\rho}$, and $\widehat{\rho}_{1}$ and
$\widehat{\rho}_{2}$. As an example, if $x:\kw{uint}^{\mathcal{P}} \in
\Gamma$, the judgment checks that $\rho(x) = \widetilde{\rho}(x) =
n$, for some $n$. We elide the judgment, providing the full definition
in the supplementary material.

With this judgment in hand, the correctness theorem is as follows:

\begin{theorem}[Correctness]\label{theorem:correctness}
  $\forall\:\Gamma, s, \widetilde{s}, \Gamma_{1}, \rho, \widetilde{\rho}, \widehat{\rho}_{1}, \widehat{\rho}_{2}$, if:

  \begin{enumerate}
  \item $\Gamma \vdash s \leadsto \widehat{s} \mid \Gamma_{1}$
  \item $\Gamma \vdash \rho \leadsto \widetilde{\rho}; \widehat{\rho}_{1}, \widehat{\rho}_{2}$
  \end{enumerate}

  then $\exists \rho_{1}, O_{1}, \widetilde{\rho}_{1}, \chi, \widehat{\rho}'_{1}, \widehat{\rho}'_{2}, O_{2}$, s.t.

  \begin{enumerate}[label=(\alph*)]
  \item $\rho \vdash s \Downarrow \rho_{1}; O_{1}$
  \item $\widetilde{\rho} \vdash \widetilde{s} \Downarrow \widetilde{\rho}_{1}; \chi$
  \item $\widehat{\rho}_{1}, \widehat{\rho}_{2} \vdash \chi \Downarrow \widehat{\rho}'_{1}, \widehat{\rho}'_{2}; O_{2}$
  \item $\Gamma_{1} \vdash \rho_{1} \leadsto \widetilde{\rho}_{1}; \widehat{\rho}'_{1}, \widehat{\rho}'_{2}$
  \item $O_{1} = O_{2}$
  \end{enumerate}
  
\end{theorem}

The theorem states that if a source statement $s$ is well-typed, and
compiles to $\widetilde{s}$, then $s$ terminates in the source
semantics with observations $O_{1}$, $\widetilde{s}$ terminates in the
target semantics with circuit $\chi$, and $\chi$ terminates in the
circuit semantics with observations $O_{2}$, where $O_{1} = O_{2}$
Furthermore, the final environments are also in the compilation
relation.

\nc{Should we point out that the proof of Theorem 1 is provided elsewhere?}
\subsubsection*{Security theorem} The protocols we generate provide
simulation-based security against a semi-honest adversary, in the
framework of ~\cite{gmw,can00,can01}. At a very high level, in this
framework, parties are modeled as non-uniform interactive turing
machines (ITMs), with inputs provided by an environment $\env$. An
adversary $\adv$, selects and ``corrupts'' one of the parties -
however, $\adv$ still follows the protocol specification. $\adv$
interacts with the $\env$, which observes the view of the corrupted
party. At the end of the interaction, $\env$ outputs a single bit. Two
different interactions are defined: the {\em real world} and an {\em
  ideal world}. In the real interaction, the parties run the protocol
$\prot$ in the presence of $\adv$ and $\env$. Let
$\real_{\prot,\adv,\env}$ denote the binary distribution ensemble
describing $\env$'s output in this interaction. In the ideal
interaction, parties send their inputs to an additional entity, a
trusted functionality machine $\F$ that carries the desired
computation truthfully. Let $\simu$ (the simulator) denote the
adversary in this idealized execution, and $\ideal_{\F,\simu,\env}$
the binary distribution ensemble describing $\env$'s output after
interacting with adversary $\simu$ and ideal functionality $\F$. A
protocol $\prot$ is said to {\em securely realize} a functionality
$\F$ if for every adversary $\adv$ in the real interaction, there is
an adversary $\simu$ in the ideal interaction, such that no
environment $\env$, on any input, can tell the real interaction apart
from the ideal interaction, except with negligible probability (in the
security parameter $\secparam$). More precisely, if the two binary
distribution ensembles above are computationally indistinguishable. 

We shall assume a cryptographic MPC backend that securely implements any circuit $\chi$ that is output by our compiler. In more detail, this means that for every source program $s$, let $\chi$ be the circuit output by our compiler (as in Theorem \ref{theorem:correctness}). We assume that there exists a two-party secure computation protocol $\prot$ that securely realizes the functionality $\chi$ and we will call the corresponding simulator for the protocol as $\simu_{\tiny{2pc}}$ (that runs on input $\chi$ and the output produced by $\chi$ on the parties inputs). We note that the work of \cite{aby} provides such a protocol $\prot$ and simulator $\simu_{\tiny{2pc}}$ for all circuits $\chi$ output by our compiler. We are now ready to state and prove our security theorem.
 
\begin{theorem}[Security]\label{theorem:security}
Let $s$ be any functionality or program in our source language with outputs (or observations) $O_1$, that is compiled into a circuit $\chi$ (as defined in Theorem \ref{theorem:correctness}). Let protocol $\prot$ be the two-party secure computation protocol that securely realizes $\chi$ (as defined above). Then, $\prot$ securely realizes $s$.  
\end{theorem}

\noindent {\em Proof.} Our simulator $\simu$ simply runs our compiler on program $s$ to obtain $\chi$ and upon receiving output $O_1$, executes $\simu_{\tiny{2pc}}$ on $\chi$ and $O_1$. Let $O_2$ be the outputs (or observations) of $\chi$. First, from Theorem \ref{theorem:correctness}, we have that the observations in $s$ and $\chi$ are the same (i.e. $O_2 = O_1$). Now, from the security of $\prot$, we have that the simulated view output by $\simu_{\tiny{2pc}}$ (with circuit $\chi$ and output $O_2$) is indistinguishable from the real view of the $\prot$ (when executed on circuit $\chi$ and when the output is $O_2$). Combining these two statements, the proof of the theorem follows. 
\aseem{Can we give a construction of the simulator S in the ideal
  semantics? The simulator S whenever it receives an observable event,
  outputs it to Z, and whenever A receives a string in the real
  semantics, S outputs a random string to Z. Now, with theorem 1,
  observable events are same in the ideal and real semantics, and with
  the security of the crypto backend, the random strings and the
  strings in the protocol are indistinguishable. Is it
  incorrect/naive?

  Also, we should emaphasize here that the ideal semantics is the
  source semantics from Figure x and the real semantics is the circuit
  semantics from Figure y. For the target language semantics, we
  should emphasize that it does not have access to the secrets, so
  there are no observations there.
}

\nc{OK now?}
  %% \\
  %% \[
  %% \begin{array}{rrcl}
  %%   \ftext{Value} & v &::=& c \mid [\overline{c_{i}}]_{n}\\
  %%   \ftext{Observation} & O &::=& \cdot \mid c; O\\
  %% \end{array}
  %% \]
