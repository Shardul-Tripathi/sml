\newcommand{\kw}[1]{{\lstinline[basicstyle=\small\color{blue}]{#1}}}
\newcommand{\ftext}[1]{\text{\small{#1}}}
\newcommand{\cond}[3]{\ensuremath{{{#1}\:?\:{#2}\::{#3}}}}
\newcommand{\for}[4]{\ensuremath{\kw{for}\:{#1}\:\kw{in}\:[{#2}, {#3}]\:\kw{do}\:{#4}}}
\newcommand{\ite}[3]{\ensuremath{\kw{if}({#1}, {#2}, {#3})}}
\newcommand{\loops}[3]{\ensuremath{\kw{while}\:{#1} \leq {#2}\:\kw{do}\:{#3}}}

\section{Formal development}
\label{sec:ld}

In this section we prove the correctness and security of our compiler.
%
We first formalize the source and target languages. Our source runtime
semantics is a model of the ideal, trusted third-party semantics, and
generates observations corresponding to the values revealed to the
parties.
%
The target language semantics (a model of the C++ code generated by
our compiler implementation) ``computes away'' the public parts and
arrays from the compiled program, generating a secure computation
circuit. Crucially, this semantics does not have access to the secret
inputs--those are processed by the secure computation circuit.
%
Finally, we formalize the circuit semantics that computes the
generated circuit, and like the source semantics, emits observations
corresponding to the values revealed to the parties.

We then present the compilation rules. To prove the correctness
of our compiler, we prove that it preserves the observations. For
security of our compiler, we reduce the security argument to the
security of the cryptographic protocol used to compute the secure
computation circuit.

We present only selected parts of our formalization for space
reasons. Full definitions and proofs can be found in the supplementary
material submitted along with the paper.


\begin{figure}
  \small
  \[
  \begin{array}{rrcl}
    \ftext{Base type} & \sigma &::=& \kw{uint} \mid \kw{bool}\\
    \ftext{Type} & \psi &::=& \sigma \mid \sigma[n]\\
    \ftext{Constant} & c &::=& n \mid \top \mid \bot\\
    \ftext{Expression} & e &::=& c \mid x \mid e_{1} + e_{2} \mid e_{1} > e_{2} \mid \cond{e_{1}}{e_{2}}{e_{3}}\\
    & &\mid& [\overline{e_{i}}]_{n} \mid x[e] \mid \kw{in}_{j}\\
    \ftext{Statement} & s &::=& \psi\:x = e \mid x := e \mid \for{x}{n_{1}}{n_{2}}{s}\\
    & & \mid& x[e_{1}] := e_{2} \mid \ite{e}{s_{1}}{s_{2}} \mid \kw{out}\:e \mid s_{1}; s_{2}\\
    & & \mid& \loops{x}{n}{s}
  \end{array}
  \]
\caption{Source language}
\label{fig:srclang}
\end{figure}

\begin{figure}
  \small
  \fbox{$\rho \vdash e \Downarrow v$}
  \[
  \\
  \begin{array}{c}
    \inferrule*[lab={\footnotesize{E-Var}}]
               {
               }
               {
                 \rho \vdash x \Downarrow \rho(x)
               }
               
               \hspace{0.1cm}
               
    \inferrule*[lab={\footnotesize{E-Add}}]
               {
                 \forall i \in \{1, 2\}.\:\rho \vdash e_{i} \Downarrow n_{i}
               }
               {
                 \rho \vdash e_{1} + e_{2} \Downarrow n_{1} + n_{2}
               }

               \hspace{0.1cm}
               
    \inferrule*[lab={\footnotesize{E-Read}}]
               {
                 \rho \vdash x \Downarrow [\overline{c_{i}}]_{n_{1}} \\\\
                 \rho \vdash e \Downarrow n \quad n < n_{1}
               }
               {
                 \rho \vdash x[e] \Downarrow c_{n}
               }
\\\\
    \inferrule*[lab={\footnotesize{E-Arr}}]
               {
                 \forall i \in \{0 \dots n - 1\}.\:\rho \vdash e_{i} \Downarrow c_{i}
               }
               {
                 \rho \vdash [\overline{e_{i}}]_{n} \Downarrow [\overline{c_{i}}]_{n}
               }
               \quad
    \inferrule*[lab={\footnotesize{E-Inp}}]
               {
               }
               {
                 \rho \vdash \kw{in}_{j} \Downarrow c
               }
  \end{array}
  \]
  \\\\
    \fbox{$\rho \vdash c \Downarrow \rho'; O$}
  \[
  \\
  \begin{array}{c}
    \inferrule*[lab={\footnotesize{E-Decl}}]
               {
                 \rho \vdash e \Downarrow v
               }
               {
                 \rho \vdash \psi\:x = e \Downarrow \rho, x \mapsto v; \cdot
               }
               
               \hspace{0.1cm}

    \inferrule*[lab={\footnotesize{E-LoopT}}]
               {
                 \rho(x) > n
               }
               {
                 \rho \vdash \loops{x}{n}{s} \Downarrow \rho; \cdot
               }

               \\\\
               
    \inferrule*[lab={\footnotesize{E-LoopI}}]
               {
                 \rho(x) \leq n\\\\
                 \rho \vdash s \Downarrow \rho_{1}; O_{1}\\\\
                 \rho_{2} = [\rho_{1}]_{\mathsf{dom}(\rho)}[x \mapsto \rho_{1}(x) + 1]\\\\
                 \rho_{2} \vdash \loops{x}{n}{s} \Downarrow \rho_{3}; O_{2}
               }
               {
                 \rho \vdash \loops{x}{n}{s} \Downarrow \rho_{3}; O_{1}, O_{2}
               }

               \hspace{0.2cm}

    \inferrule*[lab={\footnotesize{E-If}}]
               {
                 \rho \vdash e \Downarrow c\\\\
                 c = \top \Rightarrow s = s_{1}\\\\
                 c = \bot \Rightarrow s = s_{2}\\\\
                 \rho \vdash s \Downarrow \rho_{1}; O
               }
               {
                 \rho \vdash \ite{e}{s_{1}}{s_{2}} \Downarrow \rho_{1}; O
               }

               \\\\
               
    \inferrule*[lab={\footnotesize{E-For}}]
               {
                 \rho, x \mapsto n_{1} \vdash \loops{x}{n_{2}}{s} \Downarrow \rho_{1}; O
               }
               {
                 \rho \vdash \for{x}{n_{1}}{n_{2}}{s} \Downarrow \rho_{1} - \{x\}; O
               }


               \hspace{0.2cm}

    \inferrule*[lab={\footnotesize{E-Out}}]
               {
                 \rho \vdash e \Downarrow c
               }
               {
                 \rho \vdash \kw{out}\:e \Downarrow \rho; c
               }

\end{array}
  \]
\caption{Source semantics (selected rules)}
\label{fig:srcsem}
\end{figure}

\subsubsection*{Source language}Our source language
(Figure~\ref{fig:srclang}) is a simple imperative language. Types
$\psi$ consist of the base types $\sigma$, and arrays
of base types $\sigma[n]$, where $n$ is the array length. Though we
model only one dimensional arrays, our implementation supports higher
dimensional arrays as well. Expressions in the language include the
integer constants $n$, \kw{bool} constants $\top$ and $\bot$,
variables $x$, binary operations $e_{1} + e_{2}$ and $e_{1} > e_{2}$,
conditionals $\cond{e}{e_{1}}{e_{2}}$, array literals 
$[\overline{e_{i}}]_{n}$\footnote{We write $\overline{e}$ (and
  similarly for other symbols) to denote a sequence of expressions.
The length of the sequence is usually clear from the context.}, and
array reads $x[e]$. The expression $\kw{in}_{j}$ denotes input from
party $j$. The statements $s$ in the language comprise of variable
declarations and assignments ($\psi\:x = e$ and $x := e$ resp.),
\kw{for} loops, array writes ($x[e_{1}] := e_{2}$), \kw{if}
statements, and sequence of statements ($s_{1}; s_{2}$). The statement
$\kw{out}\:e$ denotes revealing the value of $e$ to the
parties. The \kw{while} statement is an internal syntax that is not
exposed to the programmer.

The runtime semantics for the source language is shown in
Figure~\ref{fig:srcsem}. Values $v$, runtime environments $\rho$, and
observations $O$ are defined as follows:

\vspace{0.2cm}
$
\small
\begin{array}{rrcl}
    \ftext{Value} & v &::=& c \mid [\overline{c_{i}}]_{n}\\
    \ftext{Runtime environment} & \rho &::=& \cdot \mid \rho[x \mapsto v]\\
    \ftext{Observation} & O & ::= & \cdot \mid c, O \\
\end{array}
$

\vspace{0.2cm}
Values consist of constants and array values, runtime environment
$\rho$ maps variables to values, and observations are sequences of
constants.

The judgment $\rho \vdash e \Downarrow v$ denotes the big-step
evaluation of an expression~$e$ to a value~$v$ under the runtime
environment~$\rho$. Rule ({\sc{E-Var}}) looks up the value of $x$ in
the environment. Rule ({\sc{E-Add}}) inductively evaluates $e_{1}$ and
$e_{2}$, and evaluates to their sum. Rule ({\sc{E-Read}})
evaluates an array read operation. It first evaluates $x$ to an array
value $[\overline{c_{i}}]_{n_{1}}$, and $e$ to a \kw{uint} value
$n$. It then returns $c_{n}$, the $n$-th index value in the array,
provided $n < n_{1}$, the length of the array. Rule ({\sc{E-Inp}})
evaluates to some constant $c$ denoting party $j$'s input. We model
the inputs to be base constants, an array input can be written in the
language as $[\kw{in}_{j}]_{n}$, which can then evaluate using the
rule ({\sc{E-Arr}}). The remaining rules are straightforward, and are
elided for space reasons.

The judgment $\rho \vdash s \Downarrow \rho_{1}; O$ represents the
big-step evaluation of a statement $s$ under environment $\rho$
producing a new environment $\rho_{1}$ and observations $O$. Rule
({\sc{E-Decl}}) evaluates the expression $e$ to $v$, and returns the
updated environment $\rho[x \mapsto v]$, with empty observations. Rule
({\sc{E-If}}) evaluates the guard expression, and then evaluates
either $s_{1}$ or $s_{2}$ accordingly. $\kw{for}$ statements evaluate
through the internal $\kw{while}$ syntax. Specifically, the rule
({\sc{E-For}}) updates $\rho$ with the initial counter value $n_{1}$,
evaluates $\loops{x}{n_{2}}{s}$ to $\rho_{1}; O$, and returns
$\rho_{1} - \{x\}$ (removing $x$ from $\rho_{1}$) and $O$. Rule
({\sc{E-LoopI}}) shows the inductive case for \kw{while}
statements, when $\rho(x) \leq n$. The rule evaluates $s$, producing
$\rho_{1}; O_{1}$. It then restricts $\rho_{1}$ to the domain of
$\rho$ ($[\rho_{1}]_{\mathsf{dom}(\rho)}$) to remove the variables
added by $s$, increments the value if $x$, and evaluates the
\kw{while} statement under this updated environment. Rule
({\sc{E-LoopT}}) is the termination case for \kw{while} statements,
when $\rho(x) > n$. Finally, the rule ({\sc{E-Out}}) evaluates the
expression, and adds its value to the observations.

\newcommand{\lcond}[4]{\ensuremath{{{#2}\:?_{{#1}}\:{#3}\::{#4}}}}
%\newcommand{\for}[4]{\ensuremath{\kw{for}\:{#1}\:\kw{in}\:[{#2}, {#3}]\:\kw{do}\:{#4}}}
%\newcommand{\ite}[3]{\ensuremath{\kw{if}({#1}, {#2}, {#3})}}
%\newcommand{\loops}[3]{\ensuremath{\kw{while}\:{#1} \leq {#2}\:\kw{do}\:{#3}}}

\begin{figure}
  \small
  \[
  \begin{array}{rrcl}
    \ftext{Secret label} & m &::=& \mathcal{A} \mid \mathcal{B}\\
    \ftext{Label} & \ell &::=& \mathcal{P} \mid m\\
    \ftext{Type} & \tau &::=& \sigma^{\ell} \mid \sigma^{\ell}[n]\\
    \ftext{Expression} & \widetilde{e} &::=& c \mid x \mid \widetilde{e_{1}} +_{\ell} \widetilde{e_{2}} \mid \widetilde{e_{1}} >_{\ell} \widetilde{e_{2}} \\
    & & \mid & \lcond{\ell}{{\widetilde{e}}}{{\widetilde{e_{1}}}}{{\widetilde{e_{2}}}} \mid x[\widetilde{e}] \mid [\overline{\widetilde{e_{i}}}]_{n} \mid \kw{in}^{m}_{j} \mid \widetilde{e} \rhd m\\
    \ftext{Statement} & \widetilde{s} &::=& \tau\:x = \widetilde{e} \mid x := \widetilde{e} \mid \dots \mid \widetilde{s_{1}}; \widetilde{s_{2}} \mid \dots\\
  \end{array}
  \]
\caption{Target language}
\label{fig:tgtlang}
\end{figure}

\begin{figure}
  \small
  \[
  \begin{array}{rrcl}
    \ftext{Wire id} & r &&\\
    \ftext{Circuit gate} & \kappa & ::= & r \mid \kw{in}^{m}_{j} \mid \kw{add}\:\kappa_{1}\:\kappa_{2} \mid \kw{gt}\:\kappa_{1}\:\kappa_{2}\\
    & & \mid & \kw{mux}\:\kappa\:\kappa_{1}\:\kappa_{2} \mid \widetilde{w} \rhd m\\
    \ftext{Base value} & \widetilde{w} & ::= & c \mid \kappa\\
    \ftext{Value} & \widetilde{v} & ::= & \widetilde{w} \mid [\overline{\widetilde{w}_{i}}]_{n}\\
    \ftext{Runtime environment} & \widetilde{\rho} & ::= & \cdot \mid \widetilde{\rho}[x \mapsto \widetilde{v}]\\
    \ftext{Circuit} & \chi & ::= & \cdot \mid \kw{bind}\:\kappa\:r \mid \kw{out}\:\kappa \mid \chi_{1}; \chi_{2}
  \end{array}
  \]
\caption{Target runtime}
\label{fig:tgtruntime}
\end{figure}


\begin{figure}
  \small
  \fbox{$\widetilde{\rho} \vdash \widetilde{e} \Downarrow \widetilde{v}$}
  \[
  \\
  \begin{array}{c}
    \inferrule*[lab={\footnotesize{S-Var}}]
               {
               }
               {
                 \widetilde{\rho} \vdash x \Downarrow \widetilde{\rho}(x)
               }
               
    \inferrule*[lab={\footnotesize{S-PAdd}}]
               {
                 \forall i \in \{1, 2\}.\:\widetilde{\rho} \vdash \widetilde{e_{i}} \Downarrow n_{i}
               }
               {
                 \widetilde{\rho} \vdash \widetilde{e_{1}} +_{\mathcal{P}} \widetilde{e_{2}} \Downarrow n_{1} + n_{2}
               }
               
    \inferrule*[lab={\footnotesize{S-Read}}]
               {
                 \widetilde{\rho} \vdash x \Downarrow [\overline{\widetilde{w_{i}}}]_{n_{1}} \\\\
                 \widetilde{\rho} \vdash \widetilde{e} \Downarrow n \quad n < n_{1}
               }
               {
                 \widetilde{\rho} \vdash x[\widetilde{e}] \Downarrow \widetilde{w_{n}}
               }\\\\
    \inferrule*[lab={\footnotesize{S-SAdd}}]
               {
                 \forall i \in \{1, 2\}.\:\widetilde{\rho} \vdash \widetilde{e_{i}} \Downarrow \kappa_{i}
               }
               {
                 \widetilde{\rho} \vdash \widetilde{e_{1}} +_{\mathcal{A}} \widetilde{e_{2}} \Downarrow \kw{add}\:\kappa_{1}\:\kappa_{2}
               }

               \hspace{0.3cm}

    \inferrule*[lab={\footnotesize{S-SGt}}]
               {
                 \forall i \in \{1, 2\}.\:\widetilde{\rho} \vdash \widetilde{e_{i}} \Downarrow \kappa_{i}
               }
               {
                 \widetilde{\rho} \vdash \widetilde{e_{1}} >_{\mathcal{B}} \widetilde{e_{2}} \Downarrow \kw{gt}\:\kappa_{1}\:\kappa_{2}
               }\\\\
               \inferrule*[lab={\footnotesize{S-SCond}}]
               {
                 \forall i \in \{1, 2, 3\}.\:\widetilde{\rho} \vdash \widetilde{e_{i}} \Downarrow \kappa_{i}
               }
               {
                 \widetilde{\rho} \vdash \lcond{\mathcal{B}}{\widetilde{e_{1}}}{\widetilde{e_{2}}}{\widetilde{e_{3}}} \Downarrow \kw{mux}\:\kappa_{1}\:\kappa_{2}\:\kappa_{3}
               }
               \hspace{0.2cm}
    \inferrule*[lab={\footnotesize{S-Coerce}}]
               {
                 \widetilde{\rho} \vdash \widetilde{e} \Downarrow \widetilde{v}
               }
               {
                 \widetilde{\rho} \vdash \widetilde{e} \rhd m \Downarrow \widetilde{v} \rhd m
               }
               \\\\
               %% \inferrule*[lab={\footnotesize{S-Arr}}]
               %% {
               %%   \forall i \in \{0 \dots n - 1\}.\:\widetilde{\rho} \vdash \widetilde{e_{i}} \Downarrow \widetilde{w_{i}}
               %% }
               %% {
               %%   \widetilde{\rho} \vdash [\overline{\widetilde{e_{i}}}]_{n} \Downarrow [\overline{\widetilde{w_{i}}}]_{n}
               %% }

               \inferrule*[lab={\footnotesize{S-PCond}}]
               {
                 \widetilde{\rho} \vdash \widetilde{e} \Downarrow c\\\\
                 c = \top \Rightarrow \widetilde{e'} = \widetilde{e_{1}}\\
                 c = \bot \Rightarrow \widetilde{e'} = \widetilde{e_{2}}\\\\
                 \widetilde{\rho} \vdash \widetilde{e'} \Downarrow \widetilde{v}
               }
               {
                 \widetilde{\rho} \vdash \lcond{\mathcal{P}}{\widetilde{e}}{\widetilde{e_{1}}}{\widetilde{e_{2}}} \Downarrow \widetilde{v}
               }
               %\hspace{0.5cm}
               
    \inferrule*[lab={\footnotesize{S-Inp}}]
               {
               }
               {
                 \widetilde{\rho} \vdash \kw{in}^{m}_{j} \Downarrow \kw{in}^{m}_{j}
               }
  \end{array}
  \]
  \\\\
    \fbox{$\widetilde{\rho} \vdash \widetilde{c} \Downarrow \widetilde{\rho'}; \chi$}
  \[
  \\
  \begin{array}{c}
    \inferrule*[lab={\footnotesize{S-DeclC}}]
               {
                 \widetilde{\rho} \vdash \widetilde{e} \Downarrow \widetilde{v}\\\\
                 \widetilde{v} = c \vee \widetilde{v} = [\overline{c_{i}}]_{n}\\\\
                 \widetilde{\rho}_{1} = \widetilde{\rho}, x \mapsto \widetilde{v}
               }
               {
                 \widetilde{\rho} \vdash \tau\:x = \widetilde{e} \Downarrow \widetilde{\rho}_{1}; \cdot
               }
               
               \hspace{0.5cm}

    \inferrule*[lab={\footnotesize{S-DeclCkt}}]
               {
                 \widetilde{\rho} \vdash \widetilde{e} \Downarrow \kappa\quad
                 \mathsf{fresh}\:r\\\\
                 \widetilde{\rho}_{1} = \widetilde{\rho}, x \mapsto r\quad
                 \chi = \kw{bind}\:\kappa\:r
               }
               {
                 \widetilde{\rho} \vdash \tau\:x = \widetilde{e} \Downarrow \widetilde{\rho}_{1}; \chi
               }

\\\\
    \inferrule*[lab={\footnotesize{S-DeclCktA}}]
               {
                 \widetilde{\rho} \vdash \widetilde{e} \Downarrow [\overline{\kappa_{i}}]_{n}\\\\
                 \forall i \in \{0 \dots n - 1\}.\:\mathsf{fresh}\:r_{i}\\\\
                 \widetilde{\rho}_{1} = \widetilde{\rho}, x \mapsto [r_{i}]_{n}\quad
                 \chi = \overline{\kw{bind}\:\kappa_{i}\:r_{i}}
               }
               {
                 \widetilde{\rho} \vdash \tau\:x = \widetilde{e} \Downarrow \widetilde{\rho}_{1}; \chi
               }

               \hspace{0.2cm}
               
    \inferrule*[lab={\footnotesize{S-Out}}]
               {
                 \widetilde{\rho} \vdash \widetilde{e} \Downarrow \kappa
               }
               {
                 \widetilde{\rho} \vdash \kw{out}\:\widetilde{e} \Downarrow \widetilde{\rho}; \kw{out}\:\kappa
               }

               \\\\
    \inferrule*[lab={\footnotesize{S-If}}]
               {
                 \widetilde{\rho} \vdash \widetilde{e} \Downarrow c\\\\
                 c = \top \Rightarrow \widetilde{s} = \widetilde{s_{1}}\\\\
                 c = \bot \Rightarrow \widetilde{s} = \widetilde{s_{2}}\\\\
                 \widetilde{\rho} \vdash \widetilde{s} \Downarrow \widetilde{\rho}_{1}; \chi
               }
               {
                 \widetilde{\rho} \vdash \ite{\widetilde{e}}{\widetilde{s_{1}}}{\widetilde{s_{2}}} \Downarrow \widetilde{\rho}_{1}; \chi
               }

               \hspace{0.5cm}
               
    \inferrule*[lab={\footnotesize{S-WriteCkt}}]
               {
                 \widetilde{\rho} \vdash x \Downarrow [\overline{r_{i}}]_{n}\quad
                 \widetilde{\rho} \vdash \widetilde{e_{1}} \Downarrow n_{1}\\\\
                 n_{1} < n\quad
                 \mathsf{fresh}\:r\quad
                 \widetilde{\rho} \vdash \widetilde{e_{2}} \Downarrow \kappa\\\\
                 \widetilde{\rho}_{1} = \widetilde{\rho}[x \mapsto [\overline{r_{i}}]_{n}[n_{1} \mapsto r]]
               }
               {
                 \widetilde{\rho} \vdash x[\widetilde{e_{1}}] := \widetilde{e_{2}} \Downarrow \widetilde{\rho}_{1}; \kw{bind}\:\kappa\:r
               }

\end{array}
  \]
\caption{Target semantics (selected rules)}
\label{fig:tgtsem}
\end{figure}

\subsubsection*{Target language} Figure~\ref{fig:tgtlang} shows the
target language of our compiler. The syntax follows that of the source
language, except that the types and operators are \emph{labeled}. Below
we mainly focus on the bits that are different from the source
language.

Labels $\ell$ consist of secret labels $\mathcal{A}$ and
$\mathcal{B}$, denoting the arithmetic and boolean shared secrets
resp., and the public label $\mathcal{P}$. Types $\tau$ are then
labeled base types $\sigma^{\ell}$ and arrays of labeled base types
$\sigma^{\ell}[n]$.

Most of the expression forms $\widetilde{e}$ are same as $e$, except
that the binary operators, and the conditional forms
are annotated with label $\ell$, denoting how the operators should be
evaluated ($\mathcal{P}$ for in-clear, and $\mathcal{A}$ and
$\mathcal{B}$ for using arithmetic or boolean circuits resp.). The
form $\widetilde{e} \rhd m$ denotes coercing $\widetilde{e}$ to be
$m$-secret shared. The statements $\widetilde{s}$ are analogous to
$s$.

The target semantics models the semantics of the code output by
our compiler (C++ code in our implementation). It computes over the
public parts of the program, emitting a circuit that can later be
evaluated using a cryptographic MPC protocol. The semantics also
\emph{flattens} the arrays so that the circuits are unaware of the
array structure. Crucially, this phase of the semantics does not have
access to the secrets.

Figure~\ref{fig:tgtruntime} shows the runtime syntax. A wire id range
$r$ denotes a set of circuit wires that carry the value of a secret
shared variable in the output circuit (we will concretely define these
values later as part of the circuit semantics). Circuit gates $\kappa$
are $r$, input gates, \kw{add}, \kw{gt}, and \kw{mux} gates, and
coerce gates $\widetilde{w} \rhd m$. Target values $\widetilde{v}$
then consist of base values $c$ and $\kappa$, and arrays of base
values.

Figure~\ref{fig:tgtsem} shows the judgments for the target
semantics. We first focus on the expression evaluation judgment
$\widetilde{\rho} \vdash \widetilde{e} \Downarrow
\widetilde{v}$. Rules ({\sc{S-PAdd}}) and ({\sc{S-SAdd}}) illustrate
the significance of the operator labels. In particular, the rule
({\sc{S-PAdd}}) evaluates a public addition $\widetilde{e_{1}}
+_{\mathcal{P}} \widetilde{e_{2}}$ to $n_{1} + n_{2}$, similar to the
source language. In contrast, the rule
({\sc{S-SAdd}}) evaluates a secret addition $\widetilde{e_{1}}
+_{\mathcal{A}} \widetilde{e_{2}}$ to an arithmetic add
gate $\kw{add}\:\kappa_{1}\:\kappa_{2}$. Foreshadowing on the
compilation rules to be presented later, the target
expressions from our compiler never have $\widetilde{e_{1}}
+_{\mathcal{B}} \widetilde{e_{2}}$, as our compiler is aware that $+$
is more performant using arithmetic circuit, rather than a boolean
one. Rules ({\sc{S-PCond}}) and ({\sc{S-SCond}})
are along the similar lines. Rule ({\sc{S-PCond}}) evaluates a public
conditional to the value from one of the branches, while the rule
({\sc{S-SCond}}) evaluates to a \kw{mux} gate that takes input
circuits from the conditional ($\kappa_{1}$) and both the branches
($\kappa_{2}$ and $\kappa_{3}$). Once again for performance reasons,
the target expressions from our compiler do not have
$\lcond{\mathcal{A}}{e_{1}}{e_{2}}{e_{3}}$. Rules
({\sc{S-Coerce}}) and ({\sc{S-Inp}}) evaluate to the coerce and input
gates respectively.

Statement evaluation $\widetilde{\rho} \vdash \widetilde{s} \Downarrow
\widetilde{\rho}_{1}; \chi$ evaluates a target statement to produce a new
environment $\widetilde{\rho}_{1}$, and a circuit $\chi$. $\chi$ (shown
in Figure~\ref{fig:tgtlang}) is either empty, \kw{bind}-ing of a
circuit gate $\kappa$ to range $r$, \kw{out} gate, or a sequence of
circuits. Rules ({\sc{S-DeclC}}), ({\sc{S-DeclCkt}}), and
({\sc{S-DeclCktA}}) show the variable declaration cases. Rule
({\sc{S-DeclC}}) shows the case when $\widetilde{e}$ evaluates to
$\widetilde{v}$, where $\widetilde{v}$ is either a constant or an
array of constants. In this case, the mapping $x \mapsto
\widetilde{v}$ is added to the environment, and the resulting circuit
is empty. When 
$\widetilde{e}$ evaluates to a circuit $\kappa$, rule
({\sc{S-DeclCkt}}) picks a fresh $r$, adds the mapping $x \mapsto r$
to the environment, and outputs the circuit
$\kw{bind}\:\kappa\:r$. Rule ({\sc{S-DeclCktA}}) is analogous for
$\widetilde{e}$ evaluating to an array of circuits. The variable
assignment rules (not shown in the figure) are similar. Rule
({\sc{S-WriteCkt}}) shows the case for writing to an array, where the
array contents are secret. Finally, rule ({\sc{S-Out}}) compiles to an
\kw{out} circuit.

\begin{figure}
  \small
  \fbox{$\widehat{\rho_{1}}, \widehat{\rho_{2}} \vdash \kappa \Downarrow b_{1}, b_{2}$}
  \[
  \\
  \begin{array}{c}
    %% \inferrule*[lab={\footnotesize{C-Wire}}]
    %%            {
    %%              b_{1}, b_{2} = \widehat{\rho_{1}}(r), \widehat{\rho_{2}}(r)
    %%            }
    %%            {
    %%              \widehat{\rho_{1}}, \widehat{\rho_{2}} \vdash r \Downarrow b_{1}, b_{2}
    %%            }               
    \inferrule*[lab={\footnotesize{C-In}}]
               {
                 b_{1}, b_{2} = \mathcal{E}_{m}(c)
               }
               {
                 \widehat{\rho_{1}}, \widehat{\rho_{2}} \vdash \kw{in}^{m}_{j} \Downarrow b_{1}, b_{2}
               }

               \hspace{0.3cm}
               
    \inferrule*[lab={\footnotesize{C-Coerce}}]
               {
                 \widehat{\rho_{1}}, \widehat{\rho_{2}} \vdash \kappa \Downarrow b_{1}, b_{2}\\\\
                 c = \mathcal{D}_{m_{1}}(b_{1}, b_{2})\\\\
                 b'_{1}, b'_{2} = \mathcal{E}_{m}(c)
               }
               {
                 \widehat{\rho_{1}}, \widehat{\rho_{2}} \vdash \kappa \rhd m \Downarrow b'_{1}, b'_{2}
               }
\\\\

    \inferrule*[lab={\footnotesize{C-Add}}]
               {
                 \forall i \in \{1, 2\}.\:\widehat{\rho_{1}}, \widehat{\rho_{2}} \vdash \kappa_{i} \Downarrow b_{1i}, b_{2i}\quad
                 n_{i} = \mathcal{D}_{\mathcal{A}}(b_{1i}, b_{2i})\\\\
                 b_{1}, b_{2} = \mathcal{E}_{\mathcal{A}}(n_{1} + n_{2})
               }
               {
                 \widehat{\rho_{1}}, \widehat{\rho_{2}} \vdash \kw{add}\:\kappa_{1}\:\kappa_{2} \Downarrow b_{1}, b_{2}
               }

\\\\

    \inferrule*[lab={\footnotesize{C-Gt}}]
               {
                 \forall i \in \{1, 2\}.\:\widehat{\rho_{1}}, \widehat{\rho_{2}} \vdash \kappa_{i} \Downarrow b_{1i}, b_{2i}\quad
                 n_{i} = \mathcal{D}_{\mathcal{B}}(b_{1i}, b_{2i})\\\\
                 b_{1}, b_{2} = \mathcal{E}_{\mathcal{B}}(n_{1} > n_{2})
               }
               {
                 \widehat{\rho_{1}}, \widehat{\rho_{2}} \vdash \kw{gt}\:\kappa_{1}\:\kappa_{2} \Downarrow b_{1}, b_{2}
               }

\\\\

    \inferrule*[lab={\footnotesize{C-Mux}}]
               {
                 \forall i \in \{1, 2, 3\}.\:\widehat{\rho_{1}}, \widehat{\rho_{2}} \vdash \kappa_{i} \Downarrow b_{1i}, b_{2i}\quad
                 c_{i} = \mathcal{D}_{\mathcal{B}}(b_{1i}, b_{2i})\\\\
                 c_{1} = \top \Rightarrow b_{1}, b_{2} = \mathcal{E}_{\mathcal{B}}(c_{2})\quad
                 c_{1} = \bot \Rightarrow b_{1}, b_{2} = \mathcal{E}_{\mathcal{B}}(c_{3})
               }
               {
                 \widehat{\rho_{1}}, \widehat{\rho_{2}} \vdash \kw{mux}\:\kappa_{1}\:\kappa_{2}\:\kappa_{3} \Downarrow b_{1}, b_{2}
               }

  \end{array}
  \]
  \\\\
    \fbox{$\widehat{\rho_{1}}, \widehat{\rho_{2}} \vdash \chi \Downarrow \widehat{\rho'_{1}}, \widehat{\rho'_{2}}; O$}
  \[
  \\
  \begin{array}{c}
    \inferrule*[lab={\footnotesize{C-Bind}}]
               {
                 \widehat{\rho_{1}}, \widehat{\rho_{2}} \vdash \kappa \Downarrow b_{1}, b_{2}\\\\
                 \widehat{\rho'_{1}} = \widehat{\rho_{1}}[r \mapsto b_{1}] \quad
                 \widehat{\rho'_{2}} = \widehat{\rho_{2}}[r \mapsto b_{2}]
               }
               {
                 \widehat{\rho_{1}}, \widehat{\rho_{2}} \vdash \kw{bind}\:\kappa\:r \Downarrow \widehat{\rho'_{1}}, \widehat{\rho'_{2}}; \cdot
               }
               
               \hspace{0.1cm}

    \inferrule*[lab={\footnotesize{C-Out}}]
               {
                 \widehat{\rho_{1}}, \widehat{\rho_{2}} \vdash \kappa \Downarrow b_{1}, b_{2}\\\\
                 c = \mathcal{D}_{m}(b_{1}, b_{2})
               }
               {
                 \widehat{\rho_{1}}, \widehat{\rho_{2}} \vdash \kw{out}\:\kappa \Downarrow \widehat{\rho_{1}}, \widehat{\rho_{2}}; c
               }
\end{array}
  \]
\caption{Circuit semantics (selected rules)}
\label{fig:cktsem}
\end{figure}


\subsubsection*{Circuit semantics} The target semantics produces a
circuit to compute over the secret data using an MPC protocol. With
our circuit semantics, we model the \emph{functional} aspect of the
protocol, parametrized by the sharing functions.

During the circuit evaluation, the wire ranges $r$ are
mapped to (random) strings $b$. The semantics of these strings is
given by pairs of encryption-decryption functions, written as
$\mathcal{E}_{m}$ and $\mathcal{D}_{m}$ (where $m$ is either
$\mathcal{A}$ or $\mathcal{B}$). More concretely,
$\mathcal{E}_{m}(c)$ returns a pair of two string $b_{1}$ and $b_{2}$
(shares of the two parties), with the property that
$\mathcal{D}_{m}(b_{1}, b_{2}) = c$. We assume that the underlying MPC
protocol instantiates $\mathcal{E}_{m}$ and $\mathcal{D}_{m}$
appropriately.

The circuit semantics is shown in Figure~\ref{fig:cktsem} using the
judgments $\widehat{\rho}_{1}, \widehat{\rho}_{2} \vdash \kappa
\Downarrow b_{1}, b_{2}$, and $\widehat{\rho}_{1}, \widehat{\rho}_{2}
\vdash \chi \Downarrow \widehat{\rho}'_{1}, \widehat{\rho}'_{2}; O$,
where $\widehat{\rho}_{1}$ and $\widehat{\rho}_{2}$ are the circuit
environments of the two parties, mapping wire ranges $r$ to strings
$b$. Rule ({\sc{C-Add}}) evinces the pattern for evaluating circuit
gates $\kappa$. To evaluate $\kw{add}\:\kappa_{1}\:\kappa_{2}$, the
rule first evaluates $\kappa_{1}$ to $(b_{11}, b_{21})$ and
$\kappa_{2}$ to $(b_{12}, b_{22})$. Shares $(b_{11}, b_{21})$ are then
combined using $\mathcal{D_{\mathcal{A}}}$ to $n_{1}$, and similarly
$(b_{12}, b_{22})$ are combined to $n_{2}$. The final output of the
\kw{add} gate is then $\mathcal{E}_{\mathcal{A}}(n_{1} + n_{2})$. Note
that this is a functional description of how the \kw{add} gate
evaluates, of course, concretely $n_{1}$ and $n_{2}$ are not observed
by the parties. Rule ({\sc{C-Coerce}}) re-encrypts the shares using the
scheme for $m$. Coming to the evaluation of circuits, the evaluation
of \kw{bind} updates the mapping of $r$ in the input environments, and
the rule ({\sc{C-Out}}) outputs the clear value $c$ to the
observations.

\begin{figure}
  \small
  \fbox{$\Gamma \vdash e : \tau \leadsto \widetilde{e}$}
  \[
  \begin{array}{c}
     \inferrule*[lab={\footnotesize{T-Cons}}]
               {
                 \tau = \mathsf{typeof}(c)^{\mathcal{P}}
               }
               {
                 \Gamma \vdash c : \tau \leadsto c 
               }

     \inferrule*[lab={\footnotesize{T-Add}}]
               {
                 \forall i \in \{1,2\}.\:\Gamma \vdash e_{i} : \kw{uint}^{\ell} \leadsto \widetilde{e_{i}}\\\\
                 \ell = \mathcal{P} \vee \ell = \mathcal{A}
               }
               {
                 \Gamma \vdash e_{1} + e_{2} : \kw{uint}^{\ell} \leadsto \widetilde{e_{1}} +_{\ell} \widetilde{e_{2}}
               }

    %% \inferrule*[lab={\footnotesize{T-Cons}}]
    %%            {
    %%              \tau = \mathsf{typeof}(c)^{\mathcal{P}}
    %%            }
    %%            {
    %%              \Gamma \vdash c : \tau \leadsto c
    %%            }

    %%  \inferrule*[lab={\footnotesize{T-Var}}]
    %%            {
    %%            }
    %%            {
    %%              \Gamma \vdash x : \Gamma(x) \leadsto x
    %%            }
\\\\
     \inferrule*[lab={\footnotesize{T-Gt}}]
               {
                 \forall i \in \{1,2\}.\:\Gamma \vdash e_{i} : \kw{uint}^{\ell} \leadsto \widetilde{e_{i}}\\\\
                 \ell = \mathcal{P} \vee \ell = \mathcal{B}
               }
               {
                 \Gamma \vdash e_{1} > e_{2} : \kw{bool}^{\ell} \leadsto \widetilde{e_{1}} >_{\ell} \widetilde{e_{2}}
               }

     \inferrule*[lab={\footnotesize{T-Read}}]
               {
                 \Gamma \vdash x : \sigma^{\ell}[n] \leadsto x\\\\
                 \Gamma \vdash e : \kw{uint}^{\mathcal{P}} \leadsto \widetilde{e}\\\\
                 \Gamma \models e < n
               }
               {
                 \Gamma \vdash x[e] : \sigma^{\ell} \leadsto x[\widetilde{e}]
               }

\\\\               

     \inferrule*[lab={\footnotesize{T-Cond}}]
               {
                 \Gamma \vdash e : \kw{bool}^{\ell} \leadsto \widetilde{e}\\\\
                 \forall i \in \{1,2\}.\:\Gamma \vdash e_{i} : \sigma^{\ell_{1}} \leadsto \widetilde{e_{i}}\\\\
                 \ell = \mathcal{P} \vee (\ell = \mathcal{B} \wedge \ell' =\mathcal{B})
               }
               {
                 \Gamma \vdash \cond{e}{e_{1}}{e_{2}} : \sigma^{\ell_{1}} \leadsto \lcond{\ell}{\widetilde{e}}{\widetilde{e_{1}}}{\widetilde{e_{2}}}
               }

     \inferrule*[lab={\footnotesize{T-Inp}}]
               {
               }
               {
                 \Gamma \vdash \kw{in}_{j} : \sigma^{m} \leadsto \kw{in}^{m}_{j}
               }
               
\\\\               

     \inferrule*[lab={\footnotesize{T-Arr}}]
               {
                 \forall i \in \{0 \dots n - 1\}.\:\Gamma \vdash e_{i} : \sigma^{\ell} \leadsto \widetilde{e_{i}}
               }
               {
                 \Gamma \vdash [\overline{e_{i}}]_{n} : \sigma^{\ell}[n] \leadsto [\overline{\widetilde{e_{i}}}]_{n}
               }

     \inferrule*[lab={\footnotesize{T-Sub}}]
               {
                 \Gamma \vdash e : \sigma^{\ell} \leadsto \widetilde{e}
               }
               {
                 \Gamma \vdash e : \sigma^{m} \leadsto \widetilde{e} \rhd m
               }

  \end{array}
  \]
  \\\\
    \fbox{$\Gamma \vdash s \leadsto \widetilde{s} \mid \Gamma_{1}$}
  \[
  \\
  \begin{array}{c}
     \inferrule*[lab={\footnotesize{T-Decl}}]
               {
                 \psi = \sigma \Rightarrow \tau = \sigma^{\ell}\\\\
                 \psi = \sigma[n] \Rightarrow \tau = \sigma^{\ell}[n]\\\\
                 \Gamma \vdash e : \tau \leadsto \widetilde{e}
               }
               {
                 \Gamma \vdash \psi\:x = e \leadsto \tau\:x = \widetilde{e} \mid \Gamma, x:\tau
               }

     \inferrule*[lab={\footnotesize{T-Assgn}}]
               {
                 \Gamma(x) = \sigma^{\ell}\\\\
                 \Gamma \vdash e : \sigma^{\ell} \leadsto \widetilde{e}
               }
               {
                 \Gamma \vdash x := e \leadsto x = \widetilde{e} \mid \Gamma
               }

\\\\

     \inferrule*[lab={\footnotesize{T-For}}]
               {
                 \Gamma_{1} = \Gamma, x:\kw{uint}^{\mathcal{P}}\\\\
                 \Gamma_{1} \vdash \loops{x}{n_{2}}{s} \leadsto \loops{x}{n_{2}}{\widetilde{s}} \mid \Gamma_{1}
               }
               {
                 \Gamma \vdash \for{x}{n_{1}}{n_{2}}{s} \leadsto \for{x}{n_{1}}{n_{2}}{\widetilde{s}} \mid \Gamma
               }

               \\\\

     \inferrule*[lab={\footnotesize{T-Write}}]
               {
                 \Gamma \vdash x : \sigma^{\ell}[n] \leadsto x\\\\
                 \Gamma \vdash e_{1} : \kw{uint}^{\mathcal{P}} \leadsto \widetilde{e_{1}}\\\\
                 \Gamma \vdash e_{2} : \sigma^{\ell} \leadsto \widetilde{e_{2}}\\\\
                 \Gamma \models e_{1} < n
               }
               {
                 \Gamma \vdash x[e_{1}] := e_{2} \leadsto x[\widetilde{e_{1}}] := \widetilde{e_{2}} \mid \Gamma
               }

     \inferrule*[lab={\footnotesize{T-Out}}]
               {
                 \Gamma \vdash e : \sigma^{m} \leadsto \widetilde{e}
               }
               {
                 \Gamma \vdash \kw{out}\:e \leadsto \kw{out}\:\widetilde{e} \mid \Gamma
               }

\\\\

     \inferrule*[lab={\footnotesize{T-If}}]
               {
                 \Gamma \vdash e : \kw{bool}^{\mathcal{P}} \leadsto \widetilde{e}\\\\
                 \forall i \in \{1, 2\}.\:\Gamma \vdash s_{i} \leadsto \widetilde{s_{i}} \mid \_
               }
               {
                 \Gamma \vdash \ite{e}{s_{1}}{s_{2}} \leadsto \ite{\widetilde{e}}{\widetilde{s_{1}}}{\widetilde{s_{2}}}  \mid \Gamma
               }

     \inferrule*[lab={\footnotesize{T-Seq}}]
               {
                 \Gamma \vdash s_{1} \leadsto \widetilde{s_{1}} \mid \Gamma_{1}\\\\
                 \Gamma_{1} \vdash s_{2} \leadsto \widetilde{s_{2}} \mid \Gamma_{2}
               }
               {
                 \Gamma \vdash s_{1}; s_{2} \leadsto \widetilde{s_{1}}; \widetilde{s_{2}} \mid \Gamma_{2}
               }

\\\\

     \inferrule*[lab={\footnotesize{T-While}}]
               {                 
                 \Gamma(x) = \kw{uint}^{\mathcal{P}}\quad
                 \Gamma \vdash s \leadsto \widetilde{s} \mid \_\quad
                 x \notin \mathsf{modifies}(s)
               }
               {
                 \Gamma \vdash \loops{x}{n_{2}}{s} \leadsto \loops{x}{n_{2}}{\widetilde{s}} \mid \Gamma
               }

  \end{array}
  \]
\caption{Compilation judgments (selected rules)}
\label{fig:compile}
\end{figure}

\subsubsection*{Compilation judgments} We now come to the compilation
rules shown in Figure~\ref{fig:compile}. We present the rules in a
declarative style, where the rules are non-syntax
directed, and the labels $\ell$ are chosen
non-deterministically. Section~\ref{sec:impl} describes the inference
scheme in our implementation.

Judgment $\Gamma \vdash e : \tau \leadsto \widetilde{e}$, where
$\Gamma$ maps variables $x$ to types $\tau$, says that
under $\Gamma$, $e$ compiles to $\widetilde{e}$ with type $\tau$.

The rule ({\sc{T-Cons}}) assigns the label $\mathcal{P}$ to the
constants, as the constants are always public. Rule ({\sc{T-Add}})
compiles an addition to either public addition ($+_{\mathcal{P}}$), or
secret addition using an arithmetic circuit ($+_{\mathcal{A}}$). As
our compiler is cryptographic cost aware, it never compiles the
addition to boolean addition $+_{\mathcal{B}}$. In a similar manner,
rule ({\sc{T-Gt}}) compiles $e_{1} > e_{2}$ to either public comparison,
or secret comparison using boolean circuits. The rule for conditional
({\sc{T-Cond}}) has two cases: when the conditional expression $e$ is of
type $\kw{bool}^{\mathcal{P}}$, both the branches have a base type
$\sigma^{\ell_{1}}$, for an arbitrary $\ell_{1}$, and the conditional is
compiled to public conditional, whereas when the conditional
expression has type $\kw{bool}^{\mathcal{B}}$, $\ell_{1}$ is also
$\mathcal{B}$, and the conditional is compiled to a secret conditional
using a boolean circuit. Note that we restrict the type of the branches
to be of base type. Rule ({\sc{T-Read}}) types an array read. It checks
that the array index $e$ is public, and uses a static bounds checking
judgment $\Gamma \models e < n$ to prove that the array index is in
bounds. Section~\ref{sec:impl} discusses our implementation of bounds
checking. Rule ({\sc{T-Inp}}) picks a label $m$ for the input. Finally,
rule ({\sc{T-Sub}}) is the subsumption rule that coerces an expression of
type $\sigma^{\ell}$ to an expression of type $\sigma^{m}$ using the
coerce expression. Importantly, secrets cannot be coerced to public
values.

Judgment $\Gamma \vdash s : \tau \leadsto \widetilde{s} \mid \Gamma_{1}$
compiles a statement $s$ resulting in the statement $\widetilde{s}$
and type environment $\Gamma_{1}$. Rule ({\sc{T-Decl}}) picks a label
$\ell$, and adds the binding for $x$ to the environment. Rule
({\sc{T-For}}) adds the loop counter $x$ to $\Gamma$ at type
$\kw{uint}^{\mathcal{P}}$, and delegates type checking to the
\kw{while} form. The rule ({\sc{T-Write}}), similar to ({\sc{T-Read}}),
checks that the index has type $\kw{uint}^{\mathcal{P}}$, and is in
bounds. Rule ({\sc{T-Out}})
types the expression $e$ at some secret label $m$. Rule ({\sc{T-If}})
checks that the conditional expression is public, and rule
({\sc{T-Seq}}) sequences the type environments. Finally, the typing
rule for the (internal) \kw{while} form ensures that $x$ is mapped in
$\Gamma$ at type $\kw{uint}^{\mathcal{P}}$, and that $x \notin
\mathsf{modifies}(s)$--this is necessary for ensuring the termination
of our semantics.

\subsubsection*{Correctness theorem} We first define a judgment for
translation of environments, $\Gamma \vdash \rho \leadsto
\widetilde{\rho}; \widehat{\rho}_{1}, \widehat{\rho}_{2}$. The
judgment is defined inductively on $\Gamma$, and establishes that
the static environment $\Gamma$ is consistent with the runtime
environments $\rho$, $\widetilde{\rho}$, and $\widehat{\rho}_{1}$ and
$\widehat{\rho}_{2}$. As an example, if $x:\kw{uint}^{\mathcal{P}} \in
\Gamma$, the judgment checks that $\rho(x) = \widetilde{\rho}(x) =
n$, for some $n$. We elide the judgment, providing the full definition
in the supplementary material.

With this judgment in hand, the correctness theorem is as follows:

\begin{theorem}[Correctness]\label{theorem:correctness}
  $\forall\:\Gamma, s, \widetilde{s}, \Gamma_{1}, \rho, \widetilde{\rho}, \widehat{\rho}_{1}, \widehat{\rho}_{2}$, if:

  \begin{enumerate}
  \item $\Gamma \vdash s \leadsto \widehat{s} \mid \Gamma_{1}$
  \item $\Gamma \vdash \rho \leadsto \widetilde{\rho}; \widehat{\rho}_{1}, \widehat{\rho}_{2}$
  \end{enumerate}

  then $\exists \rho_{1}, O_{1}, \widetilde{\rho}_{1}, \chi, \widehat{\rho}'_{1}, \widehat{\rho}'_{2}, O_{2}$, s.t.

  \begin{enumerate}[label=(\alph*)]
  \item $\rho \vdash s \Downarrow \rho_{1}; O_{1}$
  \item $\widetilde{\rho} \vdash \widetilde{s} \Downarrow \widetilde{\rho}_{1}; \chi$
  \item $\widehat{\rho}_{1}, \widehat{\rho}_{2} \vdash \chi \Downarrow \widehat{\rho}'_{1}, \widehat{\rho}'_{2}; O_{2}$
  \item $\Gamma_{1} \vdash \rho_{1} \leadsto \widetilde{\rho}_{1}; \widehat{\rho}'_{1}, \widehat{\rho}'_{2}$
  \item $O_{1} = O_{2}$
  \end{enumerate}
  
\end{theorem}

The theorem states that if a source statement $s$ is well-typed, and
compiles to $\widetilde{s}$, then $s$ terminates in the source
semantics with observations $O_{1}$, $\widetilde{s}$ terminates in the
target semantics with circuit $\chi$, and $\chi$ terminates in the
circuit semantics with observations $O_{2}$, where $O_{1} = O_{2}$
Furthermore, the final environments are also in the compilation
relation.

\nc{Super high level security theorem}
\subsubsection*{Security theorem} The protocols we generate provide
simulation-based security against a semi-honest adversary, in the
framework of ~\cite{gmw,can00,can01}. At a very high level, in this
framework, parties are modeled as non-uniform interactive turing
machines (ITMs), with inputs provided by an environment $\env$. An
adversary $\adv$, selects and ``corrupts'' one of the parties -
however, $\adv$ still follows the protocol specification. $\adv$
interacts with the $\env$, which observes the view of the corrupted
party. At the end of the interaction, $\env$ outputs a single bit. Two
different interactions are defined: the {\em real world} and an {\em
  ideal world}. In the real interaction, the parties run the protocol
$\prot$ in the presence of $\adv$ and $\env$. Let
$\real_{\prot,\adv,\env}$ denote the binary distribution ensemble
describing $\env$'s output in this interaction. In the ideal
interaction, parties send their inputs to an additional entity, a
trusted functionality machine $\F$ that carries the desired
computation truthfully. Let $\simu$ (the simulator) denote the
adversary in this idealized execution, and $\ideal_{\F,\simu,\env}$
the binary distribution ensemble describing $\env$'s output after
interacting with adversary $\simu$ and ideal functionality $\F$. A
protocol $\prot$ is said to {\em securely realize} a functionality
$\F$ if for every adversary $\adv$ in the real interaction, there is
an adversary $\simu$ in the ideal interaction, such that no
environment $\env$, on any input, can tell the real interaction apart
from the ideal interaction, except with negligible probability (in the
security parameter $\secparam$). More precisely, if the two binary
distribution ensembles above are computationally indistinguishable.
\nc{I'm not happy with the theorem statement.}
\begin{theorem}[Security]\label{theorem:security}
Let $\F$ be a functionality in our source language with outputs (or observations) $O_1$, that is compiled into a protocol $\prot$ in our target language with outputs $O_2$, then $\prot$ securely realizes $\F$.  
\end{theorem}
\nc{We should probably connect things to earlier? Theorem 1 and 2 have very different languages.}
\noindent {\em Proof.} From Theorem \ref{theorem:correctness}, we have
that the observations in $\prot$ and $\F$ are the same (i.e. $O_2 =
O_1$). Now, from the simulation security of our backend (\cite{aby}),
the proof of the above theorem follows. \nc{I dont know how to say
  more.}

\aseem{Can we give a construction of the simulator S in the ideal
  semantics? The simulator S whenever it receives an observable event,
  outputs it to Z, and whenever A receives a string in the real
  semantics, S outputs a random string to Z. Now, with theorem 1,
  observable events are same in the ideal and real semantics, and with
  the security of the crypto backend, the random strings and the
  strings in the protocol are indistinguishable. Is it
  incorrect/naive?

  Also, we should emaphasize here that the ideal semantics is the
  source semantics from Figure x and the real semantics is the circuit
  semantics from Figure y. For the target language semantics, we
  should emphasize that it does not have access to the secrets, so
  there are no observations there.
}

  %% \\
  %% \[
  %% \begin{array}{rrcl}
  %%   \ftext{Value} & v &::=& c \mid [\overline{c_{i}}]_{n}\\
  %%   \ftext{Observation} & O &::=& \cdot \mid c; O\\
  %% \end{array}
  %% \]
