\section{Motivating example}
\label{sec:ex}
%$w^Tx>0$, mnist logistic regression
Consider a hypothetical cloud provider Bob that wants to provide a service to diagnose
whether a patient has breast cancer or not. Bob trains a machine learning classification model
that results in a vector $w$ (say of length 30) and a scalar $b$.
This model is the intellectual property of Bob and he  wants to keep it secret.
Given a patient's medical report, in the form of a vector $x$ (also of length 30),
the classifer predicts that the patient has breast cancer iff $w^Tx>b$.
However, for this task Bob needs access to $x$, which is private data of a customer.

A potential customer Alice might not want to reveal $x$ to Bob because of privacy concerns.
And Bob does not want to reveal $w$ and $b$ because then Alice can steal the model.
SMC can help Alice and Bob compute $w^Tx>b$ securely, such that Alice receives the classifier's
prediction and Bob learns nothing about $x$. Moreover, Alice does not learn anything more about $w$
and $b$ than what is revealed by the prediction. 

To implement this system, Bob can write the code in \tool and this code is shown in Figure~\ref{fig:ex-sml}.
The expression {\tt input1} reads a value from Bob and {\tt input2} reads from Alice.
The language has arrays and simple loops. A loop {\tt for i = [0:N]} repeats its
body {\tt N} times, the loop counter {\tt i} is assigned {\tt 0} in the first iteration,
and is incremented by one after each iteration. Unbounded {\tt while} loops are problematic
from a cryptographic standpoint and our language only permits these simple {\tt for} loops. 
The first loop in Figure~\ref{fig:ex-sml} reads the model $w$ from Bob, the second loop reads
Alice's medical report $x$, and the third loop computes the dot product $w^Tx$.
The last {\tt output} statement sends the result of the comparison $w^Tx>b$ to Alice.
In particular, the ternary {\tt ? :} operator performs a branch and the result is the second (third)
argument if the first argument is true (false).

Our compiler compiles the code described in Figure~\ref{fig:ex-sml} to the C++ code in
Figure~\ref{fig:ex-aby}. An alternative to using \tool is to directly write this C++ code.
However, this code is much more complex. 
There are two phases of this code, circuit generation and circuit execution.
In the first phase, we create a circuit that represents the functionality that we want to compute.
And in the second phase, we run the circuit generated by the first phase and get the results.
The code uses the
{\tt role} variable to decide whether the code is executed by the {\tt SERVER} Bob or by
the {\tt CLIENT} Alice. The variables with names that start with {\tt s\_a\_} denote that
they point to circuit gates that compute arithmetic shares. In particular, {\tt s\_a\_w[i]} 
is an arithmetic share of {\tt w[i]}.
We are using arithmetic sharing as the dot product computation is more efficient in arithmetic
than using boolean sharing.
After the dot product computation (the second loop), {\tt s\_a\_acc}  points to the gate
which would compute the arithmetic share of the final value of {\tt acc}.
The {\tt PutA2Y gate} is a conversion gate that converts an arithmetic share of
{\tt acc} to a Yao share. We need Yao shares for the comparison operator ({\tt >}).
This operator cannot be implemented on arithmetic shares and needs a boolean sharing like Yao.
After the {\tt PutGTGate} for comparison, we generate gates that create Yao shares of zero and one.
Next, a multiplexer gate {\tt PutMUXGate} encodes the logic of the {\tt ? :} operator.
Finally, we add an output gate by {\tt PutOUTGate}.

Next, we execute this circuit using {\tt ExecCircuit} and Alice reads the output result.
Our compiler automatatically compiles Figure~\ref{fig:ex-sml} to Figure~\ref{fig:ex-aby}.
In particular, it manages the shares and inserts conversions between different sharing schemes
wherever necessary. 
On small examples, we have found that the compiler generated C++ code from a \tool implementation 
is almost as efficient as manually written C++ code.
