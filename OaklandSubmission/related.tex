\section{Related work}
\label{sec:related}

%\divya{Related Work: writing some citations here to be used appropriately.}
%\begin{enumerate}
%\item Secure Computation of MIPS Machine Code https://eprint.iacr.org/2015/547
%\item TASTY https://eprint.iacr.org/2010/365.pdf. Does not have language; user has to know what parts in HE and what in Yao and writes something similar to ABY
%\item ABY cites many papers on first page of intro for using a mix of HE and boolean MPC; but they didnt give much gain because HE is expensive
%\nc{I will look into this and write.}
%\item verilog, hardware tool chain paper http://encrypto.de/papers/DDKSSZ15.pdf
%\item automatic choosing between HE and Yao https://eprint.iacr.org/2014/200.pdf 
%I think this one still does not have a language; I don't know how to specify function
 

%\end{enumerate}
\noindent\textbf{Automatic Generation of SMC protocols.}
There has been vast literature on the automatic generation of SMC protocols. These works all provide tools at various levels of abstraction that help a programmer automatically generate cryptographic protocols for various functionalities. These levels can be classified as follows: 
\\\\
\noindent{\bf Function Description:} Tools at this level are a language (similar to \tool) where the programmer can specify the functionality to be securely implemented in a high level language and the compiler compiles the functionality to generate a secure computation protocol. Such languages do not require the programmer to have expertise in writing cryptographic protocols. All such existing languages in literature are built with only one backend: Fairplay's Secure Function Definition Language (SFDL)~\cite{fairplay,fairplaymp} compiles high-level C or Pascal like programs into boolean circuits that are then evaluated using garbled circuits~\cite{yao} for the two-party case and distributed garbled circuits~\cite{bmr} for the multi-party case~\cite{bmr}. The Secure Multiparty Computation Language (SMCL)~\cite{smcl} that compiles high-level Java like programs into arithmetic circuits that are then evaluated using the VIFF framework~\cite{viff}. The work of Wysteria~\cite{wysteria} provides a way of writing ``mixed-mode'' programs that combine normal or per-party, local computations, with ``secure'' (joint) computations repeatedly in a seamless manner. This work compiles programs into boolean circuits and uses Choi {\em et al.}~\cite{choi} implementation of the GMW~\cite{gmw} protocol as the backend. The work of Mitchell {\em et al.}~\cite{lambdaps} compiles their language into either a backend that works over arithmetic secret shares or over boolean secret shares using homomorphic encryption~\cite{gentry}. Finally, the work of ObliVM~\cite{oblivm} also shows how to incorporate programs that may read/write portions of the secret data, based on other secrets, without revealing access patterns (using techniques from oblivious RAM~\cite{oram1,oram2}). Their compute is through boolean circuits and the garbling technique. It is to be noted that none of the above works combine arithmetic and boolean computation together within the same program. 
\\\\
\noindent{\bf Protocol Description:} Tools at this level of abstraction provide a set of commands that can be put together to describe efficient secure computation protocols. These tools are at a high level (such as making a call to execute secure computation of an AND gate or a MULT gate over shared inputs). The exact cryptographic protocols that are used as backends to implement these secure computation protocols need not be known to the programmer, but in order to generate efficient protocols for the entire functionality, the programmer must know how the functionality will be broken into components that make calls to various secure computation protocols for sub-functions. As an example, the work of ABY \cite{aby} falls into this category. While, the programmer need not know how ABY implements boolean or arithmetic computation, he or she must know the type of compute (boolean or arithmetic) that is more efficient for specific sub-computations and also explicitly write calls to convert shares from one scheme to another (boolean secret sharing to arithmetic secret sharing and vice-versa). While the work of Kerschbaum {\em et al.}~\cite{kos14} provides a heuristic to automatically select the protocol for various types of sub-computations, one would still need to manually write the program using the share conversion tools of ABY. Similarly, the TASTY tool~\cite{tasty} provides a way to mix both boolean and arithmetic circuits (using homomorphic encryption for the arithmetic compute). As noted by ABY~\cite{aby}, the performance is much poorer than tools like ABY that combine boolean and arithmetic secure computation techniques due to very high conversion costs between homomorphic encryption and boolean shares as well as the cost of homomorphic encryption itself as the security parameter increases. This abstraction requires a fairly involved knowledge of cryptography from the programmer. Other examples include the VIFF framework~\cite{viff} for arithmetic computations, Sharemind~\cite{sharemind} (that provides information-theoretic secure 3-party boolean computation), and the Secure Multiparty Computation language~\cite{nsy04,securemc}. 
\\\\
\noindent{\bf Protocol Implementation:} Tools at this level of abstraction require the programmer to have a deep understanding of how cryptographic secure computation protocols work and the programmer must provide calls to low-level cryptographic building blocks such as oblivious transfer. While the programmer need not know the specific oblivious transfer protocol implemented in the backend, he or she still needs to know how to build a secure computation protocol from such building blocks. This abstraction requires the highest knowledge of cryptography from the programmer. Examples of such tools include L1~\cite{l1} and Qilin~\cite{qilin}.


Other low level implementations of secure computation protocols look to optimize circuits for depth (such as~\cite{ddkssz15}) or provide protocols for MIPS code~\cite{mips} using techniques from ORAM to hide access patterns~\cite{oram1,oram2}.
\\\\
\noindent\textbf{Custom SMC protocols.} Many works have designed specialized, hand-crafted protocols for various secure two-party computation tasks. The reason for doing this was to allow for a mix between arithmetic and boolean computations as a secure computation protocol for a pure boolean circuit would have been very inefficient. Such hand-crafting of protocols require deep cryptography know-how of designing secure computation protocols with various tools such as homomorphic encryption, garbled circuits, oblivious transfer and so on. A sample of such work includes various works on privacy-preserving classification of medical ElectroCardioGram (ECG)~\cite{ecgclassifier}, iris and fingerprint recognition~\cite{irisfingerprint}, remote diagnostics~\cite{remotediagnostics}, private sequence analysis~\cite{sequenceanalysis}, private biometric identification~\cite{biometricidentification}, privacy-preserving matrix factorization and ridge-regression~\cite{matrixfactorization, ridgeregression}, machine-learning classification~\cite{shafindss}, decision trees and forests~\cite{wu}, neural network training and prediction~\cite{secureml,minionn}. As seen from our experiments, the protocols generated by \tool give us comparable execution times as many of the above works with minimal programmer overhead. \nc{What do we want to say here exactly?}

\divya{We need to cite this paper \cite{yao-pipe} for yao pipelining. This technique was also used in \cite{valeriaMatrix,oblivm}}