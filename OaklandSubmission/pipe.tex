\section{Pipelining}
\label{sec:pipe}

We now describe our technique of ``pipelining'' that allows us to compile and execute large programs that would otherwise have not fit in memory (due to the large size of the circuit generated by ABY). We do this securely in a manner such that the underlying backend (such as ABY in this case) does not have to modified in anyway and hence our technique is also compatible with any backend. In more detail, let $P$ be a program in our source language that gets compiled to $P'$ in our target language. In many cases, the ABY circuit generated for $P'$ is very large and cannot fit in memory (in fact, there is an upper limit of $2^{32}$ for the circuit size in ABY and for many natural programs, this upper limit is easily crossed). Without pipelining, we would be unable to compile and execute such a program $P$. In order to overcome this size limit, we do the following: we split the program $P$ into a sequence of smaller programs $Q_1||Q_2||\cdots||Q_k$ (that will be appropriately defined). We compile and execute each $Q_i$ separately, feeding the outputs of one program as state information to the next program. Of course, we have to be careful how we do this so as to not compromise the security of the protocol. More details follow.

Let $P$ be a program that takes as (secret) inputs $x$ and $y$ and produces output $z$ to both parties. Let $P_1||P_2||\cdots||P_k$ be a sequence of programs defined such that the following holds. Define $s_0 = \bot$ (the public empty state). For all $1\leq i\leq k-1$, $P_i$ takes as input $x, y$ and $s_{i-1}$ to produce state information $s_i$. Finally, $P_k$ takes as input $x,y$ and $s_{k-1}$ to produce output $z$. Every program $P_i$ ($1\leq i\leq k$) will be required to be ``sufficiently'' small (as described later) and this will enable our pipelining technique. It is easy to see that any program $P$ can be decomposed as illustrated above into such $P_1||P_2||\cdots||P_k$. Now, if one were to compile $P_i$ into $P'_i$, and execute $P'_i$, the parties can execute $P'_1||P'_2||\cdots||P'_k$ sequentially to obtain $s_1,\cdots,s_{k-1},$ and finally output $z$. At the $i^{\textrm{\tiny{th}}}$ step, the parties would only need to store information proportional to $x,y,s_i$ and $P'_i$ (which will all be much smaller than $P'$). However, if we were to execute the programs as outlined above, it would enable the parties to learn $s_i$ (for all $1\leq i\leq k-1$), which would completely break the security of the protocol.

To overcome this problem, we define a sequence of new programs $Q_i$ ($1\leq i\leq k$) as follows. Once again, define $s_0 = \bot$. Let all $s_i$ be values in some additive ring $(\mathbb{Z},+)$ (in the ABY implementation this ring would simply be the additive ring $(\mathbb{Z}_{2^{32}},+)$ i.e., the additive ring of integers modulo $2^{32}$). This is without loss of generality true (we will also for simplicity assume that each $s_i$ is a single element in the ring, but this restriction can also be easily removed). Let $r_1,\cdots,r_{k-1}$ be a sequence of random values sampled from the same ring $(\mathbb{Z},+)$ by Party A (in our implementation, all $r_i$ values can be generated using a pseudorandom function $F$). Let $Q_1$ be the program that takes as input $x,y, r_1$ (and empty state $s_0$), runs $P_1$ (as defined above) to get $s_1$ and then produces output $o_1 = s_1 + r_1$ {\em only to} Party B\footnote{While the description of our protocol here assumes that the underlying backend supports only one party receiving output, this is only a simplifying assumption, and we can easily modify our protocol in the case where both parties must receive the same output. To do so, we let $Q_1$ output $o_1 = s_1+r_1+t_1$ (where $t_1$ is random and chosen by Party B) and have both parties learn this. We can then appropriately modify the remaining steps as well.}. The output of $Q_1$ for Party A in Step 1 is defined to be $r_1$. Now, every $Q_i$ ($2\leq i\leq k-1$) takes as input $x,y,r_{i-1},o_{i-1},r_i$, runs $P_i$ on inputs $x,y$ and state $o_{i-1}-r_{i-1}$ to get $s_i$ (where $-$ denotes subtraction in the ring $(\mathbb{Z},+)$) and then produces $s_i+r_i$ as output only to Party B. Again, Party A's output for $P_i$ is defined to be $r_i$. $Q_k$ takes as input $x,y,r_{k-1},o_{k-1}$, runs $P_k$ on inputs $x,y$ and state $o_{k-1}-r_{k-1}$ and outputs $z$ to both parties.

Given $P$, we will first split $P$ into $P_1||P_2||\cdots||P_k$ with the guarantee that the ABY circuits generated for every $Q_i$ defined above is small enough to fit into memory. We then compile and execute the $k$ programs $Q_1||Q_2||\cdots||Q_k$ sequentially (freeing up memory usage after every execution) to produce final output $z$ to both parties.

\begin{theorem}[Pipelining security]
Let $P$ be a program in our source language with output $z$, that is split into programs $Q_1||Q_2||\cdots ||Q_k$ (as defined in the pipelining algorithm above) and compiled into protocols $\prot_1||\prot_2\cdots ||\prot_k$ that outputs $r_1||r_2||\cdots||z$ (to Party A) and $o_1||o_2||\cdots||z$ (to Party B), then $\prot$ securely realizes $P$.  
\end{theorem}

\noindent {\em Proof.} From Theorem \ref{theorem:security}, it follows that $\prot_i$ securely realizes $Q_i$ for every $1\leq i\leq k$. Hence, we know that the only information learnt by Party A is $r_1||r_2||\cdots||r_{k-1}||z$ and by Party B is $o_1||o_2||\cdots||o_{k-1}||z$. From the way we defined $r_i$ and $o_i$ ($1\leq i\leq k-1$), to be secret shares of $s_i$, they are individually uniformly random (in $(\mathbb{Z},+)$ and hence perfectly simulatable. From this, the proof of the above theorem follows.