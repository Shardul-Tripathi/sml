\vspace{-0.1in}
\section{Secure code partitioning}
\label{sec:pipe}

\newcommand{\prog}{s}
\newcommand{\progn}{t}
\newcommand{\seq}{||}
\newcommand{\state}{q}

We  now describe our ``secure code partitioning'' technique that
allows \tool to execute programs that require large circuits.
Let $\prog$ be a program in our source language that
generates a circuit $\crct$. For some programs, the circuit $\crct$
can be larger than
the memory size\footnote{In fact, there is
  an upper limit of $2^{32}-1$ gates for the circuit size in ABY but
  for most machines the memory limit is hit first.} and fail to
execute. Partitioning enables us to 
execute such programs via a source to source transformation that is
oblivious to the underlying \mpc backend. Partitioning decomposes the
program $\prog$ into a sequence of smaller \tool programs
$\progn_1,\progn_2,\ldots,\progn_k$ (as defined below) such
that the circuit size
requirement for each of the $\progn_i$ itself is manageable. We compile
and execute each $\progn_i$ sequentially, feeding the outputs of
$\progn_i$ as state
information to $\progn_{i+1}$. We prove our partitioning scheme to be
correct ($\prog$ and sequential execution of $\progn_1,\progn_2,\ldots,\progn_k$ compute
the same functionality) and secure (sequential execution of
$\progn_1,\progn_2,\ldots,\progn_k$ does
not reveal any more information than $\prog$). More details follow.

Let $\prog$ be a program that takes (secret) inputs $x$ from Alice and
$y$ from Bob and produces an output $z$ to both parties. Let
$\prog_1\seq\prog_2\seq\dots\seq\prog_k$ be a decomposition of $\prog$
such that the following holds. Define $\state_0 = \bot$ (the public empty
state). For all
$1\leq i\leq k-1$, $\prog_i$ takes inputs $x, y$ and $\state_{i-1}$ and
outputs state $\state_i$. Finally, $\prog_k$ takes inputs $x, y$ and
$\state_{k-1}$ to  output $z$. It is
possible to decompose any program $\prog$  into such
$\prog_1\seq\prog_2\seq\dots\seq\prog_k$. If \tool generates circuit
$\crct_i$ from
$\prog_i$, the parties can execute
$\crct_1, \crct_2, \dots \crct_k$
sequentially (in a distributed setting)  to obtain
$\state_1,\dots,\state_{k-1},$ and finally output $z$. At the
$i^{\textrm{\tiny{th}}}$ step, the parties only need to store
information proportional to $x,y,\state_{i-1}$ and $\crct_i$ (which is
much smaller than $\crct$). However, this execution enables the
parties to learn $\state_i$ (for all $1\leq i\leq k-1$), which
completely breaks the security.

To overcome this problem, we define a sequence of new programs
$\progn_i$ ($1\leq i\leq k$) as follows. Once again, define $\state_0
= \bot$. Without
loss of generality, let all $\state_i$ be values in some additive ring
$(\mathbb{Z},+)$ (e.g., the additive ring $(\mathbb{Z}_{2^{64}},+)$,
i.e., the additive ring of integers modulo $2^{64}$).
Let $r_1,\cdots,r_{k-1}$ be a sequence of random values sampled from
the same ring $(\mathbb{Z},+)$ by Alice (in our implementation, all
$r_i$ values are generated by a pseudorandom function). Let $\progn_1$
be the program that takes as input $x,r_1$ from Alice and $y$ from Bob
(and empty state $\state_0$), and runs $\prog_1$ (as defined above) to
compute $\state_1$ and then outputs $o_1 = \state_1 + r_1$ {\em only
  to} Bob\footnote{While the description of our protocol here assumes
  that
  the underlying backend supports only one party receiving output,
  this is only a simplifying assumption, and we can easily modify our
  protocol in the case where both parties must receive the same
  output. To do so, we modify $\progn_1$ to output $o_1 = s_1+r_1+r'_1$ to
  both parties (where $r'_1$ is random and chosen by Bob). We can then
  appropriately modify the remaining steps as well.}. Alice's output
from $\progn_1$ is $r_1$. Next, every $\progn_i$ ($2\leq i\leq k-1$)
takes as inputs $x,r_{i-1},r_i$ from Alice and $y,o_{i-1}$ from Bob,
runs $\prog_i$
on inputs $x,y$ and state $\state_{i-1} = (o_{i-1}-r_{i-1})$ (where $-$ denotes
subtraction in the ring $(\mathbb{Z},+)$) and then outputs $\state_i+r_i$
to Bob and $r_i$ to Alice. The last
program $\progn_k$ takes inputs $x,y,r_{k-1},o_{k-1}$, runs $\prog_k$
on inputs $x,y$ and state $\state_{k-1} = (o_{k-1}-r_{k-1})$ and outputs $z$ to both
parties.

Thus, given a decomposition of $\prog$ into
$\prog_1\seq\prog_2\seq\dots\seq\prog_k$, we can use the construction
above to generate programs $\progn_1,\progn_2,\ldots,\progn_k$, that
can be sequentially executed, using the unmodified underlying \mpc
backend. An example illustrating the technique of secure code partitioning is provided in  \appendixref{codepartitioning}. We prove the following theorem for code partitioning:

%% \paragraph{Security.} The following theorem states the correctness and security of
%% code partitioning.

\begin{theorem}[Correctness and security of partitioning]
If $\prog_1||\prog_2||\ldots||\prog_k$ is a decomposition of a program $\prog$, then there exists a sequence of programs $\progn_1, \progn_2, \ldots, \progn_k$ and protocols $\prot_1, \prot_2, \ldots, \prot_k$ such that for all $i$, $\prot_i$ securely realizes $\progn_i$ and  $\prot
= \prot_1,\prot_2,\dots,\prot_k$ securely realizes $s$.
\end{theorem}

\noindent {\em Proof.} Let $\progn_1, \ldots, \progn_k$ be the
sequence of programs as defined above corresponding to the
decomposition $\prog = \prog_1||\prog_2||\ldots||\prog_k$.  For every
$1\leq i\leq k$, let $\prot_i$ be the \mpc protocol output by our
framework for $\progn_i$. Our construction for programs $\progn_i$
ensures that if $\prog$ is well-typed, then for each $1\leq i \leq k$,
$\progn_i$ is well-typed. By \theoremref{security}, $\prot_i$,
the \mpc protocol that evaluates the circuit generated by $\progn_i$,
securely realizes $\progn_i$. That is, for every $1\leq i \leq k-1$,
the $\prot_i$ provides observations $r_i$ to Alice and $o_i$
to Bob. Protocol $\prot_k$ provides observation $z$ to both Alice
and Bob. Finally, since $r_i$ and $o_i$ ($1\leq i\leq k-1$) are
individually uniformly random (in $(\mathbb{Z},+)$, outputs received
by the adversary can be simulated given the final output $z$.


%\begin{theorem}[Correctness and security of partitioning]
%Let $\prog$ be a program in our source language with output $z$, that
%is decomposed into programs
%$\prog'_1\seq\prog'_2\seq\dots\seq\prog'_k$ (as defined in
%the partioning procedure above) and compiled into the protocol $\prot
%= \prot_1\seq\prot_2\dots\seq\prot_k$ that outputs $r_1\seq
%r_2\seq\dots\seq z$ 
%(to Alice) and $o_1\seq o_2\seq\dots||z$ (to Bob), then $\prot$ securely
%realizes $P$.
%\end{theorem}
%
%\noindent {\em Proof.} From \theoremref{security}, it follows that
%$\prot_i$ securely realizes $\prog'_i$ for every $1\leq i\leq
%k$. Hence, we know that the only information learnt by Alice is
%$r_1||r_2||\cdots||r_{k-1}||z$ and by Bob is
%$o_1||o_2||\cdots||o_{k-1}||z$. Since $r_i$ and $o_i$ ($1\leq i\leq
%k-1$) are individually uniformly random (in $(\mathbb{Z},+)$, outputs
%received by the adversary can be easily simulated given the final
%output $z$.
\vspace{-0.1in}
\paragraph{Implementing code partitioning.}
We use partitioning for programs that require large
circuits. Specifically, the programmer decomposes the program
$\prog$ into a sequence of small programs
$\prog_1\seq\dots\seq\prog_k$ manually. And then, \tool generates
sequence of programs $\progn_1,\dots\progn_k$ automatically. We then
compile and execute the $k$ programs
$\progn_1,\progn_2,\ldots,\progn_k$ sequentially, freeing up memory
usage after execution of each $\progn_i$.
Automating the manual decomposition step requires an analysis that can 
statically estimate the resource usage of a \tool program and we leave
the construction of such an analysis as future work.% \nc{I changed the heading.}
