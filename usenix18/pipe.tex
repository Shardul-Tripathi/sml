\section{Secure code partitioning}
\label{sec:pipe}

\newcommand{\prog}{s}
\newcommand{\progn}{t}
\newcommand{\seq}{||}
\newcommand{\state}{q}

We  now describe our ``secure code partitioning'' technique that
allows \tool to execute programs that require large circuits.
Let $\prog$ be a program in our source language that
generates a circuit $\crct$. For some programs, the circuit $\crct$
can be larger than
the memory size\footnote{In fact, there is
  an upper limit of $2^{32}-1$ gates for the circuit size in ABY but
  for most machines the memory limit is hit first.} and fail to
execute. Partitioning enables us to 
execute such programs via a source to source transformation that is
oblivious to the underlying \mpc backend. Partitioning decomposes the
program $\prog$ into a sequence of smaller \tool programs
$\progn_1,\progn_2,\ldots,\progn_k$ (as defined below) such
that the circuit size
requirement for each of the $\progn_i$ itself is manageable. We compile
and execute each $\progn_i$ sequentially, feeding the outputs of
$\progn_i$ as state
information to $\progn_{i+1}$. We prove our partitioning scheme to be
correct ($\prog$ and sequential execution of $\progn_1,\progn_2,\ldots,\progn_k$ compute
the same functionality) and secure (sequential execution of
$\progn_1,\progn_2,\ldots,\progn_k$ does
not reveal any more information than $\prog$). More details follow.

Let $\prog$ be a program that takes (secret) inputs $x$ from Alice and
$y$ from Bob and produces an output $z$ to both parties. Let
$\prog_1\seq\prog_2\seq\dots\seq\prog_k$ be a decomposition of $\prog$
such that the following holds. Define $\state_0 = \bot$ (the public empty
state). For all
$1\leq i\leq k-1$, $\prog_i$ takes inputs $x, y$ and $\state_{i-1}$ and
outputs state $\state_i$. Finally, $\prog_k$ takes inputs $x, y$ and
$\state_{k-1}$ to  output $z$. It is
possible to decompose any program $\prog$  into such
$\prog_1\seq\prog_2\seq\dots\seq\prog_k$. If \tool generates circuit
$\crct_i$ from
$\prog_i$, the parties can execute
$\crct_1, \crct_2, \dots \crct_k$
sequentially (in a distributed setting)  to obtain
$\state_1,\dots,\state_{k-1},$ and finally output $z$. At the
$i^{\textrm{\tiny{th}}}$ step, the parties only need to store
information proportional to $x,y,\state_{i-1}$ and $\crct_i$ (which is
much smaller than $\crct$). However, this execution enables the
parties to learn $\state_i$ (for all $1\leq i\leq k-1$), which
completely breaks the security.

To overcome this problem, we define a sequence of new programs
$\progn_i$ ($1\leq i\leq k$) as follows. Once again, define $\state_0
= \bot$. Without
loss of generality, let all $\state_i$ be values in some additive ring
$(\mathbb{Z},+)$ (e.g., the additive ring $(\mathbb{Z}_{2^{64}},+)$,
i.e., the additive ring of integers modulo $2^{64}$).
Let $r_1,\cdots,r_{k-1}$ be a sequence of random values sampled from
the same ring $(\mathbb{Z},+)$ by Alice (in our implementation, all
$r_i$ values are generated by a pseudorandom function). Let $\progn_1$
be the program that takes as input $x,r_1$ from Alice and $y$ from Bob
(and empty state $\state_0$), and runs $\prog_1$ (as defined above) to
compute $\state_1$ and then outputs $o_1 = \state_1 + r_1$ {\em only
  to} Bob\footnote{While the description of our protocol here assumes
  that
  the underlying backend supports only one party receiving output,
  this is only a simplifying assumption, and we can easily modify our
  protocol in the case where both parties must receive the same
  output. To do so, we modify $\progn_1$ to output $o_1 = s_1+r_1+r'_1$ to
  both parties (where $r'_1$ is random and chosen by Bob). We can then
  appropriately modify the remaining steps as well.}. Alice's output
from $\progn_1$ is $r_1$. Next, every $\progn_i$ ($2\leq i\leq k-1$)
takes as inputs $x,r_{i-1},r_i$ from Alice and $y,o_{i-1}$ from Bob,
runs $\prog_i$
on inputs $x,y$ and state $\state_{i-1} = (o_{i-1}-r_{i-1})$ (where $-$ denotes
subtraction in the ring $(\mathbb{Z},+)$) and then outputs $\state_i+r_i$
to Bob and $r_i$ to Alice. The last
program $\progn_k$ takes inputs $x,y,r_{k-1},o_{k-1}$, runs $\prog_k$
on inputs $x,y$ and state $\state_{k-1} = (o_{k-1}-r_{k-1})$ and outputs $z$ to both
parties.

Thus, given a decomposition of $\prog$ into
$\prog_1\seq\prog_2\seq\dots\seq\prog_k$, we can use the construction
above to generate programs $\progn_1,\progn_2,\ldots,\progn_k$, that
can be sequentially executed, using the unmodified underlying \mpc
backend. 

\paragraph{Example of code partitioning.} We now illustrate code partitioning through an example. Consider the functionality in Figure \ref{fig:largecode}. This is a functionality that takes as input two vectors $w$ and $v$ from Alice and two vectors $x$ and $y$ from Bob. It computes two inner products $w^Tx$ and $v^Ty$, compares the first value with the second and returns a boolean value (which is $1$ if $w^Tx>v^Ty$ and $0$ otherwise) to Bob. Now, if we wish to partition this functionality using secure code partitioning, one possible split is as follows into the following three programs\footnote{All arithmetic is over an appropriate ring in the following discussion.}. Partition $1$ (Figure \ref{fig:codepartitioning1}) computes $w^Tx$ and ``secret shares'' the output of this computation between Alice and Bob (Alice's share is $r_1$, a random value, and Bob's share is $o_1 = w^Tx+r_1$). Next, partition $2$ (Figure \ref{fig:codepartitioning2}) computes $v^Ty$ and once again provides Alice with $r_2$ and Bob with $o_2 = v^Ty+r_2$. Finally, partition $3$ (Figure \ref{fig:codepartitioning3}) compares $o_1-r_1$ with $o_2-r_2$ and provides the output to Bob. It is easy to see that the size of the programs $1, 2$ and $3$ (and their corresponding circuits output by the \tool compiler) are smaller than the program in Figure \ref{fig:largecode} and its corresponding circuit, and in particular, smaller than the state that must be maintained between the programs.

\begin{figure}
\begin{lstlisting}[language=C,mathescape=true]
$\mathtt{
uint\;w[30] = input1();\;\;uint\;v[30] = input1();
}$
$\mathtt{
uint\;x[30] = input2();\;\;uint\; y[30] = input2();
}$
$\mathtt{
uint\;acc1 = 0;\;\;uint\;acc2 =0;
}$
$\mathtt{
for\;i\;in\;[0:30]\;
}$
$\mathtt{\{acc1\;=\;acc1\;+\;(w[i]\;\times\;x[i]);\;
}$
$\mathtt{\;\;acc2\;=\;acc2\;+\;(v[i]\;\times\;y[i]);\}
}$
$\mathtt{
output2((acc1 > acc2)\;?\;1\;:\;0)\;\textbf{{\color{blue}//only to party 2}}
}$
\end{lstlisting}
\caption{\tool code for $w^Tx > v^Ty$}
\label{fig:largecode}
\end{figure}

\begin{figure}
\begin{lstlisting}[language=C,mathescape=true]
$\mathtt{
uint\;w[30] = input1();\;\;uint\;r1 = input1();
}$
$\mathtt{
uint\;x[30] = input2();
}$
$\mathtt{
uint\;acc1 = 0;
}$
$\mathtt{
for\;i\;in\;[0:30]\;\{acc1\;=\;acc1\;+\;(w[i]\;\times\;x[i]);\}
}$
$\mathtt{
uint\;o1 = acc1+r1;
}$
$\mathtt{
output2(o1)\;\textbf{{\color{blue}//acc1 is ``secret shared''}}
}$
\end{lstlisting}
\caption{Partition 1: Code for $o_1 = w^Tx+r_1$}
\label{fig:codepartitioning1}
\end{figure}

\begin{figure}
\begin{lstlisting}[language=C,mathescape=true]
$\mathtt{
uint\;v[30] = input1();\;\;uint\;r2 = input1();
}$
$\mathtt{
uint\;y[30] = input2();
}$
$\mathtt{
uint\;acc2 =0;
}$
$\mathtt{
for\;i\;in\;[0:30]\;\{acc2\;=\;acc2\;+\;(v[i]\;\times\;y[i]);\;\}
}$
$\mathtt{
uint\;o2 =acc2+r2;
}$
$\mathtt{
output2(o2)\;\textbf{{\color{blue}//acc2 is ``secret shared''}}
}$
\end{lstlisting}
\caption{Partition 2: Code for $o_2 = v^Ty+r_2$}
\label{fig:codepartitioning2}
\end{figure}

\begin{figure}
\begin{lstlisting}[language=C,mathescape=true]
$\mathtt{
uint\;r1 = input1();\;\;uint\;r2 = input1();
}$
$\mathtt{
uint\;o1 = input2();\;\;uint\; o2 = input2();
}$
$\mathtt{
uint\;acc3 = o1-r1;\;\;uint\;acc4 =o2-r2;
}$
$\mathtt{
output2((acc3 > acc4)\;?\;1\;:\;0)\;\textbf{{\color{blue}//only to party 2}}
}$
\end{lstlisting}
\caption{Partition 3: Code for $(o_1-r_1)>(o_2-r_2)$}
\label{fig:codepartitioning3}
\end{figure}



\paragraph{Security.} The following theorem states the correctness and security of
code partitioning.

\begin{theorem}[Correctness and security of partitioning]
If $\prog_1||\prog_2||\ldots||\prog_k$ is a decomposition of a program $\prog$, then there exists a sequence of programs $\progn_1, \progn_2, \ldots, \progn_k$ and protocols $\prot_1, \prot_2, \ldots, \prot_k$ such that for all $i$, $\prot_i$ securely realizes $\progn_i$ and  $\prot
= \prot_1,\prot_2,\dots,\prot_k$ securely realizes $s$.
\end{theorem}

\noindent {\em Proof.} Let $\progn_1, \ldots, \progn_k$ be the
sequence of programs as defined above corresponding to the
decomposition $\prog = \prog_1||\prog_2||\ldots||\prog_k$.  For every
$1\leq i\leq k$, let $\prot_i$ be the \mpc protocol output by our
framework for $\progn_i$. Our construction for programs $\progn_i$
ensures that if $\prog$ is well-typed, then for each $1\leq i \leq k$,
$\progn_i$ is well-typed. By \theoremref{security}, $\prot_i$,
the \mpc protocol that evaluates the circuit generated by $\progn_i$,
securely realizes $\progn_i$. That is, for every $1\leq i \leq k-1$,
the $\prot_i$ provides observations $r_i$ to Alice and $o_i$
to Bob. Protocol $\prot_k$ provides observation $z$ to both Alice
and Bob. Finally, since $r_i$ and $o_i$ ($1\leq i\leq k-1$) are
individually uniformly random (in $(\mathbb{Z},+)$, outputs received
by the adversary can be simulated given the final output $z$.


%\begin{theorem}[Correctness and security of partitioning]
%Let $\prog$ be a program in our source language with output $z$, that
%is decomposed into programs
%$\prog'_1\seq\prog'_2\seq\dots\seq\prog'_k$ (as defined in
%the partioning procedure above) and compiled into the protocol $\prot
%= \prot_1\seq\prot_2\dots\seq\prot_k$ that outputs $r_1\seq
%r_2\seq\dots\seq z$ 
%(to Alice) and $o_1\seq o_2\seq\dots||z$ (to Bob), then $\prot$ securely
%realizes $P$.
%\end{theorem}
%
%\noindent {\em Proof.} From \theoremref{security}, it follows that
%$\prot_i$ securely realizes $\prog'_i$ for every $1\leq i\leq
%k$. Hence, we know that the only information learnt by Alice is
%$r_1||r_2||\cdots||r_{k-1}||z$ and by Bob is
%$o_1||o_2||\cdots||o_{k-1}||z$. Since $r_i$ and $o_i$ ($1\leq i\leq
%k-1$) are individually uniformly random (in $(\mathbb{Z},+)$, outputs
%received by the adversary can be easily simulated given the final
%output $z$.

\paragraph{Managing circuit sizes using partitioning.}
We use partitioning for programs that require large
circuits. Specifically, the programmer decomposes the program
$\prog$ into a sequence of small programs
$\prog_1\seq\dots\seq\prog_k$ manually. And then, \tool generates
sequence of programs $\progn_1,\dots\progn_k$ automatically. We then
compile and execute the $k$ programs
$\progn_1,\progn_2,\ldots,\progn_k$ sequentially, freeing up memory
usage after execution of each $\progn_i$.
Automating the manual decomposition step requires an analysis that can 
statically estimate the resource usage of a \tool program and we leave
the construction of such an analysis as future work. \nc{Are we trying to say here which part is manual and which part is automatic? This paragraph is a bit unclear to me.}
