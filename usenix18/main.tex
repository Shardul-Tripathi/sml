\documentclass[letterpaper,twocolumn,10pt]{article}
\input{headers}

\usepackage{usenix,epsfig,endnotes}
\begin{document}

%don't want date printed
\date{}

\title{\tool: Programmable, Efficient, and Scalable Secure Two-Party Computation}


%for single author (just remove % characters)
%% \author{
%% {\rm Your N.\ Here}\\
%% Your Institution
%% \and
%% {\rm Second Name}\\
%% Second Institution
%% % copy the following lines to add more authors
%% % \and
%% % {\rm Name}\\
%% %Name Institution
%% } % end author


\maketitle

\subsection*{Abstract}

  %% Secure two-party computation (\mpc) allows two mutually distrusting
  %% parties to compute any function on their joint inputs, without
  %% revealing anything other than the output of the function to one
  %% another.

  %While the application and potential impact of secure computation is virtually limitless, writing an efficient and scalable secure protocol is by no means an easy feat.
% Prior work in designing such protocols, suffered from either a) a lack of programmability (e.g. requiring the programmer to write cryptography-aware circuits for the computation); b) a lack of efficiency for several natural computations (such as machine learning classification tasks); or c) required cryptographers to design hand-crafted protocols for various applications.
We present \tool: a 
%new ``cryptographic-cost aware'' 
secure two-party computation (\mpc) framework that generates efficient
\mpc protocols from high-level, easy-to-write, programs.
\tool provides formal correctness and security guarantees while maintaining performance and scalability.
%% that 
%% %contain absolutely no cryptographic details. Programs in our language 
%% are easy-to-write and are statically verified. 
%Furthermore,
Previous language frameworks, such as CBMC-GC, ObliVM, SMCL, and
Wysteria,
generate protocols that use either arithmetic or boolean
circuits exclusively. Our compiler is the first to generate protocols
that combine both arithmetic sharing and garbled circuits  for better
performance.
%We give the first compiler that generates protocols which combine both arithmetic and boolean circuits
%for better performance compared to protocols that use either arithmetic or boolean circuits exclusively.
We
empirically demonstrate that the
protocols generated by our framework match or outperform (up to
19x)
recent works that provide hand-crafted protocols for various
functionalities such as secure  prediction  and matrix factorization.

\aseem{Usenix TODOs:
  (a) Explain cryptographic cost-awareness better (Reviewer A, Rahul).

  (b) Comment about side-channels (Reviewer A, Aseem).

  (c) Remove the comment about extension to malicious security (Reviewer A, Nishanth/Divya)? \nc{I think we can keep it, but I've added a caveat that a more complete treatment of malicious security is left to future work.}

  (d) Highlight advantages of EzPC more in Section 2 (Reviewer A, Aseem).

  (e) Add proofs and defns to appendix, Usenix has no limit (Reviewer B, Aseem).

  (f) More explanation to Section 4, with a small example (Reviewer B, Nishanth). \nc{Done.}

  (g) Comment about high branches (branches on secrets), we plan to
  support proper declassification in future (Reviewer B, All)?

  (h) Can the compiler reject secure programs -- of course! Type
  systems are inherently conservative. May be we don't need to add
  anything about it (Reviewer B, All)?

  (i) How are optimizations secure (Reviewer B, Divya/Aseem).

  (j) Compiler validation, read about Frigate and add to related work
  (Reviewer C, Aseem).

  (k) Discuss what would it take to handle malicious parties -- may be
  we don't address this (Reviewer C, All)? \nc{Added a little more to conclusions.}

  (l) Limitation of manual partitioning -- it is what it is at this
  point (Reviewer C, All).

  (m) Getting code from others, consistent machine configuration for
  Bost et al. (Reviewer C, Rahul/Nishanth). \nc{Wrote a line.}

  (n) Comment on why are we better than Minion (Reviewer C, Rahul).
}
%\tool provides formal correctness and security guarantees.
%% (up to
%% a 19x factor!).


\graphicspath{{./Images/}}
\DeclareGraphicsExtensions{.pdf,.jpg,.png}

\input{intro}
%\input{fig-ex-sml}
%\input{fig-ex-aby}

\input{ex}
\input{ld}
\input{security}
\input{pipe}
\input{impl}

\input{eval}
\input{train}
\input{related}
\input{conclude}

%\newpage

{\footnotesize \bibliographystyle{acm}
\bibliography{bib}}


%\bibliographystyle{abbrv}
%\bibliography{bib}
%\balance

%\appendix
%\input{app-stash}

\end{document}


