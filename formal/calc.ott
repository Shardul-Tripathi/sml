% minimal + latex + comments
metavar termvar, x ::=   
  {{ tex \mathit{[[termvar]]} }}

indexvar index, i, j, m, b ::=

grammar

n :: 'n_' ::= {{ com Const }}
  | n + 1    :: M :: incr

s {{ tex m }} :: 's_' ::= {{ com Secret label }}
  | asecret  :: :: ASecret {{ tex \mathcal{A} }}
  | bsecret  :: :: BSecret {{ tex \mathcal{B} }}

l {{ tex \ell }} :: 'l_' ::= {{ com Label }}
  | public  ::   :: Public  {{ tex \mathcal{P} }}
  | s       ::   :: ASecret
  | lab bt  :: M :: LabelOf {{ tex \mathsf{label}([[bt]]) }}

bt {{ tex \sigma }} :: 'bt_' ::= {{ com Base type }}
  | l uint      :: :: UInt {{ tex \mathsf{uint}^{[[l]]} }}
  | l bool      :: :: Bool  {{ tex \mathsf{bool}^{[[l]]} }}

t {{ tex \tau }} :: 't_' ::= {{ com Type }}
  | bt               ::   :: Baset  {{ tex [[bt]] }}
  | bt array         ::   :: Array  {{ tex [[bt]] [\;] }}
  | G ( x )          :: M :: EnvLookup

cons {{ tex c }} :: 'cons_' ::= {{ com Constant }}
  | n                             ::  :: Num   {{ tex [[n]] }}
  | true                          ::  :: True  {{ tex \top }}
  | false                         ::  :: False {{ tex \bot }}

e :: 'e_' ::=  {{ com Expression }}
  | cons                          ::  :: Constant
  | x                             ::  :: Var
  | e1 + l e2                     ::  :: SAdd  {{ tex [[e1]] +_{[[l]]} [[e2]] }}
  | e1 * l e2                     ::  :: SMult {{ tex [[e1]] \times_{[[l]]} [[e2]] }}
  | cond l e e1 e2                ::  :: CondE  {{ tex [[cond]]_{[[l]]}([[e]], [[e1]], [[e2]]) }}
  | e1 > l e2                     ::  :: Relop  {{ tex [[e1]] >_{[[l]]} [[e2]] }}
  | x [ e ]                       ::  :: ArrayRead
  | e |> s                        ::  :: Coerce {{ tex [[e]] \rhd [[s]] }}

c {{ tex s }} :: 'c_' ::= {{ com Statement }}
  | t x                                ::   :: Decl
  | x := e                             ::   :: Assignment
  | foreach x in n1 to n2 do c         ::   :: For  {{ tex [[for]]([[x]] := [[n1]]; [[x]] \leq [[n2]]; x := x + 1)\;[[c]] }}
  | x [ e1 ] := e2                     ::   :: ArrayWrite
  | if e c1 c2                         ::   :: If   {{ tex [[if]]([[e]], [[c1]], [[c2]]) }}
  | out e                              ::   :: Output
  | c1 ; c2                            ::   :: Sequence
  | { c }                              :: M :: Paren

G {{ tex \Gamma }} :: 'G_' ::= {{ com Type environment }}
  | emp        ::   :: Empty    {{ tex \cdot }}
  | G , x : t  ::   :: Binding
  | whateverG  :: M :: Whatever {{ tex \_ }}

formula :: formula_ ::=  
   | judgement             :: :: judgement
   | t1 = t2               :: :: teq
   | e1 = e2               :: :: eeq
   | l1 = l2               :: :: leq
   | v1 = v2               :: :: veq
   | v1 = v2 = v3          :: :: veq3
   | n1 gt n2              :: :: ngt        {{ tex [[n1]] > [[n2]] }}
   | n1 geq n2             :: :: ngeq       {{ tex [[n1]] \geq [[n2]] }}
   | formula1 ==> formula2 :: :: implies    {{ tex [[formula1]] \Rightarrow [[formula2]] }}
   | x notin modifies c    :: :: modifesmem {{ tex [[x]] \not\in \mathsf{modifies}([[c]]) }}
   | mapsto                :: :: mapsto     {{ tex \mapsto }}
   | l1 ne l2              :: :: labne      {{ tex [[l1]] \neq [[l2]] }}
   | l1 = l2               :: :: labeq
   | base bt1 = base bt2   :: :: baseEq     {{ tex \mathsf{base}([[bt1]]) = \mathsf{base}([[bt2]]) }}
   | default t = v ; ckt   :: :: defaultt   {{ tex \mathsf{default}([[t]]) = [[v]]; [[ckt]] }}


defns
JCompileE :: '' ::=

defn
G |- e : t ~> e' :: :: compile :: 's_' {{ tex [[G]] \vdash [[e]] : [[t]] \leadsto [[e']] }}
by

-------------------------- :: const
G |- n : public uint ~> n

-------------------------------- :: true
G |- true : public bool ~> true

---------------------------------- :: false
G |- false : public bool ~> false

G(x) = t
---------------- :: var
G |- x : t ~> x

G |- ei : public uint ~> ei'
----------------------------------------------------- :: padd
G |- e1 + public e2 : public uint ~> e1' + public e2'

G |- ei : asecret uint ~> ei'
-------------------------------------------------------- :: sadd
G |- e1 + public e2 : asecret uint ~> e1' + asecret e2'

G |- ei : public uint ~> ei'
----------------------------------------------------- :: pmult
G |- e1 * public e2 : public uint ~> e1' * public e2'

G |- ei : asecret uint ~> ei'
-------------------------------------------------------- :: smult
G |- e1 * public e2 : asecret uint ~> e1' * asecret e2'

G |- e : public bool ~> e'
G |- ei : bt ~> ei'
------------------------------------------------------- :: pcond
G |- cond public e e1 e2 : bt ~> cond public e' e1' e2'

G |- e : bsecret bool ~> e'
G |- ei : bt ~> ei'
------------------------------------------------------- :: scond
G |- cond public e e1 e2 : bt ~> cond bsecret e' e1' e2'

G |- ei : public uint ~> ei'
------------------------------------------------------ :: pgt
G |- e1 > public e2 : public bool ~> e1' > public e2'

G |- ei : bsecret uint ~> ei'
-------------------------------------------------------- :: sgt
G |- e1 > public e2 : bsecret bool ~> e1' > bsecret e2'

G |- x : bt array ~> x
G |- e : public uint ~> e'
--------------------------- :: aread
G |- x[e] : bt ~> x[e']

G |- e : bt1 ~> e'
base bt1 = base bt2
lab bt2 = s
-------------------------  :: sub
G |- e : bt2 ~> e' |> s


defns
JCompileC :: '' ::=

defn
G |- c ~> c' | G' :: :: ccompile :: 'c_' {{ tex [[G]] \vdash [[c]] \leadsto [[c']] \mid [[G']]}}
by

-------------------------- :: decl
G |- t x ~> t x | G, x:t

G (x) = bt
G |- e : bt ~> e'
--------------------------- :: vassgn
G |- x := e ~> x := e' | G

G, x:public uint |- c ~> c' | whateverG
x notin modifies c
------------------------------------------------------------------- :: for
G |- foreach x in n1 to n2 do c ~> foreach x in n1 to n2 do c' | G

G |- x : bt array ~> x
G |- e1 : public uint ~> e1'
G |- e2 : bt ~> e2'
--------------------------------------- :: awrite
G |- x [e1] := e2 ~> x[e1'] := e2' | G

G |- e : public bool ~> e'
G |- ci ~> ci' | whateverG
--------------------------------------- :: if
G |- if e c1 c2 ~> if e' c1' c2' | G

G |- e : t ~> e'
-------------------------- :: out
G |- out e ~> out e' | G

G |- c1 ~> c1' | G1
G1 |- c2 ~> c2' | G'
----------------------------- :: seq
G |- c1; c2 ~> c1'; c2' | G'

grammar

r :: 'r_' ::= {{ com Wire id range }}
  | next_range ( )        :: M :: Next  {{ tex \mathsf{next\_range}() }}

w :: 'w_' ::= {{ com Base value }}
  | cons                          ::  :: Constant
  | r                             ::  :: Range

v :: 'v_' ::= {{ com Value }}
  | w                                 ::   :: BaseValue
  | [ </ wi // i /> ]                 ::   :: Array
  | rho [ x ]                         :: M :: EnvLookup
  | n1 + n2                           :: M :: NAdd
  | n1 * n2                           :: M :: NMult  {{ tex [[n1]] \times [[n2]] }}
  | n1 > n2                           :: M :: NGt
  | w n                               :: M :: NthArr {{ tex [[w]]_{[[n]]} }}
  | v [ n mapsto w ]                  :: M :: ArrUpd {{ tex [[v]][ [[n]] \mapsto [[w]] ] }}

ckt {{ tex \kappa }} :: 'ckt_' ::= {{ com Circuit }}
  | emp                   :: :: Emp  {{ tex \cdot }}
  | add  r1 r2 r3         :: :: Add  {{ tex \oplus([[r1]], [[r2]], [[r3]]) }}
  | mult r1 r2 r3         :: :: Mult {{ tex \otimes([[r1]], [[r2]], [[r3]]) }}
  | mux  r1 r2 r3 r4      :: :: Mux  {{ tex \mathsf{Mux}([[r1]], [[r2]], [[r3]], [[r4]]) }}
  | gt   r1 r2 r3         :: :: Gt   {{ tex \mathsf{Gt}([[r1]], [[r2]], [[r3]]) }}
  | r |> s r'             :: :: Conv {{ tex [[r]] \rhd_{[[s]]} [[r']] }}
  | out r                 :: :: Out  {{ tex \mathsf{Out}([[r]]) }}
  | ckt1 , ckt2           :: :: Seq

rho {{ tex \rho }} :: 'rho_' ::= {{ com Runtime environment }}
  | emp             ::   :: Empty {{ tex \cdot }}
  | rho , x |-> v   ::   :: Map   {{ tex [[rho]][ [[x]] \mapsto [[v]] ] }}
  | rho - x         ::   :: Minus {{ tex [[rho]] \setminus [[x]] }}


defns
JEvalE :: '' ::=

defn
rho |- e !! v ; ckt :: :: eeval :: 'ee_' {{ tex [[rho]] \vdash [[e]] \Downarrow [[v]]; [[ckt]] }}
by

------------------------- :: const
rho |- cons !! cons; emp

------------------------ ::var
rho |- x !! rho[x]; emp

rho |- ei !! ni; ckti
---------------------------------------------- :: padd
rho |- e1 + public e2 !! n1 + n2; ckt1, ckt2

rho |- ei !! ri; ckti
r3 = next_range ()
-------------------------------------------------------- :: sadd
rho |- e1 + asecret e2 !! r3; ckt1, ckt2, add r1 r2 r3

rho |- ei !! ni; ckti
---------------------------------------------- :: pmult
rho |- e1 * public e2 !! n1 * n2; ckt1, ckt2

rho |- ei !! ri; ckti
r3 = next_range ()
-------------------------------------------------------- :: smult
rho |- e1 * asecret e2 !! r3; ckt1, ckt2, mult r1 r2 r3

rho |- e !! true; ckt
rho |- e1 !! v; ckt1
------------------------------------------- :: pcondt
rho |- cond public e e1 e2 !! v; ckt,ckt1

rho |- e !! false; ckt
rho |- e2 !! v; ckt2
------------------------------------------- :: pcondf
rho |- cond public e e1 e2 !! v; ckt,ckt2

rho |- e !! r; ckt
rho |- ei !! ri; ckti
r3 = next_range ()
-------------------------------------------------------------------- :: scond
rho |- cond bsecret e e1 e2 !! r3; ckt, ckt1, ckt2, mux r r1 r2 r3

rho |- ei !! ni; ckti
---------------------------------------------- :: pgt
rho |- e1 > public e2 !! n1 > n2; ckt1, ckt2

rho |- ei !! ri; ckti
r3 = next_range ()
------------------------------------------------------ :: sgt
rho |- e1 > bsecret e2 !! r3; ckt1, ckt2, gt r1 r2 r3

rho |- e !! n; ckt1
rho |- x !! [ </ wi // i /> ]; ckt2
------------------------------------ :: aread
rho |- x[e] !! w n; ckt1, ckt2

rho |- e !! r; ckt
r' = next_range ()
------------------------------------- :: coerce
rho |- e |> s !! r'; ckt, r |> s r'


defns
JEvalC :: '' ::=

defn
rho |- c !! rho' ; ckt :: :: ceval :: 'ec_' {{ tex [[rho]] \vdash [[c]] \Downarrow [[rho']]; [[ckt]] }}
by

default t = v; ckt
--------------------------------- :: decl
rho |- t x !! rho, x |-> v; ckt

rho |- e !! v; ckt
----------------------------------- :: assgn
rho |- x := e !! rho, x |-> v; ckt

n1 gt n2
---------------------------------------------- :: fort
rho |- foreach x in n1 to n2 do c !! rho; emp

n2 geq n1
rho, x|-> n1 |- c !! rho1; ckt1
rho1 - x |- foreach x in n1 + 1 to n2 do c !! rho2; ckt2
--------------------------------------------------------- :: fori
rho |- foreach x in n1 to n2 do c !! rho2; ckt1, ckt2

rho |- x !! [ </ wi // i /> ]; emp
rho |- e1 !! n; ckt1
rho |- e2 !! w; ckt2
-------------------------------------------------------------------------- :: awrite
rho |- x[e1] := e2 !! rho, x |-> [ </ wi // i /> ][n mapsto w]; ckt1, ckt2

rho |- e !! true; ckt1
rho |- c1 !! rho'; ckt2
-------------------------------------- :: ift
rho |- if e c1 c2 !! rho'; ckt1, ckt2

rho |- e !! false; ckt1
rho |- c2 !! rho'; ckt2
-------------------------------------- :: iff
rho |- if e c1 c2 !! rho'; ckt1, ckt2

rho |- e !! r; ckt
--------------------------------- :: out
rho |- out e !! rho; ckt1, out r

rho  |- c1 !! rho1; ckt1
rho1 |- c2 !! rho2; ckt2
---------------------------------- :: seq
rho |- c1; c2 !! rho2; ckt1, ckt2

% rho1, rho2 |- c1 --> rho1', rho2'
% rho1', rho2' |- c2 --> rho1'', rho2''
% ---------------------------------------- :: seq
% rho1, rho2 |- c1; c2 --> rho1'', rho2''

% %   | \ x . t      ::  :: Lam
% %   | t t'         ::  :: App
% %   | ( t )        :: M :: Paren      
% %   | { t / x } t' :: M :: Tsub  

% % v :: 'v_' ::= {{ com value   }}
% %   | \ x . t      ::  :: Lam

% % terminals :: 'terminals_' ::=
% %   | \            ::  :: lambda  {{ tex \lambda }}
% %   | –>          ::  :: red     {{ tex \longrightarrow }}

% % subrules
% %   v <:: t

% % defns
% % Jop :: '' ::=

% %  defn
% %  t1 –> t2 :: ::reduce:: 'r_' {{ com [[t1]] reduces to [[t2]]}} by


% %     --------------------------  :: ax_app
% %     (\x.t12) v2 –>  {v2/x}t12

% %     t1 –> t1'
% %     -------------- :: ctx_app_fun
% %     t1 t –> t1' t

% %     t1 –> t1'
% %     -------------- :: ctx_app_arg
% %     v t1 –> v t1'
