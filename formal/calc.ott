% minimal + latex + comments
metavar termvar, x ::=   
  {{ tex \mathit{[[termvar]]} }}

indexvar index, i, j, m, b ::=

grammar

n :: 'n_' ::= {{ com Const }}
  | n + 1    :: M :: incr

s {{ tex m }} :: 's_' ::= {{ com Secret label }}
  | asecret  :: :: ASecret {{ tex \mathcal{A} }}
  | bsecret  :: :: BSecret {{ tex \mathcal{B} }}

l {{ tex \ell }} :: 'l_' ::= {{ com Label }}
  | public  ::   :: Public  {{ tex \mathcal{P} }}
  | s       ::   :: ASecret
  | lab bt  :: M :: LabelOf {{ tex \mathsf{label}([[bt]]) }}

bt {{ tex \sigma }} :: 'bt_' ::= {{ com Base type }}
  | l uint      :: :: UInt {{ tex \mathsf{uint}^{[[l]]} }}
  | l bool      :: :: Bool  {{ tex \mathsf{bool}^{[[l]]} }}
t {{ tex \tau }} :: 't_' ::= {{ com Type }}
  | bt               ::   :: Baset  {{ tex [[bt]] }}
  | bt array         ::   :: Array  {{ tex [[bt]] [\;] }}
  | G ( x )          :: M :: EnvLookup

cons {{ tex c }} :: 'cons_' ::= {{ com Constant }}
  | n                             ::  :: Num   {{ tex [[n]] }}
  | true                          ::  :: True  {{ tex \top }}
  | false                         ::  :: False {{ tex \bot }}
  | cons1 + cons2                 :: M :: NAdd
  | cons1 > cons2                 :: M :: NGt
  | ( cons )                      :: M :: Paren

se {{ tex e }} :: 'se_' ::= {{ com Source expression }}
  | cons                          ::  :: Constant
  | x                             ::  :: Var
  | se1 + se2                     ::  :: SAdd  {{ tex [[se1]] + [[se2]] }}
  | cond se se1 se2               ::  :: CondE  {{ tex [[cond]]([[se]], [[se1]], [[se2]]) }}
  | se1 > se2                     ::  :: Relop  {{ tex [[se1]] > [[se2]] }}
  | x [ se ]                      ::  :: ArrayRead

sc {{ tex s }} :: 'sc_' ::= {{ com Source statement }}
  | t x                                ::   :: Decl
  | x := se                            ::   :: Assignment
  | foreach x in n1 to n2 do sc        ::   :: For  {{ tex [[for]]([[x]] := [[n1]]; [[x]] \leq [[n2]]; x := x + 1)\;[[sc]] }}
  | x [ se1 ] := se2                   ::   :: ArrayWrite
  | if se sc1 sc2                      ::   :: If   {{ tex [[if]]([[se]], [[sc1]], [[sc2]]) }}
  | out se                             ::   :: Output
  | sc1 ; sc2                          ::   :: Sequence

sv {{ tex v }} :: 'sv_' ::= {{ com Source value }}
  | cons                              ::   :: BaseValue
  | [ </ consi // i /> ]              ::   :: Array
  | srho [ x ]                        :: M :: EnvLookup
  | cons n                            :: M :: NthArr {{ tex [[cons]]_{[[n]]} }}
  | sv [ n mapsto cons ]              :: M :: ArrUpd {{ tex [[sv]][ [[n]] \mapsto [[cons]] ] }}

srho {{ tex \rho }} :: 'srho_' ::= {{ com Source runtime environment }}
  | emp             ::   :: Empty {{ tex \cdot }}
  | srho , x |-> sv ::   :: Map   {{ tex [[srho]][ [[x]] \mapsto [[sv]] ] }}
  | srho - x        :: M :: Minus {{ tex [[srho]] \setminus [[x]] }}

sobs {{ tex O }} :: 'sobs_' ::= {{ com Source observation }}
  | emp              :: :: Emp    {{ tex \cdot }}
  | sv               :: :: Value
  | sobs1 , sobs2    :: :: Seq

defns
JEvalSE :: '' ::=

defn
srho |- se !! sv :: :: seeval :: 'se_' {{ tex [[srho]] \vdash [[se]] \downarrow [[sv]] }}
by

------------------------- :: const
srho |- cons !! cons

--------------------------- ::var
srho |- x !! srho[x]

srho |- sei !! ni
------------------------------------------- :: add
srho |- se1 + se2 !! n1 + n2

srho |- se !! true
srho |- se1 !! sv
------------------------------------------ :: condt
srho |- cond se se1 se2 !! sv

srho |- se !! false
srho |- se2 !! sv
------------------------------------------ :: condf
srho |- cond se se1 se2 !! sv

srho |- sei !! ni
-------------------------------------------- :: gt
srho |- se1 > se2 !! n1 > n2

srho |- se !! n
srho |- x !! [ </ consi // i /> ]
--------------------------------------- :: aread
srho |- x[se] !! cons n


defns
JEvalSC :: '' ::=

defn
srho |- sc !! srho' ; sobs :: :: sceval :: 'sc_' {{ tex [[srho]] \vdash [[sc]] \longrightarrow [[srho']]; [[sobs]] }}
by

default t = sv
----------------------------------- :: decl
srho |- t x !! srho, x |-> sv; emp

srho |- se !! sv
--------------------------------------- :: assgn
srho |- x := se !! srho, x |-> sv; emp

n1 gt n2
------------------------------------------------- :: fort
srho |- foreach x in n1 to n2 do sc !! srho; emp

n2 geq n1
srho, x|-> n1 |- sc !! srho1; sobs1
srho1 |- foreach x in n1 + 1 to n2 do sc !! srho2; sobs2
----------------------------------------------------------- :: fori
srho |- foreach x in n1 to n2 do sc !! srho2; sobs1, sobs2

srho |- x !! [ </ consi // i /> ]
srho |- se1 !! n
srho |- se2 !! cons
--------------------------------------------------------------------------------------- :: awrite
srho |- x[se1] := se2 !! srho, x |-> [ </ consi // i /> ][n mapsto cons]; sobs1, sobs2

srho |- se !! true
srho |- sc1 !! srho'; sobs
-------------------------------------- :: ift
srho |- if se sc1 sc2 !! srho'; sobs

srho |- se !! false
srho |- sc2 !! srho'; sobs
-------------------------------------- :: iff
srho |- if se sc1 sc2 !! srho'; sobs

srho |- se !! sv
-------------------------- :: out
srho |- out se !! srho; sv

srho  |- sc1 !! srho1; sobs1
srho1 |- sc2 !! srho2; sobs2
---------------------------------------- :: seq
srho |- sc1; sc2 !! srho2; sobs1, sobs2


grammar

e {{ tex \widetilde{e} }} :: 'e_' ::=  {{ com Target expression }}
  | cons                          ::  :: Constant
  | x                             ::  :: Var
  | e1 + l e2                     ::  :: SAdd  {{ tex [[e1]] +_{[[l]]} [[e2]] }}
  | cond l e e1 e2                ::  :: CondE  {{ tex [[cond]]_{[[l]]}([[e]], [[e1]], [[e2]]) }}
  | e1 > l e2                     ::  :: Relop  {{ tex [[e1]] >_{[[l]]} [[e2]] }}
  | x [ e ]                       ::  :: ArrayRead
  | e |> s                        ::  :: Coerce {{ tex [[e]] \rhd [[s]] }}

c {{ tex \widetilde{s} }} :: 'c_' ::= {{ com Target statement }}
  | t x                                ::   :: Decl
  | x := e                             ::   :: Assignment
  | foreach x in n1 to n2 do c         ::   :: For  {{ tex [[for]]([[x]] := [[n1]]; [[x]] \leq [[n2]]; x := x + 1)\;[[c]] }}
  | x [ e1 ] := e2                     ::   :: ArrayWrite
  | if e c1 c2                         ::   :: If   {{ tex [[if]]([[e]], [[c1]], [[c2]]) }}
  | out e                              ::   :: Output
  | c1 ; c2                            ::   :: Sequence
  | { c }                              :: M :: Paren

G {{ tex \Gamma }} :: 'G_' ::= {{ com Type environment }}
  | emp        ::   :: Empty    {{ tex \cdot }}
  | G , x : t  ::   :: Binding
  | whateverG  :: M :: Whatever {{ tex \_ }}

formula :: formula_ ::=  
   | judgement             :: :: judgement
   | t1 = t2               :: :: teq
   | e1 = e2               :: :: eeq
   | l1 = l2               :: :: leq
   | v1 = v2               :: :: veq
   | v1 = v2 = v3          :: :: veq3
   | n1 gt n2              :: :: ngt        {{ tex [[n1]] > [[n2]] }}
   | n1 geq n2             :: :: ngeq       {{ tex [[n1]] \geq [[n2]] }}
   | formula1 ==> formula2 :: :: implies    {{ tex [[formula1]] \Rightarrow [[formula2]] }}
   | x notin modifies sc   :: :: modifesmem {{ tex [[x]] \not\in \mathsf{modifies}([[sc]]) }}
   | mapsto                :: :: mapsto     {{ tex \mapsto }}
   | l1 ne l2              :: :: labne      {{ tex [[l1]] \neq [[l2]] }}
   | l1 = l2               :: :: labeq
   | base bt1 = base bt2   :: :: baseEq     {{ tex \mathsf{base}([[bt1]]) = \mathsf{base}([[bt2]]) }}
   | default t = sv        :: :: sdefaultt  {{ tex \mathsf{default}([[t]]) = [[sv]] }}
   | default t = v ; ckt   :: :: defaultt   {{ tex \mathsf{default}([[t]]) = [[v]]; [[ckt]] }}
   | cv1 = cv2             :: :: cveq
   | cons1 = cons2         :: :: conseq
   | srho ~ G              :: :: rgcorres   {{ tex [[srho]] \sim [[G]] }}
   | rho ~ G srho          :: :: srhogcorr  {{ tex [[rho]] \sim_{[[G]]} [[srho]] }}
   | rho |- srho ~> G crho1 , crho2  :: :: circrhocorres   {{ tex [[rho]] \vdash [[srho]] \hookrightarrow_{[[G]]} [[crho1]], [[crho2]] }}


defns
JCompileE :: '' ::=

defn
G |- se : t ~> e :: :: compile :: 's_' {{ tex [[G]] \vdash [[se]] : [[t]] \leadsto [[e]] }}
by

-------------------------- :: const
G |- n : public uint ~> n

-------------------------------- :: true
G |- true : public bool ~> true

---------------------------------- :: false
G |- false : public bool ~> false

G(x) = t
---------------- :: var
G |- x : t ~> x

G |- sei : public uint ~> ei
----------------------------------------------- :: padd
G |- se1 + se2 : public uint ~> e1 + public e2

G |- sei : asecret uint ~> ei
------------------------------------------------- :: sadd
G |- se1 + se2 : asecret uint ~> e1 + asecret e2

G |- se : public bool ~> e
G |- sei : bt ~> ei
----------------------------------------------------- :: pcond
G |- cond se se1 se2 : bt ~> cond public e e1 e2

G |- se : bsecret bool ~> e
G |- sei : bt ~> ei
lab bt = bsecret
------------------------------------------------------ :: scond
G |- cond se se1 se2 : bt ~> cond bsecret e e1 e2

G |- sei : public uint ~> ei
----------------------------------------------- :: pgt
G |- se1 > se2 : public bool ~> e1 > public e2

G |- sei : bsecret uint ~> ei
-------------------------------------------------- :: sgt
G |- se1 > se2 : bsecret bool ~> e1 > bsecret e2

G |- x : bt array ~> x
G |- se : public uint ~> e
--------------------------- :: aread
G |- x[se] : bt ~> x[e]

G |- se : bt1 ~> e
base bt1 = base bt2
lab bt2 = s
-------------------------  :: sub
G |- se : bt2 ~> e |> s


defns
JCompileC :: '' ::=

defn
G |- sc ~> c | G' :: :: ccompile :: 'c_' {{ tex [[G]] \vdash [[sc]] \leadsto [[c]] \mid [[G']]}}
by

-------------------------- :: decl
G |- t x ~> t x | G, x:t

G (x) = bt
G |- se : bt ~> e
--------------------------- :: vassgn
G |- x := se ~> x := e | G

G, x:public uint |- sc ~> c | whateverG
x notin modifies sc
------------------------------------------------------------------- :: for
G |- foreach x in n1 to n2 do sc ~> foreach x in n1 to n2 do c | G

G |- x : bt array ~> x
G |- se1 : public uint ~> e1
G |- se2 : bt ~> e2
--------------------------------------- :: awrite
G |- x [se1] := se2 ~> x[e1] := e2 | G

G |- se : public bool ~> e
G |- sci ~> ci | whateverG
--------------------------------------- :: if
G |- if se sc1 sc2 ~> if e c1 c2 | G

G |- se : bt ~> e
lab bt = s
-------------------------- :: out
G |- out se ~> out e | G

G |- sc1 ~> c1 | G1
G1 |- sc2 ~> c2 | G'
----------------------------- :: seq
G |- sc1; sc2 ~> c1; c2 | G'

grammar

r :: 'r_' ::= {{ com Wire id range }}
  | next_range ( )        :: M :: Next  {{ tex \mathsf{next\_range}() }}

w {{ tex \widetilde{w} }} :: 'w_' ::= {{ com Compiled base value }}
  | cons                          ::  :: Constant
  | r                             ::  :: Range

v {{ tex \widetilde{v} }} :: 'v_' ::= {{ com Compiled value }}
  | w                                 ::   :: BaseValue
  | [ </ wi // i /> ]                 ::   :: Array
  | rho [ x ]                         :: M :: EnvLookup
  | w n                               :: M :: NthArr {{ tex [[w]]_{[[n]]} }}
  | v [ n mapsto w ]                  :: M :: ArrUpd {{ tex [[v]][ [[n]] \mapsto [[w]] ] }}

ckt {{ tex \kappa }} :: 'ckt_' ::= {{ com Circuit }}
  | emp                   :: :: Emp  {{ tex \cdot }}
  | add  r1 r2 r3         :: :: Add  {{ tex \oplus([[r1]], [[r2]], [[r3]]) }}
  | mux  r1 r2 r3 r4      :: :: Mux  {{ tex \mathsf{Mux}([[r1]], [[r2]], [[r3]], [[r4]]) }}
  | gt   r1 r2 r3         :: :: Gt   {{ tex \mathsf{Gt}([[r1]], [[r2]], [[r3]]) }}
  | r1 |> s r2            :: :: Conv {{ tex [[r1]] \rhd_{[[s]]} [[r2]] }}
  | out r                 :: :: Out  {{ tex \mathsf{Out}([[r]]) }}
  | ckt1 , ckt2           :: :: Seq

rho {{ tex \widetilde{\rho} }} :: 'rho_' ::= {{ com Runtime environment }}
  | emp             ::   :: Empty {{ tex \cdot }}
  | rho , x |-> v   ::   :: Map   {{ tex [[rho]][ [[x]] \mapsto [[v]] ] }}
  | rho - x         :: M :: Minus {{ tex [[rho]] \setminus [[x]] }}


defns
JEvalE :: '' ::=

defn
rho |- e !! v ; ckt :: :: eeval :: 'ee_' {{ tex [[rho]] \vdash [[e]] \Downarrow [[v]]; [[ckt]] }}
by

------------------------- :: const
rho |- cons !! cons; emp

------------------------ ::var
rho |- x !! rho[x]; emp

rho |- ei !! ni; ckti
---------------------------------------------- :: padd
rho |- e1 + public e2 !! n1 + n2; ckt1, ckt2

rho |- ei !! ri; ckti
r3 = next_range ()
-------------------------------------------------------- :: sadd
rho |- e1 + asecret e2 !! r3; ckt1, ckt2, add r1 r2 r3

rho |- e !! true; ckt
rho |- e1 !! v; ckt1
------------------------------------------- :: pcondt
rho |- cond public e e1 e2 !! v; ckt,ckt1

rho |- e !! false; ckt
rho |- e2 !! v; ckt2
------------------------------------------- :: pcondf
rho |- cond public e e1 e2 !! v; ckt,ckt2

rho |- e !! r; ckt
rho |- ei !! ri; ckti
r3 = next_range ()
-------------------------------------------------------------------- :: scond
rho |- cond bsecret e e1 e2 !! r3; ckt, ckt1, ckt2, mux r r1 r2 r3

rho |- ei !! ni; ckti
---------------------------------------------- :: pgt
rho |- e1 > public e2 !! n1 > n2; ckt1, ckt2

rho |- ei !! ri; ckti
r3 = next_range ()
------------------------------------------------------ :: sgt
rho |- e1 > bsecret e2 !! r3; ckt1, ckt2, gt r1 r2 r3

rho |- e !! n; ckt1
rho |- x !! [ </ wi // i /> ]; ckt2
------------------------------------ :: aread
rho |- x[e] !! w n; ckt1, ckt2

rho |- e !! r; ckt
r' = next_range ()
------------------------------------- :: coerce
rho |- e |> s !! r'; ckt, r |> s r'


defns
JEvalC :: '' ::=

defn
rho |- c !! rho' ; ckt :: :: ceval :: 'ec_' {{ tex [[rho]] \vdash [[c]] \Longrightarrow [[rho']]; [[ckt]] }}
by

default t = v; ckt
--------------------------------- :: decl
rho |- t x !! rho, x |-> v; ckt

rho |- e !! v; ckt
----------------------------------- :: assgn
rho |- x := e !! rho, x |-> v; ckt

n1 gt n2
---------------------------------------------- :: fort
rho |- foreach x in n1 to n2 do c !! rho; emp

n2 geq n1
rho, x|-> n1 |- c !! rho1; ckt1
rho1 |- foreach x in n1 + 1 to n2 do c !! rho2; ckt2
--------------------------------------------------------- :: fori
rho |- foreach x in n1 to n2 do c !! rho2; ckt1, ckt2

rho |- x !! [ </ wi // i /> ]; emp
rho |- e1 !! n; ckt1
rho |- e2 !! w; ckt2
-------------------------------------------------------------------------- :: awrite
rho |- x[e1] := e2 !! rho, x |-> [ </ wi // i /> ][n mapsto w]; ckt1, ckt2

rho |- e !! true; ckt1
rho |- c1 !! rho'; ckt2
-------------------------------------- :: ift
rho |- if e c1 c2 !! rho'; ckt1, ckt2

rho |- e !! false; ckt1
rho |- c2 !! rho'; ckt2
-------------------------------------- :: iff
rho |- if e c1 c2 !! rho'; ckt1, ckt2

rho |- e !! r; ckt
--------------------------------- :: out
rho |- out e !! rho; ckt, out r

rho  |- c1 !! rho1; ckt1
rho1 |- c2 !! rho2; ckt2
---------------------------------- :: seq
rho |- c1; c2 !! rho2; ckt1, ckt2

grammar

cv {{ tex \widehat{c} }} :: 'cv_' ::= {{ com Circuit value (share) }}
  | enc cons s 1     ::   ::  Share1  {{ tex \mathcal{E}^{[[s]]}_{1}([[cons]]) }}
  | enc cons s 2     ::   ::  Share2  {{ tex \mathcal{E}^{[[s]]}_{2}([[cons]]) }}
  | crho [ r ]       :: M ::  Lookup

crho {{ tex \widehat{\rho} }} :: 'crho_' ::= {{ com Circuit environment }}
  | emp                ::   :: Empty {{ tex \cdot }}
  | crho , r |-> cv ::   :: Map   {{ tex [[crho]][ [[r]] \mapsto [[cv]] ] }}


defns
JEvalCirc :: '' ::=

defn
crho1 , crho2 |- ckt !! crho1' , crho2' ; sobs :: :: circeval :: 'ckt_' {{ tex [[crho1]], [[crho2]] \vdash [[ckt]] \longmapsto [[crho1']], [[crho2']]; [[sobs]] }}
by

------------------------------------------  :: emp
crho1, crho2 |- emp !! crho1, crho2; emp

crho1[r1] = enc n1 asecret 1
crho2[r1] = enc n1 asecret 2
crho1[r2] = enc n2 asecret 1
crho2[r2] = enc n2 asecret 2
--------------------------------------------------------------------------------------------------------------------- :: add
crho1, crho2 |- add r1 r2 r3 !! crho1, r3 |-> enc (n1 + n2) asecret 1 , crho2, r3 |-> enc (n1 + n2) asecret 2; emp

crho1[r1] = enc true bsecret 1
crho2[r1] = enc true bsecret 2
crho1[r2] = enc cons bsecret 1
crho2[r2] = enc cons bsecret 2
------------------------------------------------------------------------------------------------------------ :: muxt
crho1, crho2 |- mux r1 r2 r3 r4 !! crho1, r4 |-> enc cons bsecret 1 , crho2, r4 |-> enc cons bsecret 2; emp

crho1[r1] = enc false bsecret 1
crho2[r1] = enc false bsecret 2
crho1[r3] = enc cons bsecret 1
crho2[r3] = enc cons bsecret 2
------------------------------------------------------------------------------------------------------------ :: muxf
crho1, crho2 |- mux r1 r2 r3 r4 !! crho1, r4 |-> enc cons bsecret 1 , crho2, r4 |-> enc cons bsecret 2; emp

crho1[r1] = enc n1 bsecret 1
crho2[r1] = enc n1 bsecret 2
crho1[r2] = enc n2 bsecret 1
crho2[r2] = enc n2 bsecret 2
cons = n1 > n2
-------------------------------------------------------------------------------------------------------- :: gt
crho1, crho2 |- gt r1 r2 r3 !! crho1, r3 |-> enc cons bsecret 1 , crho2, r3 |-> enc cons bsecret 2; emp

crho1[r1] = enc cons s1 1
crho2[r1] = enc cons s1 2
------------------------------------------------------------------------------------------- :: coerce
crho1, crho2 |- r1 |> s r2 !! crho1, r2 |-> enc cons s 1 , crho2, r2 |-> enc cons s 2; emp


crho1[r] = enc cons s 1
crho2[r] = enc cons s 2
-------------------------------------------- :: out
crho1, crho2 |- out r !! crho1, crho2; cons

crho1, crho2 |- ckt1 !! crho1', crho2'; sobs1
crho1', crho2' |- ckt2 !! crho1'', crho2''; sobs2
-------------------------------------------------------------- :: seq
crho1, crho2 |- ckt1, ckt2 !! crho1'', crho2''; sobs1, sobs2
