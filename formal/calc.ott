% minimal + latex + comments
metavar termvar, x ::=   
  {{ tex \mathit{[[termvar]]} }}

indexvar index, i, j, n, m, b ::=

grammar

s :: 's_' ::= {{ com Secret label }}
  | asecret  :: :: ASecret {{ tex \mathcal{A} }}
  | bsecret  :: :: BSecret {{ tex \mathcal{B} }}

l {{ tex \ell }} :: 'l_' ::= {{ com Label }}
  | public  :: :: Public  {{ tex \mathcal{P} }}
  | s       :: :: ASecret

bt {{ tex \sigma }} :: 'bt_' ::= {{ com Base type }}
  | uint b    :: :: UIntb {{ tex \mathsf{uint}_{[[b]]} }}
  | bool      :: :: Bool  {{ tex \mathsf{bool} }}

t {{ tex \tau }} :: 't_' ::= {{ com Type }}
  | l bt               :: :: Baset  {{ tex [[bt]]^{[[l]]} }}
  | l uint b array n   :: :: Array  {{ tex \mathsf{uint}^{ [[l]] }_{ [[b]] } [\;]_{ [[n]] } }}
  | G ( x )            :: M :: EnvLookup

e :: 'e_' ::=  {{ com Expression }}
  | b n                           ::  :: Const {{ tex [[n]]_{[[b]]} }}
  | x                             ::  :: Var
  | e1 + e2                       ::  :: Binop {{ tex [[e1]] \oplus [[e2]] }}
  | e1 ? e2 : e3                  ::  :: CondE {{ tex [[e1]]\:?\:[[e2]]\::\:[[e3]] }}
  | e1 > e2                       ::  :: Relop
  | x [ </ ei // i IN 1 .. n /> ] ::  :: ArrayRead
  | e1 + s e2                     ::  :: Sbinop {{ tex [[e1]] \oplus_{[[s]]} [[e2]] }}
  | mux s e e1 e2                 ::  :: Mux    {{ tex [[mux]]_{[[s]]}\;[[e]]\;[[e1]]\;[[e2]] }}
  | e1 > s e2                     ::  :: Sgt    {{ tex [[e1]] >_{[[s]]} [[e2]] }}
  | e |> l                        ::  :: Coerce {{ tex [[e]] \rhd [[l]] }}

c :: 'c_' ::= {{ com Command }}
  | t x                                ::   :: Decl
  | x := e                             ::   :: Assignment
  | foreach x in n to m do c           ::   :: For  {{ tex [[for]]\;[[x]]\;\in\;[ [[n]] \dots [[m]] ]\;[[do]]\; [[c]] }}
  | x [ </ ei // i IN 1 .. n /> ] := e ::   :: ArrayWrite
  | if e c1 c2                         ::   :: If
  | out e                              ::   :: Output
  | c1 ; c2                            ::   :: Sequence
  | { c }                              :: M :: Paren

G {{ tex \Gamma }} :: 'G_' ::= {{ com Type environment }}
  | emp        ::   :: Empty    {{ tex \cdot }}
  | G , x : t  ::   :: Binding
  | whateverG  :: M :: Whatever {{ tex \_ }}

formula :: formula_ ::=  
   | judgement             :: :: judgement
   | t1 = t2               :: :: teq
   | e1 = e2               :: :: eeq
   | l1 = l2               :: :: leq
   | formula1 ==> formula2 :: :: implies {{ tex [[formula1]] \Rightarrow [[formula2]] }}
   | x notin modifies c    :: :: modifesmem {{ tex [[x]] \not\in \mathsf{modifies}([[c]]) }}

defns
JLattice :: '' ::=

defn
l1 < l2 :: :: lattice :: 'l_' {{ tex [[l1]] \sqsubseteq [[l2]] }}
by


------- :: refl
l < l

----------- :: ps
public < s

-------- :: ss
s1 < s2

defns
JCompileE :: '' ::=

defn
G |- e : t ~> e' :: :: compile :: 's_' {{ tex [[G]] \vdash [[e]] : [[t]] \leadsto [[e']] }}
by


--------------------------------- :: const
G |- b n : public uint b ~> b n

G(x) = t
---------------- :: var
G |- x : t ~> x

G |- ei : public uint b ~> ei'
----------------------------------------- :: pbinop
G |- e1 + e2 : public uint b ~> e1' + e2'

G |- ei : asecret uint b ~> ei'
--------------------------------------------------- :: sbinop
G |- e1 + e2 : asecret uint b ~> e1' + asecret e2'

G |- e : public bool ~> e'
G |- ei : t ~> ei'
--------------------------------------- :: pcond
G |- e ? e1 : e2 : t ~> e' ? e1' : e2'

G |- e : bsecret bool ~> e'
G |- ei : t ~> ei'
---------------------------------------------- :: scond
G |- e ? e1 : e2 : t ~> mux bsecret e' e1' e2'

G |- ei : public uint b ~> ei'
---------------------------------------- :: pgt
G |- e1 > e2 : public bool ~> e1' > e2'

G |- ei : bsecret uint b ~> ei'
------------------------------------------------ :: sgt
G |- e1 > e2 : bsecret bool ~> e1' > bsecret e2'

G |- x : l uint b array n ~> x
G |- ei : public uint b ~> ei'
------------------------------------------------------------------------------- :: aread
G |- x[ </ ei // i IN 1 .. n /> ] : l uint b ~> x[ </ ei' // i IN 1 .. n /> ]

G |- e : l1 bt ~> e'
l1 < l2
----------------------------  :: sub
G |- e : l2 bt ~> e' |> l2


defns
JCompileC :: '' ::=

defn
G |- c ~> c' | G' :: :: ccompile :: 'c_' {{ tex [[G]] \vdash [[c]] \leadsto [[c']] \mid [[G']]}}
by

------------------------- :: decl
G |- t x ~> t x | G, x:t

G (x) = t
G |- e : t ~> e'
--------------------------- :: vassgn
G |- x := e ~> x := e' | G

G, x:public uint b |- c ~> c' | whateverG
x notin modifies c
---------------------------------------------------------------- :: for
G |- foreach x in n to m do c ~> foreach x in n to m do c' | G

G |- x : l uint b array n ~> x
G |- ei : public uint b ~> ei'
G |- e : l uint b ~> e'
------------------------------------------------------------------------------------- :: awrite
G |- x [ </ ei // i IN 1 .. n /> ] := e ~> x [ </ ei' // i IN 1 .. n /> ] := e' | G

G |- e : public bool ~> e'
G |- c1 ~> c1' | whateverG
G |- c2 ~> c2' | whateverG
--------------------------------------- :: if
G |- if e c1 c2 ~> if e' c1' c2' | G

G |- e : t ~> e'
-------------------------- :: out
G |- out e ~> out e' | G

G |- c1 ~> c1' | G1
G1 |- c2 ~> c2' | G'
----------------------------- :: seq
G |- c1; c2 ~> c1'; c2' | G'

% %   | \ x . t      ::  :: Lam
% %   | t t'         ::  :: App
% %   | ( t )        :: M :: Paren      
% %   | { t / x } t' :: M :: Tsub  

% % v :: 'v_' ::= {{ com value   }}
% %   | \ x . t      ::  :: Lam

% % terminals :: 'terminals_' ::=
% %   | \            ::  :: lambda  {{ tex \lambda }}
% %   | –>          ::  :: red     {{ tex \longrightarrow }}

% % subrules
% %   v <:: t

% % defns
% % Jop :: '' ::=

% %  defn
% %  t1 –> t2 :: ::reduce:: 'r_' {{ com [[t1]] reduces to [[t2]]}} by


% %     --------------------------  :: ax_app
% %     (\x.t12) v2 –>  {v2/x}t12

% %     t1 –> t1'
% %     -------------- :: ctx_app_fun
% %     t1 t –> t1' t

% %     t1 –> t1'
% %     -------------- :: ctx_app_arg
% %     v t1 –> v t1'
