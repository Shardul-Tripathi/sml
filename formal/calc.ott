% minimal + latex + comments
metavar termvar, x ::=   
  {{ tex \mathit{[[termvar]]} }}

indexvar index, i, j, m, b ::=

grammar

n :: 'n_' ::= {{ com Const }}

s :: 's_' ::= {{ com Secret label }}
  | asecret  :: :: ASecret {{ tex \mathcal{A} }}
  | bsecret  :: :: BSecret {{ tex \mathcal{B} }}

l {{ tex \ell }} :: 'l_' ::= {{ com Label }}
  | public  :: :: Public  {{ tex \mathcal{P} }}
  | s       :: :: ASecret

bt {{ tex \sigma }} :: 'bt_' ::= {{ com Base type }}
  | uint      :: :: UInt {{ tex \mathsf{uint} }}
  | bool      :: :: Bool  {{ tex \mathsf{bool} }}

t {{ tex \tau }} :: 't_' ::= {{ com Type }}
  | l bt               :: :: Baset  {{ tex [[bt]]^{[[l]]} }}
  | l uint array       :: :: Array  {{ tex \mathsf{uint}^{ [[l]] } [\;] }}
  | G ( x )            :: M :: EnvLookup

e :: 'e_' ::=  {{ com Expression }}
  | n                             ::  :: Const {{ tex [[n]] }}
  | x                             ::  :: Var
  | e1 + e2                       ::  :: Binop {{ tex [[e1]] \oplus [[e2]] }}
  | e1 ? e2 : e3                  ::  :: CondE {{ tex [[e1]]\:?\:[[e2]]\::\:[[e3]] }}
  | e1 > e2                       ::  :: Relop
  | x [ e ]                       ::  :: ArrayRead
  | e1 + s e2                     ::  :: Sbinop {{ tex [[e1]] \oplus_{[[s]]} [[e2]] }}
  | mux s e e1 e2                 ::  :: Mux    {{ tex [[mux]]_{[[s]]}\;[[e]]\;[[e1]]\;[[e2]] }}
  | e1 > s e2                     ::  :: Sgt    {{ tex [[e1]] >_{[[s]]} [[e2]] }}
  | e |> s                        ::  :: Coerce {{ tex [[e]] \rhd [[s]] }}

c :: 'c_' ::= {{ com Command }}
  | t x = e                            ::   :: Decl
  | x := e                             ::   :: Assignment
  | foreach x in n to m do c           ::   :: For  {{ tex [[for]]\;[[x]]\;\in\;[ [[n]] \dots [[m]] ]\;[[do]]\; [[c]] }}
  | x [ e1 ] := e2                     ::   :: ArrayWrite
  | if e c1 c2                         ::   :: If
  | out e                              ::   :: Output
  | c1 ; c2                            ::   :: Sequence
  | { c }                              :: M :: Paren

G {{ tex \Gamma }} :: 'G_' ::= {{ com Type environment }}
  | emp        ::   :: Empty    {{ tex \cdot }}
  | G , x : t  ::   :: Binding
  | whateverG  :: M :: Whatever {{ tex \_ }}

formula :: formula_ ::=  
   | judgement             :: :: judgement
   | t1 = t2               :: :: teq
   | e1 = e2               :: :: eeq
   | l1 = l2               :: :: leq
   | v1 = v2               :: :: veq
   | v1 = v2 = v3          :: :: veq3
   | formula1 ==> formula2 :: :: implies {{ tex [[formula1]] \Rightarrow [[formula2]] }}
   | x notin modifies c    :: :: modifesmem {{ tex [[x]] \not\in \mathsf{modifies}([[c]]) }}

defns
JLattice :: '' ::=

defn
l1 < l2 :: :: lattice :: 'l_' {{ tex [[l1]] \sqsubseteq [[l2]] }}
by


------- :: refl
l < l

----------- :: ps
public < s

-------- :: ss
s1 < s2

defns
JCompileE :: '' ::=

defn
G |- e : t ~> e' :: :: compile :: 's_' {{ tex [[G]] \vdash [[e]] : [[t]] \leadsto [[e']] }}
by


-------------------------- :: const
G |- n : public uint ~> n

G(x) = t
---------------- :: var
G |- x : t ~> x

G |- ei : public uint ~> ei'
--------------------------------------- :: pbinop
G |- e1 + e2 : public uint ~> e1' + e2'

G |- ei : asecret uint ~> ei'
------------------------------------------------- :: sbinop
G |- e1 + e2 : asecret uint ~> e1' + asecret e2'

G |- e : public bool ~> e'
G |- ei : t ~> ei'
--------------------------------------- :: pcond
G |- e ? e1 : e2 : t ~> e' ? e1' : e2'

G |- e : bsecret bool ~> e'
G |- ei : t ~> ei'
---------------------------------------------- :: scond
G |- e ? e1 : e2 : t ~> mux bsecret e' e1' e2'

G |- ei : public uint ~> ei'
--------------------------------------- :: pgt
G |- e1 > e2 : public bool ~> e1' > e2'

G |- ei : bsecret uint ~> ei'
------------------------------------------------ :: sgt
G |- e1 > e2 : bsecret bool ~> e1' > bsecret e2'

G |- x : l uint array ~> x
G |- e : public uint ~> e'
----------------------------- :: aread
G |- x[e] : l uint ~> x[e']

G |- e : l bt ~> e'
----------------------------  :: sub
G |- e : s bt ~> e' |> s


defns
JCompileC :: '' ::=

defn
G |- c ~> c' | G' :: :: ccompile :: 'c_' {{ tex [[G]] \vdash [[c]] \leadsto [[c']] \mid [[G']]}}
by

G |- e : t ~> e'
---------------------------------- :: decl
G |- t x = e ~> t x = e' | G, x:t

G (x) = t
G |- e : t ~> e'
--------------------------- :: vassgn
G |- x := e ~> x := e' | G

G, x:public uint |- c ~> c' | whateverG
x notin modifies c
--------------------------------------------------------------- :: for
G |- foreach x in n to m do c ~> foreach x in n to m do c' | G

G |- x : l uint array ~> x
G |- e1 : public uint ~> e1'
G |- e2 : l uint ~> e2'
--------------------------------------- :: awrite
G |- x [e1] := e2 ~> x[e1'] := e2' | G

G |- e : public bool ~> e'
G |- c1 ~> c1' | whateverG
G |- c2 ~> c2' | whateverG
--------------------------------------- :: if
G |- if e c1 c2 ~> if e' c1' c2' | G

G |- e : t ~> e'
-------------------------- :: out
G |- out e ~> out e' | G

G |- c1 ~> c1' | G1
G1 |- c2 ~> c2' | G'
----------------------------- :: seq
G |- c1; c2 ~> c1'; c2' | G'

grammar

bv {{ tex w }} :: 'bv_' ::= {{ com Runtime base values }}
  | n                 ::   :: Const  {{ tex [[n]] }}
  | true              ::   :: True   {{ tex \mathsf{true} }}
  | false             ::   :: False  {{ tex \mathsf{false} }}
  | bv s one          ::   :: Share1 {{ tex [[bv]]^{[[s]], 1} }}
  | bv s two          ::   :: Share2 {{ tex [[bv]]^{[[s]], 2} }}
  | n1 + n2           :: M :: PAdd   {{ tex [[n1]] \oplus [[n2]] }}
  | n1 > n2           :: M :: PGt    {{ tex [[n1]] > [[n2]] }}
  | ( bv )            :: M :: Paren

v :: 'v_' ::= {{ com Runtime values }}
  | bv                 ::   :: BaseValue
  | [ </ vi // i /> ]  ::   :: Array
  | rho [ x ]          :: M :: Lookup    {{ tex [[rho]][ [[x]] ] }}
  | v n                :: M :: ArrayRead {{ tex [[v]]_{[[n]]} }}
  | ( v )              :: M :: Paren
  | v |> s             :: M :: Coerce    {{ tex [[v]] \rhd [[s]] }}

rho {{ tex \rho }} :: 'rho_' ::= {{ com Runtime environment }}
  | emp             ::   :: Empty {{ tex \cdot }}
  | rho , x |-> v   ::   :: Map   {{ tex [[rho]][ [[x]] \mapsto [[v]] ] }}
  | rho [ x |-> v ] :: M :: Add   {{ tex [[rho]][ [[x]] \mapsto [[v]] ] }}


defns
JEvalE :: '' ::=

defn
rho1 , rho2 |- e !! v1 , v2 :: :: eeval :: 'ee_' {{ tex [[rho1]], [[rho2]] \vdash [[e]] \Downarrow [[v1]], [[v2]] }}
by

-------------------------- :: const
rho1, rho2 |- n !! n, n

rho1[x] = rho2[x] = v
------------------------- :: pvar
rho1, rho2 |- x !! v, v

rho1[x] = bv s one
rho2[x] = bv s two
-------------------------------------- :: svar
rho1, rho2 |- x !! bv s one, bv s two

rho1, rho2 |- ei !! ni, ni
------------------------------------------ :: pbinop
rho1, rho2 |- e1 + e2 !! n1 + n2, n1 + n2

rho1, rho2 |- e !! true, true
rho1, rho2 |- e1 !! v1, v2
------------------------------------- :: pcondt
rho1, rho2 |- e ? e1 : e2 !! v1, v2

rho1, rho2 |- e !! false, false
rho1, rho2 |- e2 !! v1, v2
------------------------------------ :: pcondf
rho1, rho2 |- e ? e1 : e2 !! v1, v2

rho1, rho2 |- ei !! ni, ni
------------------------------------------ :: pgt
rho1, rho2 |- e1 > e2 !! n1 > n2, n1 > n2

rho1, rho2 |- e !! n, n
rho1, rho2 |- x !! [ </ v1i // i /> ], [ </ v2i // i /> ]
--------------------------------------------------------- :: aread
rho1, rho2 |- x[e] !! v1 n, v2 n

rho1, rho2 |- ei !! ni s one, ni s two
------------------------------------------------------------ :: sbinop
rho1, rho2 |- e1 + s e2 !! (n1 + n2) s one, (n1 + n2) s two

rho1, rho2 |- e !! true s one, true s two
rho1, rho2 |- e1 !! v1, v2
------------------------------------------- :: scondt
rho1, rho2 |- mux s e e1 e2 !! v1, v2

rho1, rho2 |- e !! false s one , false s two
rho1, rho2 |- e2 !! v1, v2
---------------------------------------------- :: scondf
rho1, rho2 |- mux s e e1 e2 !! v1, v2

rho1, rho2 |- ei !! ni s one, ni s two
-------------------------------------------------------------- :: sgt
rho1, rho2 |- e1 > s e2 !! (n1 > n2) s one , (n1 > n2) s two

rho1, rho2 |- e !! v1, v2
----------------------------------------- :: coerce
rho1, rho2 |- e |> s !! v1 |> s, v2 |> s


defns
JEvalC :: '' ::=

defn
rho1 , rho2 |- c --> rho1' , rho2' :: :: ceval :: 'ec_' {{ tex [[rho1]], [[rho2]] \vdash [[c]] \longrightarrow [[rho1']], [[rho2']] }}
by

rho1, rho2 |- e !! v1, v2
--------------------------------------------------------- :: decl
rho1, rho2 |- t x = e --> rho1, x |-> v1, rho2, x |-> v2

rho1, rho2 |- e !! v1, v2
--------------------------------------------------------- :: assgn
rho1, rho2 |- x := e --> rho1, x |-> v1, rho2, x |-> v2



% %   | \ x . t      ::  :: Lam
% %   | t t'         ::  :: App
% %   | ( t )        :: M :: Paren      
% %   | { t / x } t' :: M :: Tsub  

% % v :: 'v_' ::= {{ com value   }}
% %   | \ x . t      ::  :: Lam

% % terminals :: 'terminals_' ::=
% %   | \            ::  :: lambda  {{ tex \lambda }}
% %   | –>          ::  :: red     {{ tex \longrightarrow }}

% % subrules
% %   v <:: t

% % defns
% % Jop :: '' ::=

% %  defn
% %  t1 –> t2 :: ::reduce:: 'r_' {{ com [[t1]] reduces to [[t2]]}} by


% %     --------------------------  :: ax_app
% %     (\x.t12) v2 –>  {v2/x}t12

% %     t1 –> t1'
% %     -------------- :: ctx_app_fun
% %     t1 t –> t1' t

% %     t1 –> t1'
% %     -------------- :: ctx_app_arg
% %     v t1 –> v t1'
